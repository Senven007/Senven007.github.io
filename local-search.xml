<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据交互之Restful API</title>
    <link href="/2021/05/17/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B9%8BRestful%20API/"/>
    <url>/2021/05/17/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B9%8BRestful%20API/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Restful-API？"><a href="#什么是Restful-API？" class="headerlink" title="什么是Restful API？"></a>什么是Restful API？</h2><p>Restful API 从字面就可以知道，他是rest式的接口，所以就要先了解什么是rest。rest 不是一个技术，也不是一个协议。rest 指的是一组架构约束条件和原则，提供了一个新的架构设计思路，满足这些约束条件和原则的应用程序或设计就是 RESTful。在REST规则中，有两个基础概念：对象、行为。对象就是我们要操作的对象，例如添加用户的操作，那么对象就是user</p><p>行为有4种常用的：查看、创建、编辑、删除</p><p>rest的提出者很巧妙的利用http现有方法来对应这4种行为：</p><p>GET - 查看<br>POST - 创建<br>PUT - 编辑<br>DELETE - 删除</p><h2 id="为什么用Restful-API？"><a href="#为什么用Restful-API？" class="headerlink" title="为什么用Restful API？"></a>为什么用Restful API？</h2><p>例如常用的MVC结构中，前后端的融合还是比较紧密的，用户访问一个网址，例如：<a href="http://www.91tuoke.com/a.php%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%85%88%E5%8F%91%E9%80%81%E5%88%B0%E5%8A%A8%E6%80%81php%E5%A4%84%E7%90%86%EF%BC%8Cphp%E4%B8%AD%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF%E6%9D%A5%E8%BE%93%E5%87%BA%E6%98%BE%E7%A4%BA%E7%BB%99%E7%94%A8%E6%88%B7%E3%80%82">http://www.91tuoke.com/a.php，请求先发送到动态php处理，php中处理逻辑，然后使用页面模板来输出显示给用户。</a></p><p>以前用户主要就是用浏览器访问，这样的结构没什么问题，但现在移动客户端越来越重要，显然不能使用这个结构，需要为移动客户端开发接口。</p><p>RESTful API 就可以通过一套统一的接口为所有客户端提供web服务，实现前后端分离。</p><p>再比如在一个大型系统架构设计中，可能是多种开发语言一起工作，使用 RESTful API 就可以完全不关心开发语言，以标准的接口来协同工作</p><h2 id="Restful-API是怎么定义的？定义规则方法："><a href="#Restful-API是怎么定义的？定义规则方法：" class="headerlink" title="Restful API是怎么定义的？定义规则方法："></a>Restful API是怎么定义的？定义规则方法：</h2><p>添加（POST）<br>查询（GET）<br>更新编辑修改（GET/POST/PUT）<br>删除（DELETE）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">（<span class="hljs-number">1</span>）查看所有任务<br>GET http:<span class="hljs-comment">//www.gookang.com/tasks</span><br>（<span class="hljs-number">2</span>）新建一个任务<br>POST http:<span class="hljs-comment">//www.gookang.com/tasks</span><br><br>传递Data: title = Foobar<br>（<span class="hljs-number">3</span>）根据ID查看一个任务<br>GET http:<span class="hljs-comment">//www.gookang.com/tasks/123</span><br>（<span class="hljs-number">4</span>）更新任务<br>PUT http:<span class="hljs-comment">//www.gookang.com/tasks/123</span><br><br>传递Data: title = New<br>（<span class="hljs-number">5</span>）删除任务<br>DELETE http:<span class="hljs-comment">//www.nongyejing.com/tasks/123</span><br></code></pre></td></tr></table></figure><h2 id="传统接口写法与Restful-API-接口写法区别："><a href="#传统接口写法与Restful-API-接口写法区别：" class="headerlink" title="传统接口写法与Restful API 接口写法区别："></a>传统接口写法与Restful API 接口写法区别：</h2><p><strong>一个文件操作接口，传统模式</strong>：</p><blockquote><p>api/getfile.php - 获取文件信息，下载文件<br>api/uploadfile.php - 上传创建文件<br>api/deletefile.php - 删除文件</p></blockquote><p>RESTful：</p><blockquote><p>api/file 只需要这一个接口</p><p>GET 方式请求 api/file - 获取文件信息，下载文件<br>POST 方式请求 api/file - 上传创建文件<br>DELETE 方式请求 api/file - 删除某个文件</p></blockquote><h1 id="get-和post-的区别"><a href="#get-和post-的区别" class="headerlink" title="get 和post 的区别"></a>get 和post 的区别</h1><p>POST和GET都是向服务器提交数据，并且都会从服务器获取数据。</p><p><strong>区别：</strong></p><p>1、传送方式：get通过地址栏传输，post通过报文传输。</p><p>2、传送长度：get参数有长度限制（受限于url长度），而post无限制</p><p>3、GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端跨域如何解决？</title>
    <link href="/2021/05/17/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%9F/"/>
    <url>/2021/05/17/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h3><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1.跨域原理：<br><br><span class="hljs-code">主要是由于浏览器的同源策略</span><br><span class="hljs-code"></span><br><span class="hljs-code">2.同源指三个相同：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    协议相同</span><br><span class="hljs-code">    域名相同</span><br><span class="hljs-code">    端口相同</span><br><span class="hljs-code">3.如果非同源，三种行为会受到限制：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    Cookie，LocalStorage和IndexDB无法读取</span><br><span class="hljs-code">    DOM无法获得</span><br><span class="hljs-code">    AJAX请求不能发送</span><br></code></pre></td></tr></table></figure><h3 id="二、解决跨域的方案"><a href="#二、解决跨域的方案" class="headerlink" title="二、解决跨域的方案"></a>二、解决跨域的方案</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-number">1</span>.CORS<br><br>    MDN   CORS术语：https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Glossary/</span>CORS<br><br>    跨域资源共享 CORS 详解，阮一峰（<span class="hljs-number">16</span>年）: http:<span class="hljs-regexp">//</span>www.ruanyifeng.com<span class="hljs-regexp">/blog/</span><span class="hljs-number">2016</span><span class="hljs-regexp">/04/</span>cors.html<br><br>    插件：<br>        CORS Unblock<br><br><span class="hljs-number">2</span>.Nginx反向代理<br><br>    Nginx中文文档：https:<span class="hljs-regexp">//</span>www.nginx.cn<span class="hljs-regexp">/doc/</span><br><br><span class="hljs-number">3</span>.JSONP<br><br>    JSONP主要利用了script标签没有跨域限制的这个特性来完成。<br>    仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。<br><br><span class="hljs-number">4</span>.Websocket<br><br>    MDN：  https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Web/</span>API/WebSocket<br><br><br><span class="hljs-number">5</span>.window.postMessage<br><br>    提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。<br><br>    MDN：  https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Web/</span>API<span class="hljs-regexp">/Window/</span>postMessage<br><br><span class="hljs-number">6</span>.document.domain + Iframe<br><br>    该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加document.domain =<span class="hljs-string">&#x27;test.com&#x27;</span>表示二级域名都相同就可以实现跨域。<br><br><br><span class="hljs-number">7</span>.window.location.hash + Iframe<br><br>    通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。<br><br><br><span class="hljs-number">8</span>.window.name+ Iframe<br><br><br><span class="hljs-number">9</span>.浏览器开启跨域<br><br>一般情况千万别轻易使用这个方式<br><br>    Windows<br>    <br>    找到你安装的目录<br>    .\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx<br><br>    Mac<br>    <br>    ~<span class="hljs-regexp">/Downloads/</span>chrome-data这个目录可以自定义.<br>    <span class="hljs-regexp">/Applications/</span>Google\ Chrome\ Canary.app<span class="hljs-regexp">/Contents/</span>MacOS<span class="hljs-regexp">/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/</span>Downloads/chrome-data<br><br><br><br><span class="hljs-number">10</span>.Node 正向代理<br><br>    代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。<br>    a.cli工具中的代理<br>        Webpack (<span class="hljs-number">4</span>.x)<br>        Vue-cli <span class="hljs-number">2</span>.x<br>        Vue-cli <span class="hljs-number">3</span>.x<br>        Parcel (<span class="hljs-number">2</span>.x)<br>    b.使用自己的代理<br>    c.charles<br><br><br><br><br><br></code></pre></td></tr></table></figure><p>以上所有详细用法参考网址：<br>    <a href="https://zhuanlan.zhihu.com/p/132534931">https://zhuanlan.zhihu.com/p/132534931</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Git&amp;Github</title>
    <link href="/2021/02/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git&amp;Github/"/>
    <url>/2021/02/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git&amp;Github/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-amp-GitHub-如何使用"><a href="#Git-amp-GitHub-如何使用" class="headerlink" title="Git&amp;GitHub 如何使用"></a>Git&amp;GitHub 如何使用</h1><h2 id="1-Git-介绍"><a href="#1-Git-介绍" class="headerlink" title="1 Git 介绍"></a>1 Git 介绍</h2><p>Git 是一款开源免费的分布式的<strong>版本控制系统</strong>。是 Linux 之父 Linus Torvalds（林纳斯·托瓦兹）为了方便管理 linux 代码代码而开发的。</p><p>Git 可以实现的功能：</p><ul><li>代码备份</li><li>版本回退</li><li>多人协作</li><li>权限控制</li></ul><p>Git 工具下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>GIt 官方文档地址：<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h2 id="2-Git-准备工作"><a href="#2-Git-准备工作" class="headerlink" title="2 Git 准备工作"></a>2 Git 准备工作</h2><h3 id="2-1-常用-Linux-操作"><a href="#2-1-常用-Linux-操作" class="headerlink" title="2.1 常用 Linux 操作"></a>2.1 常用 Linux 操作</h3><h4 id="①-常用-Linux-命令"><a href="#①-常用-Linux-命令" class="headerlink" title="① 常用 Linux 命令"></a>① 常用 Linux 命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ls</span> 将当前目录下所有的文件或子目录列举选项 a:包括隐藏文件， l:详细信息<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">ls</span> <span class="hljs-literal">-a</span><br><span class="hljs-built_in">ls</span> <span class="hljs-literal">-l</span><br><span class="hljs-built_in">ls</span> <span class="hljs-literal">-al</span><br><br><span class="hljs-built_in">cd</span> 进入到指定的目录<br><span class="hljs-built_in">cd</span>  目录的路径（相对路径绝对路径）<br><span class="hljs-built_in">cd</span> ..进入上一级目录<br><br><br><span class="hljs-built_in">rm</span> 删除指定的文件或目录<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> 目录名或文件名<br><br><span class="hljs-built_in">clear</span> 清除当前命令行<br></code></pre></td></tr></table></figure><h4 id="②-常用快捷键"><a href="#②-常用快捷键" class="headerlink" title="② 常用快捷键"></a>② 常用快捷键</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-literal">tab</span>自动补全路径<br>ctrl + L清除当前命令行<br>ctrl + C终止当前命令<br>键盘上下方向键    调取历史命令<br></code></pre></td></tr></table></figure><h3 id="2-2-Vim-的使用"><a href="#2-2-Vim-的使用" class="headerlink" title="2.2 Vim 的使用"></a>2.2 Vim 的使用</h3><p>vim 是一个代码编辑软件，可以对文件进行创建、编辑。</p><p>使用 vim 命令打开文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim 文件名<br></code></pre></td></tr></table></figure><p>如果要打开的文件是不存在，会自动创建文件。</p><p><img src="/.io//vim%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="三种模式"></p><h4 id="①-命令模式"><a href="#①-命令模式" class="headerlink" title="① 命令模式"></a>① 命令模式</h4><p>使用 vim 打开文件之后，最先进入的就是命令模式，命令模式下无法编辑文件的，只能输入命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">i<span class="hljs-comment"># 进入输入模式</span><br></code></pre></td></tr></table></figure><h4 id="②-输入模式"><a href="#②-输入模式" class="headerlink" title="② 输入模式"></a>② 输入模式</h4><p>只有在输入模式下才能对文件进行编辑。</p><p>在命令模式下输入 i 命令即可进入输入模式。</p><p>在输入模式下按 <code>ESC</code> 键可以再次回到命令模式。</p><h4 id="③-底线命令模式"><a href="#③-底线命令模式" class="headerlink" title="③ 底线命令模式"></a>③ 底线命令模式</h4><p>在模式下按 : 可以进入底线命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">:w<span class="hljs-comment"># 保存斌退出底线命令， :w! 表示强制保存。</span><br>:q<span class="hljs-comment"># 退出 vim</span><br>:wq     <span class="hljs-comment"># 保存并退出 vim，  :wq! 表示强制保存并退出</span><br></code></pre></td></tr></table></figure><h2 id="3-Git-基础概念"><a href="#3-Git-基础概念" class="headerlink" title="3 Git 基础概念"></a>3 Git 基础概念</h2><h3 id="3-1-git-目录-仓库目录"><a href="#3-1-git-目录-仓库目录" class="headerlink" title="3.1 .git 目录 仓库目录"></a>3.1 <code>.git</code> 目录 仓库目录</h3><ul><li>hooks 目录包含客户端或服务端的钩子脚本，在特定操作下自动执行。</li><li>info 包含一个全局性排除文件，可以配置文件忽略。</li><li>logs 保存日志信息。</li><li>objects 目录存储所有数据内容,本地的版本库存放位置。</li><li>refs 目录存储指向数据的提交对象的指针（分支）。</li><li>config 文件包含项目特有的配置选项。</li><li>description 用来显示对仓库的描述信息。</li><li>HEAD 文件指示目前被检出的分支。</li><li>index 暂存区数据。</li></ul><blockquote><p><strong>切记：</strong> 不要手动去修改 .git 文件夹中的内容。</p></blockquote><h3 id="3-2-Git-仓库的三个区域"><a href="#3-2-Git-仓库的三个区域" class="headerlink" title="3.2 Git 仓库的三个区域"></a>3.2 Git 仓库的三个区域</h3><p><img src="/.io//%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git-Github%5C%E7%89%88%E6%9C%AC%E4%BB%93%E5%BA%93.png" alt="git三个区域"></p><p><strong>工作区：</strong> 代码编辑区，编辑代码的地方。</p><p><strong>暂存区：</strong> 修改待提交区。</p><p><strong>版本库：</strong> 真正存储代码的地方。</p><h2 id="4-Git-基础命令总结"><a href="#4-Git-基础命令总结" class="headerlink" title="4 Git 基础命令总结"></a>4 Git 基础命令总结</h2><h3 id="4-1-初始化配置"><a href="#4-1-初始化配置" class="headerlink" title="4.1 初始化配置"></a>4.1 初始化配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>初始化命令在 git 安装完整之后运行一次即可，以后就无需再进行配置了。</p><p>查看相关的配置信息，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><h3 id="4-2-仓库初始化"><a href="#4-2-仓库初始化" class="headerlink" title="4.2 仓库初始化"></a>4.2 仓库初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git init<br></code></pre></td></tr></table></figure><p>进入项目所在的目录，运行命令进行仓库初始化。 进行仓库初始化会创建该项目的 git 仓库。</p><p>通常，项目目录创建完成之后进行仓库初始化，以后就不需要了。</p><h3 id="4-3-查看状态"><a href="#4-3-查看状态" class="headerlink" title="4.3 查看状态"></a>4.3 查看状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>可以查看工作区有没有修改（看的是工作区和版本库的区别）。</p><p>可以查看暂存区有没有东西。</p><h3 id="4-4-添加暂存区"><a href="#4-4-添加暂存区" class="headerlink" title="4.4 添加暂存区"></a>4.4 添加暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;文件名&gt;<span class="hljs-comment"># 添加指定的文件到暂存区</span><br>git add -A  <span class="hljs-comment"># 提交所有的修改、删除、新增到暂存区</span><br></code></pre></td></tr></table></figure><h3 id="4-5-提交版本库"><a href="#4-5-提交版本库" class="headerlink" title="4.5 提交版本库"></a>4.5 提交版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;提交日志&quot;</span><span class="hljs-comment"># 把暂存区的东西提交到版本库</span><br>git commit -am <span class="hljs-string">&quot;提交日志&quot;</span><span class="hljs-comment"># 把工作区的修改一步到位添加暂存并提交到版本库</span><br></code></pre></td></tr></table></figure><h3 id="4-6-查看暂存前后具体的变化"><a href="#4-6-查看暂存前后具体的变化" class="headerlink" title="4.6 查看暂存前后具体的变化"></a>4.6 查看暂存前后具体的变化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff <span class="hljs-comment"># 查看当前工作区和版本库的差异 （不包括新增的文件）</span><br>git diff --cached<span class="hljs-comment"># 查看暂存区中的变化</span><br></code></pre></td></tr></table></figure><h3 id="4-7-撤销修改和撤销暂存"><a href="#4-7-撤销修改和撤销暂存" class="headerlink" title="4.7 撤销修改和撤销暂存"></a>4.7 撤销修改和撤销暂存</h3><h4 id="①-工作区的修改没有添加暂存"><a href="#①-工作区的修改没有添加暂存" class="headerlink" title="① 工作区的修改没有添加暂存"></a>① 工作区的修改没有添加暂存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore &lt;文件名&gt;<span class="hljs-comment"># 恢复工作区指定文件</span><br>git restore .  <span class="hljs-comment"># 恢复工作区所有的修改（恢复之后，新增的文件不会被删除）</span><br></code></pre></td></tr></table></figure><blockquote><p>会使用版本库当前最前的版本进行恢复！</p></blockquote><p><strong>注意：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- &lt;file&gt; <span class="hljs-comment"># 同 git restore &lt;file&gt; 作用一致</span><br>git checkout -- .      <span class="hljs-comment"># 同 git restore . 作用一致</span><br></code></pre></td></tr></table></figure><h4 id="②-工作区的修改已经添加到暂存区"><a href="#②-工作区的修改已经添加到暂存区" class="headerlink" title="② 工作区的修改已经添加到暂存区"></a>② 工作区的修改已经添加到暂存区</h4><p>如果工作区的修改已经添加到暂存区，先清除暂存区，再恢复工作区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore --staged &lt;文件名&gt;<span class="hljs-comment"># 把指定文件从暂存区移除</span><br>git restore --staged .  <span class="hljs-comment"># 把所有文件从暂存区移除</span><br></code></pre></td></tr></table></figure><h3 id="4-8-历史版本回滚"><a href="#4-8-历史版本回滚" class="headerlink" title="4.8 历史版本回滚"></a>4.8 历史版本回滚</h3><h4 id="①-查看历史版本号"><a href="#①-查看历史版本号" class="headerlink" title="① 查看历史版本号"></a>① 查看历史版本号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><span class="hljs-comment"># 查看提交记录</span><br>git <span class="hljs-built_in">log</span> -n<span class="hljs-comment"># 查看最近的 n 次提交几次，n 是个数字</span><br>git <span class="hljs-built_in">log</span> --oneline<span class="hljs-comment"># 每次提交记录只用一行显示</span><br></code></pre></td></tr></table></figure><p>如果需要查看被回滚掉的提交的版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><h4 id="②-通过指定版本号回滚"><a href="#②-通过指定版本号回滚" class="headerlink" title="② 通过指定版本号回滚"></a>② 通过指定版本号回滚</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard &lt;commitID&gt;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>进行版本回退时，不需要使用完整的哈希字符串(版本号，CommitID)，前七位即可。</p><p>版本切换之前，要提交当前的代码状态到仓库。</p></blockquote><h4 id="③-快捷回滚"><a href="#③-快捷回滚" class="headerlink" title="③ 快捷回滚"></a>③ 快捷回滚</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^    <span class="hljs-comment"># 恢复到上个版本</span><br>git reset --hard HEAD^^    <span class="hljs-comment"># 恢复到上上个版本</span><br>git reset --hard HEAD^^^    <span class="hljs-comment"># 恢复到上上上个版本</span><br></code></pre></td></tr></table></figure><h2 id="5-忽略文件"><a href="#5-忽略文件" class="headerlink" title="5 忽略文件"></a>5 忽略文件</h2><h3 id="5-1-被忽略的文件"><a href="#5-1-被忽略的文件" class="headerlink" title="5.1 被忽略的文件"></a>5.1 被忽略的文件</h3><p>哪些文件需要被 git 忽略：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><h3 id="5-2-设置忽略文件-gitignore"><a href="#5-2-设置忽略文件-gitignore" class="headerlink" title="5.2 设置忽略文件 .gitignore"></a>5.2 设置忽略文件 <code>.gitignore</code></h3><p>忽略文件的文件名是 <code>.gitignore</code> 的文件, 文件内可以设置项目的忽略规则。</p><p>忽略文件可以放在项目中的任意目录中，放在哪个目录作用范围就是哪个目录； 一般忽略文件会放在项目的根目录下。</p><h3 id="5-3-忽略文件的语法"><a href="#5-3-忽略文件的语法" class="headerlink" title="5.3 忽略文件的语法"></a>5.3 忽略文件的语法</h3><p>可以用<code>git check-ignore</code> 命令检查 <code>.gitignore</code>文件格式是否正确。</p><p><code>.gitignore</code> 文件的格式规则如下：</p><ol><li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义。</li><li><code>#</code> 开头的文件标识注释，可以使用反斜杠进行转义。</li><li><code>!</code> 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 <code>!</code> 也不会再次被包含。可以使用反斜杠进行转义。</li><li><code>/</code> 结束的模式只匹配目录以及在该目录路径下的内容。</li><li><code>/</code> 开始的模式匹配当前目录下的，（gitignore 文件所在的目录）</li><li><code>**</code> 匹配多级目录，可在开始，中间，结束。</li><li><code>*</code> 匹配任意数量的任意字符串。</li><li><code>?</code> 通用匹配单个字符。</li><li><code>[]</code> 通用匹配单个字符列表。</li></ol><h3 id="5-4-忽略文件配置示例"><a href="#5-4-忽略文件配置示例" class="headerlink" title="5.4 忽略文件配置示例"></a>5.4 忽略文件配置示例</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 此为注释 </span><br><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*<span class="hljs-string">.a</span><br><br><span class="hljs-comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.a<br><br><span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="hljs-string">/TODO</span><br><br><span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹</span><br>build/<br><br><span class="hljs-comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*<span class="hljs-string">.txt</span><br><br><span class="hljs-comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*<span class="hljs-string">.pdf</span><br></code></pre></td></tr></table></figure><h2 id="6-Git-分支"><a href="#6-Git-分支" class="headerlink" title="6 Git 分支"></a>6 Git 分支</h2><h3 id="6-1-分支介绍"><a href="#6-1-分支介绍" class="headerlink" title="6.1 分支介绍"></a>6.1 分支介绍</h3><p>分支并非 Git 的专利，几乎所有的版本控制系统都以某种形式支持分支。</p><p>使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p><p><img src="/.io//%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git-Github%5C%E5%88%86%E6%94%AF.jpg" alt="分支"></p><h3 id="6-2-分支操作"><a href="#6-2-分支操作" class="headerlink" title="6.2 分支操作"></a>6.2 分支操作</h3><blockquote><p><strong>注意：</strong> 在进行分支操作之前，一定一定要把工作区都提交了！！！</p></blockquote><h4 id="①-创建分支"><a href="#①-创建分支" class="headerlink" title="① 创建分支"></a>① 创建分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch 分支名<br></code></pre></td></tr></table></figure><p>会根据当前所在的分支进行创建。</p><h4 id="②-切换分支"><a href="#②-切换分支" class="headerlink" title="② 切换分支"></a>② 切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch 分支名<br><span class="hljs-comment"># 或者</span><br>git checkout 分支名<br></code></pre></td></tr></table></figure><h4 id="③-创建并切换到该分支"><a href="#③-创建并切换到该分支" class="headerlink" title="③ 创建并切换到该分支"></a>③ 创建并切换到该分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -c 分支名<br><span class="hljs-comment"># 或者</span><br>git checkout -b 分支名<br></code></pre></td></tr></table></figure><h4 id="④-查看分支"><a href="#④-查看分支" class="headerlink" title="④ 查看分支"></a>④ 查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><h4 id="⑤-删除分支"><a href="#⑤-删除分支" class="headerlink" title="⑤ 删除分支"></a>⑤ 删除分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d 分支名<br></code></pre></td></tr></table></figure><h4 id="⑥-合并分支"><a href="#⑥-合并分支" class="headerlink" title="⑥ 合并分支"></a>⑥ 合并分支</h4><p>如果把 A 分支合并到 B 分支上，先切换到 B 分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge 分支名<span class="hljs-comment"># 把指定的分支合并到当前分支</span><br></code></pre></td></tr></table></figure><h3 id="6-3-合并分支解决冲突"><a href="#6-3-合并分支解决冲突" class="headerlink" title="6.3 合并分支解决冲突"></a>6.3 合并分支解决冲突</h3><p>当多个分支修改同一个文件后，合并分支的时候就会产生冲突。冲突的解决非常简单，将内容修改为最终想要的结果，然后继续执行 <code>git add</code> 与 <code>git commit</code> 就可以了。</p><h2 id="7-GitHub-Git-远程仓库"><a href="#7-GitHub-Git-远程仓库" class="headerlink" title="7 GitHub - Git 远程仓库"></a>7 GitHub - Git 远程仓库</h2><h3 id="7-1-GitHub-介绍"><a href="#7-1-GitHub-介绍" class="headerlink" title="7.1 GitHub 介绍"></a>7.1 GitHub 介绍</h3><p>Hub 是一个代码仓库的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。可以创建远程中心仓库，为多人合作开发提供便利。</p><p>目前，其注册用户已经超过 350 万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python等。</p><p>2018 年 6 月 4 日，微软宣布，通过 75 亿美元的股票交易收购代码托管平台 GitHub。</p><p>网址：<a href="https://github.com/">https://github.com</a></p><p>从搜索框，输入，可以查看星数十万以上，会从高到低排列</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">star</span><span class="hljs-variable">s:</span>&gt;<span class="hljs-number">100000</span><br></code></pre></td></tr></table></figure><h3 id="7-2-GitHub-使用流程"><a href="#7-2-GitHub-使用流程" class="headerlink" title="7.2 GitHub 使用流程"></a>7.2 GitHub 使用流程</h3><h4 id="①-场景一：-本地有仓库-远程没有仓库"><a href="#①-场景一：-本地有仓库-远程没有仓库" class="headerlink" title="① 场景一： 本地有仓库 远程没有仓库"></a>① 场景一： 本地有仓库 远程没有仓库</h4><ol><li><p>在 github 上创建一个仓库</p></li><li><p>获取到远程仓库的地址</p></li><li><p>本地运行命令， 给仓库地址取别名为 origin</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> origin 远程仓库地址</span><br></code></pre></td></tr></table></figure></li><li><p>本地仓库提交</p></li><li><p>把本地仓库推送到远程仓库 （第一次）, <code>-u</code> 的意思是记录远程仓库的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master<br></code></pre></td></tr></table></figure></li><li><p>以后如果向远程仓库推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push master<br></code></pre></td></tr></table></figure><h4 id="②-场景二：-本地没仓库-远程有仓库"><a href="#②-场景二：-本地没仓库-远程有仓库" class="headerlink" title="② 场景二： 本地没仓库 远程有仓库"></a>② 场景二： 本地没仓库 远程有仓库</h4></li><li><p>获取到远程仓库的地址</p></li><li><p>本地克隆远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 远程仓库地址<br></code></pre></td></tr></table></figure></li><li><p>本地仓库如有修改，一定要添加并提交</p></li><li><p>将本地仓库推送到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-多人合作"><a href="#7-3-多人合作" class="headerlink" title="7.3 多人合作"></a>7.3 多人合作</h3><h4 id="①-创建组织配置权限"><a href="#①-创建组织配置权限" class="headerlink" title="① 创建组织配置权限"></a>① 创建组织配置权限</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">首页 -&gt; 右上角 `+` 号 -&gt; <span class="hljs-keyword">new</span> Organization<br>免费计划<br>填写组织名称和联系方式（不用使用中文名称）<br>邀请其他开发者进入组织（会有邮件邀请，==如收不到，请查看垃圾箱==）<br>配置组织权限，组织首页右侧  settings -&gt; Member privileges -&gt; 选择 write<br></code></pre></td></tr></table></figure><h4 id="②-多人合作工作流程"><a href="#②-多人合作工作流程" class="headerlink" title="② 多人合作工作流程"></a>② 多人合作工作流程</h4><p><strong>第一天上班：</strong></p><ol><li><p>获取到仓库地址，克隆到本地</p></li><li><p>进行开发修改代码，添加、提交。</p></li><li><p>下班之前要推送到远程仓库</p><p>3.1 先确定所有的都提交了（commit）</p><p>3.2 推送之前先拉取</p><pre><code>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git pull<br></code></pre></td></tr></table></figure></code></pre><p>3.3 正式推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure></li></ol><p><strong>以后每一天：</strong></p><ol><li><p>早上上班，拉取远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure></li><li><p>进行开发修改代码，添加、提交。</p></li><li><p>下班之前要推送到远程仓库</p><p>3.1 先确定所有的都提交了（commit）</p><p>3.2 推送之前先拉取</p><pre><code>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git pull<br></code></pre></td></tr></table></figure></code></pre><p>3.3 正式推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure><h4 id="③-冲突解决"><a href="#③-冲突解决" class="headerlink" title="③ 冲突解决"></a>③ 冲突解决</h4></li></ol><p>与合并分支类似，多个成员如果修改了同一个文件，就会出现冲突； 本地拉取文件的时候，如果远程仓库中与本地的提交有冲突，解决：修改再次提交， 再推送</p><h3 id="7-4-GitHub-免密登录"><a href="#7-4-GitHub-免密登录" class="headerlink" title="7.4 GitHub 免密登录"></a>7.4 GitHub 免密登录</h3><ol><li><p>创建非对称加密对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>文件默认存储在家目录（c:/用户/用户名/.ssh）的 .ssh 文件夹中。</p><ul><li>id_rsa 私钥</li><li>id_rsa.pub 公钥</li></ul></li><li><p>将公钥（.pub）文件内容配置到账号的秘钥中</p><p>首页 -&gt; 右上角头像-&gt; settings -&gt; SSH and GPG keys -&gt; new SSH Key</p></li><li><p>克隆代码时，选择 ssh 模式进行克隆 （地址 在仓库首页 绿色 克隆的位置 选择 use ssh）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com/unclealan/team-repo-1.git<br></code></pre></td></tr></table></figure></li><li><p>克隆代码时的提醒，这里需要输入 <code>yes</code></p></li></ol><h2 id="8-GitFlow-Git-开发流程"><a href="#8-GitFlow-Git-开发流程" class="headerlink" title="8 GitFlow - Git 开发流程"></a>8 GitFlow - Git 开发流程</h2><p><img src="/.io//blog\Senven007\source\img\GitFlow.png"></p><ul><li>Master 主分支。上面只保存正式发布的版本</li><li>Hotfix 线上代码 Bug 修复分支。开发完后需要合并回Master和Develop分支。</li><li>Feather 功能分支。当开发某个功能时，创建一个单独的分支，开发完毕后再合并到 dev 分支</li><li>Release 分支。待发布分支，Release分支基于Develop分支创建，在这个Release分支上测试，修改Bug</li><li>Develop 开发分支。开发者都在这个分支上提交代码</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>总结Promise的语法和用法</title>
    <link href="/2021/02/22/Promise%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/22/Promise%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise-教程"><a href="#Promise-教程" class="headerlink" title="Promise 教程"></a>Promise 教程</h1><h2 id="1-Promise-概述"><a href="#1-Promise-概述" class="headerlink" title="1 Promise 概述"></a>1 Promise 概述</h2><p>Promise 是异步编程的一种解决方法，比传统的方式更加高效、友好！</p><p>使用 Promise 语法需要创建一个 promise 对象，promise 对象中包含一个异步操作， 可以通过实例化 Promise 构造函数来创造 promise 对象。</p><p>promise 对象具有三种状态：</p><ol><li>pending 状态， 进行中， 刚创建的 promise 对象就处于 pending 状态。</li><li>resolved 状态，已成功， 内部的异步操作执行成功，promise 对象的状态由 pending -&gt; resolved</li><li>rejected 状态，已失败。 内部的异步操作执行失败，promise 对象的状态由 pending -&gt; rejected</li></ol><p>当 promise 的状态发生改变，就再也不会变了！</p><h2 id="2-Promise-基本语法"><a href="#2-Promise-基本语法" class="headerlink" title="2 Promise 基本语法"></a>2 Promise 基本语法</h2><h4 id="①-使用-Promise-构造函数创建-promise-对象"><a href="#①-使用-Promise-构造函数创建-promise-对象" class="headerlink" title="① 使用 Promise 构造函数创建 promise 对象"></a>① 使用 Promise 构造函数创建 promise 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><ol><li>实例化 Promise 构造函数 可以创建 promise 对象</li><li>Promise 构造函数需要指定一个回调函数作为参数，<strong>该回调函数是同步的</strong>， 在实例化 Promise 的那一刻就会执行。</li></ol></blockquote><h4 id="②-修改promise-对象的状态"><a href="#②-修改promise-对象的状态" class="headerlink" title="② 修改promise 对象的状态"></a>② 修改promise 对象的状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>&#123;<br>    <span class="hljs-comment">// 修改状态为 resolved</span><br>    res();<br>    <br>    <span class="hljs-comment">// 修改状态为 rejected</span><br>    rej();<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><ol><li>Promise 构造函数的回调函数，能够自动接收两个参数，这两个参数都是 function</li><li>如果调用第一个参数，promise 对象的状态会改为 resolved， 如果调用第二个参数，promise 对象的状态会改为 rejected。</li><li>注意： promise 对象的状态一旦改变就永久定格了。</li></ol></blockquote><h4 id="③-指定-promise-对象的回调函数"><a href="#③-指定-promise-对象的回调函数" class="headerlink" title="③ 指定 promise 对象的回调函数"></a>③ 指定 promise 对象的回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>&#123;<br>    <span class="hljs-comment">// 修改状态为 resolved, 指定实参</span><br>    res(value);<br>    <br>    <span class="hljs-comment">// 修改状态为 rejected，指定形参</span><br>    rej(reason);<br>&#125;);<br><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>promise 对象调用 then 方法，then 方法指定两个回调函数作为参数，如果 promise 对象的状态改为 resolved，就执行第一个回调函数，如果promise 状态改为 reject的，就执行第二个回调函数。</p></blockquote><h2 id="3-Promise-实例的方法"><a href="#3-Promise-实例的方法" class="headerlink" title="3 Promise 实例的方法"></a>3 Promise 实例的方法</h2><h3 id="3-1-then-方法"><a href="#3-1-then-方法" class="headerlink" title="3.1 then 方法"></a>3.1 then 方法</h3><h4 id="①-参数"><a href="#①-参数" class="headerlink" title="① 参数"></a>① 参数</h4><ul><li><p><code>onResolved</code> 可选</p><p>当 Promise 变成成功状态（resolved）时调用的函数。该函数有一个参数，即接受的最终结果（the fulfillment value）。如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数。</p></li><li><p><code>onRejected</code> 可选</p><p>当 Promise 变成成功状态或失败状态（rejected）时调用的函数。该函数有一个参数，即失败的原因（<code>rejection reason</code>）。 如果该参数不是函数，则会在内部被替换为一个 “Thrower” 函数 (it throws an error it received as argument)。</p></li></ul><h4 id="②-返回值"><a href="#②-返回值" class="headerlink" title="② 返回值"></a>② 返回值</h4><p><code>then()</code> 方法返回一个 promise 对象，（注意：then 返回的promise对象与调用then的promise对象不是一个），<code>then()</code> 方法返回的 promise 对象的状态取决于所执行的回调函数的返回值，分为以下 4 种情况：</p><ol><li>如果回调函数返回一个除了promise对象以外的数据类型，<code>then()</code> 方法返回的 promise 对象的状态是 resolved，回调函数的返回值作为成功状态的值。</li><li>如果回调函数没有返回值，<code>then()</code> 方法返回的 promise 对象的状态是 resolved，成功的值是 undefined。</li><li>如果回调函数中出现错误（运行错误），<code>then()</code> 方法返回的 promise 对象的状态是 rejected，错误信息作为失败状态的原因。</li><li>如果回调函数返回的是一个promise对象，<code>then()</code> 方法返回的就是这个 promise 对象。</li></ol><h3 id="3-2-catch-方法"><a href="#3-2-catch-方法" class="headerlink" title="3.2 catch 方法"></a>3.2 catch 方法</h3><h4 id="①-参数-1"><a href="#①-参数-1" class="headerlink" title="① 参数"></a>① 参数</h4><ul><li><p>onRejected</p><p>当Promise 被 rejected 时,被调用的一个函数。 该函数拥有一个参数：<code>reason</code> rejection 的原因。</p><p>如果 <code>onRejected</code> 抛出一个错误或返回一个本身失败的 Promise ， 通过 <code>catch()</code> 返回的Promise 被rejected；否则，它将显示为成功（resolved）。</p></li></ul><h4 id="②-then-和-catch-可以配合使用"><a href="#②-then-和-catch-可以配合使用" class="headerlink" title="② then 和 catch 可以配合使用"></a>② then 和 catch 可以配合使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = randEvenTimeout(<span class="hljs-number">3000</span>, <span class="hljs-number">3</span>, <span class="hljs-number">67</span>);<br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;取到了随机偶数：&#x27;</span>, value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;随机偶数获取失败，&#x27;</span>, reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="③-异常穿透"><a href="#③-异常穿透" class="headerlink" title="③ 异常穿透"></a>③ 异常穿透</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">randEvenTimeout(<span class="hljs-number">3000</span>, <span class="hljs-number">3</span>, <span class="hljs-number">67</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;取到了随机偶数：&#x27;</span>, value);<br>    <span class="hljs-keyword">return</span> randEvenTimeout(<span class="hljs-number">2000</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;取到了随机偶数：&#x27;</span>, value);<br>    <span class="hljs-keyword">return</span> randEvenTimeout(<span class="hljs-number">5000</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;取到了随机偶数：&#x27;</span>, value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;随机偶数获取失败，&#x27;</span>, reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-3-finally"><a href="#3-3-finally" class="headerlink" title="3.3 finally"></a>3.3 finally</h3><p>与 then 和 catch 类似，指定一个回调函数作为参数，只有 promise 状态改变不论改为哪种状态，finally 指定的回调函数都执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">randEvenTimeout(<span class="hljs-number">4000</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;成功获取随机偶数：&#x27;</span>, value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;无法获取偶数：&#x27;</span>, reason);<br>&#125;).finally(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;哈哈，我一定执行&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="4-Promise-构造函数本身的方法"><a href="#4-Promise-构造函数本身的方法" class="headerlink" title="4 Promise 构造函数本身的方法"></a>4 Promise 构造函数本身的方法</h2><h3 id="4-1-Promise-resolve"><a href="#4-1-Promise-resolve" class="headerlink" title="4.1 Promise.resolve()"></a>4.1 Promise.resolve()</h3><h4 id="①-功能"><a href="#①-功能" class="headerlink" title="①  功能"></a>①  功能</h4><p>能够返回一 个promise 对象，用于快速得到一个 promise 对象。</p><h4 id="②-根据参数不同返回的promise也不同："><a href="#②-根据参数不同返回的promise也不同：" class="headerlink" title="② 根据参数不同返回的promise也不同："></a>② 根据参数不同返回的promise也不同：</h4><ol><li><code>Promise.resolve()</code> 如果没有参数，返回成功状态的 promise 对象，值是 undefined。</li><li><code>Promise.resolve()</code>  指定一个除promise对象或thenable以外的数据作为参数，返回成功状态的 promise 对象，值就是那个参数。</li><li><code>Promise.resolve()</code>  指定一个 promise 对象作为参数，方法就返回这个参数。</li><li><code>Promise.resolve()</code>  指定一个 thenable 对象作为参数，返回的 promise 对象状态由 then 方法决定。</li></ol><h3 id="4-2-Promise-reject"><a href="#4-2-Promise-reject" class="headerlink" title="4.2 Promise.reject()"></a>4.2 Promise.reject()</h3><p>没有 Promise.resolve() 那么复杂，Promise.reject() 就返回一个失败状态的 promise 对象， 方法的参数会作为失败原因。</p><h3 id="4-3-Promise-all"><a href="#4-3-Promise-all" class="headerlink" title="4.3 Promise.all()"></a>4.3 Promise.all()</h3><p>该方法接收一个可遍历对象作为参数，可遍历对象的成员要求都是 promise 对象，该方法最终返回一个 promise 对象，状态由参数中的成员决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建 3 个 promise 对象</span><br><span class="hljs-keyword">let</span> p1 = randEvenTimeout(<span class="hljs-number">3000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">let</span> p2 = randEvenTimeout(<span class="hljs-number">2000</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">let</span> p3 = randEvenTimeout(<span class="hljs-number">4000</span>, <span class="hljs-number">32</span>, <span class="hljs-number">100</span>);<br><br><br><span class="hljs-comment">// 根据 p1,p2和p3, 创建一个 promise 对象</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;成功状态！&#x27;</span>, value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;失败状态：&#x27;</span>, reason);<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li>如果 p1 p2 p3 都改为 resolved 的状态 ，p 的状态改为 resolved</li><li>p1 p2 p3 只要一个状态改为 rejected，p 的状态改为 rejected、</li></ol><h2 id="5-Promise-的优势"><a href="#5-Promise-的优势" class="headerlink" title="5 Promise 的优势"></a>5 Promise 的优势</h2><ol><li>Promise 指定回调函数的方式更灵活。</li><li>解决回调地狱。</li></ol><h2 id="6-宏队列和微队列"><a href="#6-宏队列和微队列" class="headerlink" title="6 宏队列和微队列"></a>6 宏队列和微队列</h2><p><strong>宏队列：</strong> dom事件的回调函数、ajax的回调函数、定时器的回调函数满足条件之后进入宏队列。</p><p><strong>微队列：</strong> promise 的回调函数当状态改变的时候进入微队列。</p><p>当执行栈空的时候（同步代码执行完毕），先将微队列的回调放入执行栈，再将宏队列的回调放入执行栈。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6+ 教程</title>
    <link href="/2021/02/21/ES6%20%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/21/ES6%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-教程"><a href="#ES6-教程" class="headerlink" title="ES6+ 教程"></a>ES6+ 教程</h1><h2 id="1-let-和-const-关键字"><a href="#1-let-和-const-关键字" class="headerlink" title="1 let 和 const 关键字"></a>1 let 和 const 关键字</h2><h3 id="1-1-let-关键字"><a href="#1-1-let-关键字" class="headerlink" title="1.1 let 关键字"></a>1.1 let 关键字</h3><p><strong>作用：</strong> let 关键字用于声明变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 变量名;<br><span class="hljs-keyword">let</span> 变量名 = 值;<br></code></pre></td></tr></table></figure><p><strong>与 var 声明的变量相比，let 声明的变量具有如下特点：</strong></p><ol><li>let 声明的变量不能重复声明。（注意：let 也不能重复声明用var声明过的变量）。</li><li>let 声明的变量除了具有全局作用域和函数内作用域之外，还有块级作用域。</li><li>let 声明的全局变量不再作为全局对象的属性。</li><li>let 声明的变量不会变量提升。</li></ol><h3 id="1-2-const-关键字"><a href="#1-2-const-关键字" class="headerlink" title="1.2 const 关键字"></a>1.2 const 关键字</h3><p><strong>const 关键字作用：</strong> 用于定义常量。</p><p><strong>常量：</strong> 常量是一种特殊的变量，值不能修改。</p><p><strong>const 声明的变量与let 声明的变量区别：</strong></p><p>值不能修改！</p><p><strong>const 也具备 let 声明变量的 4 个特点：</strong></p><ol><li>不能重复声明。</li><li>具有块级作用域。</li><li>全局变量不再作为全局对象的属性。</li><li>不会变量提升</li></ol><h3 id="1-3-块级作用域"><a href="#1-3-块级作用域" class="headerlink" title="1.3 块级作用域"></a>1.3 块级作用域</h3><p>那些可以产生块级作用域， 分支语句、循环语句等结构，一般有<code>&#123;&#125;</code> 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 分支结构</span><br><span class="hljs-keyword">if</span> () &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">if</span> () &#123;<br>    <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">if</span> () &#123;<br>    <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>           <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;<br>           <br>&#125;<br><br><span class="hljs-keyword">switch</span> () &#123;<br>        <br>&#125;<br><br><span class="hljs-comment">// 循环语句  每次循环各自产生自己的块级作用域</span><br><span class="hljs-keyword">for</span> () &#123;&#125;<br><span class="hljs-keyword">while</span>() &#123;&#125;<br><span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span>();<br>            <br><span class="hljs-comment">// for .. in</span><br>            <br><span class="hljs-comment">// try...catch语句</span><br><br>            <br><span class="hljs-comment">// 单 &#123;&#125; 语句</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2 解构赋值"></a>2 解构赋值</h2><h3 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 声明多个变量并赋值，左边是数组，右边是数组</span><br><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><br><span class="hljs-comment">// 2. 修改多个变量的值</span><br>[a,b,c] = [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>];<br><br><span class="hljs-comment">// 3. 等号左边的变量，类似于形参； 等号右边的类似于实参</span><br><span class="hljs-comment">// 左边数组结构中只能有变量名， 右边的数组结构中可以有直接量、变量、表达式</span><br><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">10</span>, num, fn()];<br><br><span class="hljs-comment">// 4. 左右根据模式进行匹配，数组解构赋值，模式就是索引；</span><br><span class="hljs-keyword">let</span> arr = [<br>    <span class="hljs-number">100</span>,<br>    [<span class="hljs-number">210</span>, <span class="hljs-number">220</span>],<br>    [<br>        <span class="hljs-number">300</span>, <br>        [<span class="hljs-number">400</span>, <span class="hljs-number">410</span>]<br>    ]<br>];<br><span class="hljs-keyword">let</span> [n1, [n2, n3], [n5, [n6, n7]]] = arr;<br><br><span class="hljs-comment">// 5. 左边是数组，右边也必须是数组或者可遍历对象（伪数组）, 否则报错</span><br><span class="hljs-keyword">let</span> [a,b,c] = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h3 id="2-2-可遍历对象解构赋值"><a href="#2-2-可遍历对象解构赋值" class="headerlink" title="2.2 可遍历对象解构赋值"></a>2.2 可遍历对象解构赋值</h3><p>如果等号的左边是数组结构，右边除了是数组，可以是一个其他可遍历对象（≈伪数组）</p><h3 id="2-3-对象的解构赋值"><a href="#2-3-对象的解构赋值" class="headerlink" title="2.3 对象的解构赋值"></a>2.3 对象的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 对象的解构赋值   按照属性名进行模式匹配;  左边的对象中属性值必须是变量名</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: n1, <span class="hljs-attr">age</span>: n2, <span class="hljs-attr">address</span>: n3&#125; = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;朦朦&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;二朦朦&#x27;</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;三萌萌&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(n1);    <span class="hljs-comment">// 朦朦 </span><br><span class="hljs-built_in">console</span>.log(n2);    <span class="hljs-comment">// 二朦朦</span><br><span class="hljs-built_in">console</span>.log(n3);    <span class="hljs-comment">// 三朦朦</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 2. 对象解构赋值简写： 左边的属性名和变量名一致</span><br><span class="hljs-comment">//let &#123;username: username, age: age, address: address&#125; = &#123;username: &#x27;大悲&#x27;, age: 102, address: &#x27;松江&#x27;&#125;;</span><br><span class="hljs-keyword">let</span> &#123;username, age, address&#125; = &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;大悲&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">102</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;松江&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(username);<br><span class="hljs-built_in">console</span>.log(age);<br><span class="hljs-built_in">console</span>.log(address);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><br><span class="hljs-comment">// 3. 左边对象中成员相当于形参，右边对象中的成员相当于实参； 左边的变量可以有默认值</span><br><span class="hljs-comment">// let &#123;name: v1, age: v2, address: v3, job&#125; = &#123;address:&#x27;中国上海&#x27;&#125;;</span><br><span class="hljs-comment">// let &#123;name: v1, age: v2, address: v3, job&#125; = &#123;address:&#x27;中国上海&#x27;, name: &#x27;大萌萌&#x27;, username:&#x27;小朦朦&#x27;&#125;;</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: v1=<span class="hljs-string">&#x27;大悲&#x27;</span>, <span class="hljs-attr">age</span>: v2, <span class="hljs-attr">address</span>: v3, job=<span class="hljs-string">&quot;打野&quot;</span>&#125; = &#123;<span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;中国上海&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;大萌萌&#x27;</span>, <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;小朦朦&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(v1);  <span class="hljs-comment">// 大朦朦</span><br><span class="hljs-built_in">console</span>.log(v2);  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(v3);  <span class="hljs-comment">// 中国上海</span><br><span class="hljs-built_in">console</span>.log(job); <span class="hljs-comment">// 打野</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><br><span class="hljs-comment">// 4. 复杂形式的对象解构赋值； 数组解构：按照索引匹配； 对象解构：按照属性名匹配</span><br><span class="hljs-keyword">let</span> data = &#123;<br>    email: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    nums: [<br>        <span class="hljs-number">10000</span>, <br>        <span class="hljs-number">2000</span><br>    ],<br>    prop: &#123;<br>        content: <span class="hljs-string">&#x27;过年好&#x27;</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;email, <span class="hljs-attr">nums</span>: [num1, num2], <span class="hljs-attr">prop</span>: &#123;content&#125;&#125; = data;<br><span class="hljs-built_in">console</span>.log(email);  <span class="hljs-comment">// email</span><br><span class="hljs-comment">// console.log(nums);   // 不存在 nums 变量</span><br><span class="hljs-built_in">console</span>.log(num1);  <span class="hljs-comment">// 10000</span><br><span class="hljs-built_in">console</span>.log(num2);  <span class="hljs-comment">// 2000</span><br><span class="hljs-comment">// console.log(prop);  // 不存在 prop 变量</span><br><span class="hljs-built_in">console</span>.log(content); <span class="hljs-comment">// 过年好</span><br></code></pre></td></tr></table></figure><h3 id="2-4-其他对象解构赋值（一切皆对象）"><a href="#2-4-其他对象解构赋值（一切皆对象）" class="headerlink" title="2.4 其他对象解构赋值（一切皆对象）"></a>2.4 其他对象解构赋值（一切皆对象）</h3><p>如果等号的左边是对象结构的形式（{}），等好右边除了写一个 Object 类型的对象，其他任意类型的对象都可以（一切皆对象，除了 null 和 undefined）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象解构赋值</span><br><span class="hljs-keyword">let</span> &#123;name, age, address, length&#125; = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>];<br><span class="hljs-built_in">console</span>.log(name);   <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(age);    <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(address); <span class="hljs-comment">// undefiend</span><br><span class="hljs-built_in">console</span>.log(length);  <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 对象解构赋值</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span>:nums&#125; = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(nums);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">getElementById</span>:n1, <span class="hljs-attr">querySelector</span>:n2&#125; = <span class="hljs-built_in">document</span>;<br><span class="hljs-built_in">console</span>.log(n1);<br><span class="hljs-built_in">console</span>.log(n2);<br></code></pre></td></tr></table></figure><h3 id="2-5-解构赋值应用场景"><a href="#2-5-解构赋值应用场景" class="headerlink" title="2.5 解构赋值应用场景"></a>2.5 解构赋值应用场景</h3><h4 id="①-用于给多个变量赋值"><a href="#①-用于给多个变量赋值" class="headerlink" title="① 用于给多个变量赋值"></a>① 用于给多个变量赋值</h4><p>可以使用解构赋值创建并同时给变量赋值；也可以给已经创建的变量修改值</p><h4 id="②-从数组中或对象中提取想要的数据"><a href="#②-从数组中或对象中提取想要的数据" class="headerlink" title="② 从数组中或对象中提取想要的数据"></a>② 从数组中或对象中提取想要的数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [n1, n2] = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>);   <span class="hljs-comment">// 提取中 NodeList 中前两个元素，分别赋值给 n1, n2</span><br><span class="hljs-keyword">let</span> [name, age] = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;&#x27;</span>, grade=<span class="hljs-string">&#x27;&#x27;</span>&#125;;  <span class="hljs-comment">// 提取对象中的 name 值和 age 值</span><br></code></pre></td></tr></table></figure><h4 id="③-解构赋值可以用于函数传参"><a href="#③-解构赋值可以用于函数传参" class="headerlink" title="③ 解构赋值可以用于函数传参"></a>③ 解构赋值可以用于函数传参</h4><p>函数传参就是实参给形参赋值；可以使用解构赋值的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">[a, b]</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>, <span class="hljs-number">345</span>];<br>func(arr);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><br><span class="hljs-comment">// 定义插件方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params">&#123;duration=<span class="hljs-number">5000</span>, autoPlay=<span class="hljs-literal">false</span>, icons=<span class="hljs-literal">false</span>&#125;</span>) </span>&#123;<br><br>&#125;<br><span class="hljs-comment">// 调用插件  只需要对象一个参数</span><br>play(&#123;<br>    duration: <span class="hljs-number">3000</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="④-快速交换两个变量的值"><a href="#④-快速交换两个变量的值" class="headerlink" title="④ 快速交换两个变量的值"></a>④ 快速交换两个变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义两个变量</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// 交换 a 和 b 的值</span><br>[a,b] = [b,a];<br><br><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">// 200;</span><br><span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">// 100;</span><br></code></pre></td></tr></table></figure><h2 id="3-字符串新增特性"><a href="#3-字符串新增特性" class="headerlink" title="3 字符串新增特性"></a>3 字符串新增特性</h2><h3 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h3><p><strong>什么是模板字符串？</strong></p><p>使用反引号定义的字符串，称之为模板字符串。</p><p><strong>模板字符串的特点：</strong></p><p>相对于使用单引号或双引号声明的字符串，模板字符串具有以下特点：</p><ol><li>模板字符串中可以保存换行、缩进等格式，适合定义内容比较多且有格式的字符串。</li><li>模板字符串可以非常方便的嵌套变量或者表达式，把变量和表达式写在 <code>$&#123;&#125;</code> 里面</li></ol><p>其他的特点就与单引号双引号定义的字符串一致了，可以写转义字符，模板字符中也不能嵌套反引号（需要转义）。</p><h3 id="3-2-字符串实例新增方法"><a href="#3-2-字符串实例新增方法" class="headerlink" title="3.2 字符串实例新增方法"></a>3.2 字符串实例新增方法</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">ES3</span> 方法：<br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">indexOf</span></span>()</span><br><span class="hljs-function"><span class="hljs-title">lastIndexOf</span>()</span><br><span class="hljs-function"><span class="hljs-title">slice</span>()</span><br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">substring</span></span>()</span><br><span class="hljs-function"><span class="hljs-title">substr</span>()</span><br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">split</span></span>()</span><br><span class="hljs-function"><span class="hljs-title">toUpperCase</span>()</span><br><span class="hljs-function"><span class="hljs-title">toLowerCase</span>()</span><br><span class="hljs-function"><span class="hljs-title">charCodeAt</span>()</span><br><span class="hljs-function"><span class="hljs-title">search</span>()</span><br><span class="hljs-function"><span class="hljs-title">match</span>()</span><br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">replace</span></span>()</span><br><br><span class="hljs-variable">ES5</span> 方法：<br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">trim</span></span>()去除字符串两端的空格</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">ES6</span>+ 方法：</span><br><span class="hljs-function"><span class="hljs-title">repeat</span>()字符串重复，参数指定重复的次数，默认<span class="hljs-number">0</span></span><br><span class="hljs-function"><span class="hljs-title">includes</span>()判断字符串是否包含某个值； 第一参数指定要查找的值；第二个参数可选指定开始查找的位置，默认<span class="hljs-number">0</span>；返回布尔值。</span><br><span class="hljs-function"><span class="hljs-title">startsWith</span>()判断字符串是否以某个值开头；第一参数指定要查找的值；第二个参数可选指定开始查找的位置，默认<span class="hljs-number">0</span>；返回布尔值。</span><br><span class="hljs-function"><span class="hljs-title">endsWith</span>()判断字符串是否以某个值结尾；第一参数指定要查找的值；第二个参数可选指定开始查找的位置，默认 <span class="hljs-number">0</span>； 返回布尔值。</span><br><span class="hljs-function"><span class="hljs-title">padStart</span>()把字符串补全到指定长度，内容填充在前面；第一参数指定目标长度；第二个参数指定填充的内容，默认空格 （<span class="hljs-variable">ES2017</span>）</span><br><span class="hljs-function"><span class="hljs-title">padEnd</span>()把字符串补全到指定长度，内容填充在后面；第一参数指定目标长度；第二个参数指定填充的内容，默认空格 （<span class="hljs-variable">ES2017</span>）</span><br><span class="hljs-function"><span class="hljs-title">trimStart</span>()去除字符串前面的空格（<span class="hljs-variable">ES2019</span>）</span><br><span class="hljs-function"><span class="hljs-title">trimEnd</span>()去除字符串后面的空格（<span class="hljs-variable">ES2019</span>）</span><br></code></pre></td></tr></table></figure><h2 id="4-数值新增特性"><a href="#4-数值新增特性" class="headerlink" title="4 数值新增特性"></a>4 数值新增特性</h2><h3 id="4-1-新增的二进制和八进制表示方式"><a href="#4-1-新增的二进制和八进制表示方式" class="headerlink" title="4.1 新增的二进制和八进制表示方式"></a>4.1 新增的二进制和八进制表示方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 八进制的表示方式</span><br><span class="hljs-number">0o100</span>;<br><br><span class="hljs-comment">// ES6 二进制的表示方式</span><br><span class="hljs-number">0b100</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>旧语法中 <code>0</code> 开头表示八进制的方式在严格模式下会报错，不建议使用！</p></blockquote><h3 id="4-2-Number-构造函数本身新增的方法和属性"><a href="#4-2-Number-构造函数本身新增的方法和属性" class="headerlink" title="4.2 Number 构造函数本身新增的方法和属性"></a>4.2 Number 构造函数本身新增的方法和属性</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ES3:<br>Number.MAX_VALUE<br>Number.MIN_VALUE<br><br>ES6:<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">NaN()</span>同全局函数 is<span class="hljs-constructor">NaN()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Finite()</span>同全局函数 is<span class="hljs-constructor">Finite()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>parse<span class="hljs-constructor">Int()</span>同全局函数 parse<span class="hljs-constructor">Int()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>parse<span class="hljs-constructor">Float()</span>同全局函数 parse<span class="hljs-constructor">Float()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Integer()</span>判断是否是整数，返回布尔值<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">SafeInteger()</span>判断是否是安全整数，返回布尔值<br>Number.MAX_SAFE_INTEGER返回最大的安全数<br>Number.MIN_SAFE_INTEGER返回最小的安全数<br>Number.ESPILON返回JS中可以表示的最小精度<br></code></pre></td></tr></table></figure><blockquote><p><strong>安全整数：</strong> 在 -2^53 到 2^53之间的整数是安全的整数，安全整数的运算时精确的； 超出范围的整数无法保证运算的精确性。</p></blockquote><h3 id="4-3-Math-新增方法"><a href="#4-3-Math-新增方法" class="headerlink" title="4.3 Math 新增方法"></a>4.3 Math 新增方法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ES3:<br>Math.PI<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sqrt<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>pow<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span><br><br>ES6:<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>trunc<span class="hljs-literal">()</span>截取数字中的整数部分<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sign<span class="hljs-literal">()</span>判断一个数是正数、负数还是<span class="hljs-number">0</span>；正数返回<span class="hljs-number">1</span>，负数返回-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>返回<span class="hljs-number">0</span>。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cbrt<span class="hljs-literal">()</span>计算一个数的立方根<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>hypot<span class="hljs-literal">()</span>计算所有参数的平方和的平方根<br></code></pre></td></tr></table></figure><h3 id="4-4-指数运算符-（ES2016）"><a href="#4-4-指数运算符-（ES2016）" class="headerlink" title="4.4 指数运算符 ** （ES2016）"></a>4.4 指数运算符 ** （ES2016）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span> ** <span class="hljs-number">10</span>;<span class="hljs-comment">// 计算 2 的 10 次方</span><br></code></pre></td></tr></table></figure><h3 id="4-5-新增原始数据类型-bigint-（ES2020）"><a href="#4-5-新增原始数据类型-bigint-（ES2020）" class="headerlink" title="4.5 新增原始数据类型 bigint （ES2020）"></a>4.5 新增原始数据类型 bigint （ES2020）</h3><p><strong>bigint 数据类型：</strong> bigint 是 ES6 新增的原始数据类型，使用 typeof 查看 bigint 类型的数据返回 <code>bigint</code></p><p><strong>bigint 数据类型的直接量表示方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">23423n</span>;<span class="hljs-comment">// bigint 直接量</span><br></code></pre></td></tr></table></figure><p><strong>bigint 数据类型的特点：</strong></p><ol><li>bigint 不能与其他类型的数据进行运算，只能以 bigint 类型的数据运算。</li><li>bigint 可以比较，自动类型转换。</li></ol><p><strong>bigint 的作用：</strong></p><p>如果要定义很大数（超过安全数范围）同时需要保证精度，需要定义为 bigint 类型。</p><h2 id="5-函数新增特性"><a href="#5-函数新增特性" class="headerlink" title="5 函数新增特性"></a>5 函数新增特性</h2><h3 id="5-1-新增的函数参数默认值的设置方式"><a href="#5-1-新增的函数参数默认值的设置方式" class="headerlink" title="5.1 新增的函数参数默认值的设置方式"></a>5.1 新增的函数参数默认值的设置方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">a, b=<span class="hljs-string">&#x27;默认值&#x27;</span></span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-rest-参数"><a href="#5-2-rest-参数" class="headerlink" title="5.2 rest 参数"></a>5.2 rest 参数</h3><p>ES6 引入 rest 参数（形式 <code>...变量名</code>） ，用于获取函数中多余的参数，用来代替 arguments</p><p>rest 参数会得到一个数组，数组中的成员是剩余的实参（没有形参接收的实参）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-comment">// 定义函数，计算所有参数的和</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-comment">// 定义变量</span><br>    <span class="hljs-keyword">var</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历所有参数 args</span><br>    args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>        res += arg;<br>    &#125;);<br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// rest 参数获取的是剩余的实参，且必须写在所有参数的最后面</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">name, ...nums</span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>rest 参数的特点（相对于 arguments）：</strong></p><ol><li>rest 参数得到是纯数组，argument 得到是伪数组。</li><li>rest 参数获取的是多余的实参（没有形参接收的实参），arguments 获取所有的实参。</li><li>rest 参数的变量名自定义的，且必须写在所有参数的最后面； arguments 无需声明，自动创建。</li></ol><h3 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数"></a>5.3 箭头函数</h3><h4 id="①-箭头函数的语法"><a href="#①-箭头函数的语法" class="headerlink" title="① 箭头函数的语法"></a>① 箭头函数的语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 定义一个箭头函数</span><br><span class="hljs-keyword">let</span> fn01 = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(fn01);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> fn01);<br>fn01();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><br><span class="hljs-comment">// 2. 定义有函数体的箭头函数</span><br><span class="hljs-keyword">let</span> fn02 = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;啊，我是箭头函数 fn02&#x27;</span>);<br>&#125;;<br>fn02();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 3. 定义有参数的箭头函数</span><br><span class="hljs-keyword">let</span> fn03 = <span class="hljs-function">(<span class="hljs-params">name, age=<span class="hljs-number">10</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;name&#125;</span>,我的年龄<span class="hljs-subst">$&#123;age&#125;</span>岁，我觉得我很牛逼`</span>);<br>&#125;;<br>fn03(<span class="hljs-string">&#x27;朦朦&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><br><span class="hljs-comment">// 4. 如果箭头函数只有一个形参，可以省略()</span><br><span class="hljs-keyword">let</span> fn04 = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;name&#125;</span>,以后跟着我混吧`</span>);<br>&#125;;<br>fn04(<span class="hljs-string">&#x27;大悲&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 5. 如果函数体只有一条语句且这条语句还是返回语句，可以省略&#123;&#125;和return</span><br><span class="hljs-keyword">let</span> fn05 = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2;<br><span class="hljs-built_in">console</span>.log(fn05(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 6. 同时省略 () 和 &#123;&#125;</span><br><span class="hljs-keyword">let</span> fn06 = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + <span class="hljs-number">200</span>;<br><span class="hljs-built_in">console</span>.log(fn06(<span class="hljs-number">50</span>));<br></code></pre></td></tr></table></figure><h4 id="②-箭头函数的特点"><a href="#②-箭头函数的特点" class="headerlink" title="② 箭头函数的特点"></a>② 箭头函数的特点</h4><p>相对于使用 function 声明的函数，箭头函数具有如下特点：</p><ol><li>箭头函数中没有自己的this（没有本作用域下的this），如果在箭头函数中使用this，会沿着作用域链向上查找。</li><li>箭头函数中不能使用 arguments，可以用 rest 参数代替。</li><li>箭头函数只能调用，不能<code>new</code>； 箭头函数是函数但不是构造函数。</li><li>箭头函数不能用于生成器函数。</li></ol><h3 id="5-4-函数参数尾逗号（ES2017）"><a href="#5-4-函数参数尾逗号（ES2017）" class="headerlink" title="5.4 函数参数尾逗号（ES2017）"></a>5.4 函数参数尾逗号（ES2017）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 语法： 最后一个形参后面跟个逗号，不报错！</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">name, age, address, </span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-数组新增特性"><a href="#6-数组新增特性" class="headerlink" title="6 数组新增特性"></a>6 数组新增特性</h2><h3 id="6-1-扩展运算符"><a href="#6-1-扩展运算符" class="headerlink" title="6.1 扩展运算符"></a>6.1 扩展运算符</h3><h4 id="①-把数组拆分为逗号隔开的参数序列"><a href="#①-把数组拆分为逗号隔开的参数序列" class="headerlink" title="① 把数组拆分为逗号隔开的参数序列"></a>① 把数组拆分为逗号隔开的参数序列</h4><p><code>...</code> 用在等号的右边或者函数的实参，会把数组或其他可遍历对象拆分为逗号隔开的参数序列。</p><p><strong>作用：</strong></p><ol><li><p>用于实参赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 定义数组</span><br><span class="hljs-keyword">var</span> nums = [<span class="hljs-number">1231</span>, <span class="hljs-number">2342</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45656</span>, <span class="hljs-number">345</span>, <span class="hljs-number">109</span>];<br><span class="hljs-comment">// 取出数组中值最大的成员</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(...nums));<br></code></pre></td></tr></table></figure></li><li><p>用于拷贝数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 拷贝数组</span><br><span class="hljs-comment">// 引用赋值， num2 和 nums 其实指向一个数组</span><br><span class="hljs-comment">// var num2 = nums;</span><br><span class="hljs-keyword">var</span> num2 = [...nums];<br>num2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;朦朦&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(nums);<br><span class="hljs-built_in">console</span>.log(num2);<br></code></pre></td></tr></table></figure><h4 id="②-把多个值合并到一个数组中"><a href="#②-把多个值合并到一个数组中" class="headerlink" title="② 把多个值合并到一个数组中"></a>② 把多个值合并到一个数组中</h4></li></ol><p><code>...</code> 写在等号的左边或者形参位置，把多个值合并到一个数组中。</p><ol><li><p>作为 rest 参数；</p></li><li><p>在解构赋值中使用；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span> [a, ...b] = [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">6000</span>];<br><span class="hljs-built_in">console</span>.log(a);   <span class="hljs-comment">//  1000</span><br><span class="hljs-built_in">console</span>.log(b);   <span class="hljs-comment">// [2000, 3000, 4000, 5000, 6000]</span><br></code></pre></td></tr></table></figure><h3 id="6-2-Array-构造函数本身新增的方法"><a href="#6-2-Array-构造函数本身新增的方法" class="headerlink" title="6.2 Array 构造函数本身新增的方法"></a>6.2 Array 构造函数本身新增的方法</h3></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from<span class="hljs-literal">()</span>把其他可遍历对象转为纯数组<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-literal">()</span>创建一个新数组，参数数量任意，会作为数组的成员。<br></code></pre></td></tr></table></figure><h3 id="6-3-Array-实例新增的方法"><a href="#6-3-Array-实例新增的方法" class="headerlink" title="6.3 Array 实例新增的方法"></a>6.3 Array 实例新增的方法</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">ES3</span>:<br><span class="hljs-function"><span class="hljs-title">concat</span>()</span><br><span class="hljs-function"><span class="hljs-title">join</span>()</span><br><span class="hljs-function"><span class="hljs-title">slice</span>()</span><br><span class="hljs-function"><span class="hljs-title">push</span>()</span><br><span class="hljs-function"><span class="hljs-title">pop</span>()</span><br><span class="hljs-function"><span class="hljs-title">unshift</span>()</span><br><span class="hljs-function"><span class="hljs-title">shift</span>()</span><br><span class="hljs-function"><span class="hljs-title">splice</span>()</span><br><span class="hljs-function"><span class="hljs-title">reverse</span>()</span><br><span class="hljs-function"><span class="hljs-title">sort</span>()</span><br><br><span class="hljs-variable">ES5</span>:<br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">indexOf</span></span>()</span><br><span class="hljs-function"><span class="hljs-title">lastIndexOf</span>()</span><br><span class="hljs-function"><span class="hljs-title">forEach</span>()</span><br><span class="hljs-function"><span class="hljs-title">filter</span>()</span><br><span class="hljs-function"><span class="hljs-title">map</span>()</span><br><span class="hljs-function"><span class="hljs-title">some</span>()</span><br><span class="hljs-function"><span class="hljs-title">every</span>()</span><br><span class="hljs-function"><span class="hljs-title">reduce</span>()</span><br><span class="hljs-function"><span class="hljs-title">reduceRight</span>()</span><br><br><span class="hljs-variable">ES6</span>+:<br><span class="hljs-function"><span class="hljs-title">find</span>()返回第一个满足条件的数组成员，参数是回调函数。</span><br><span class="hljs-function"><span class="hljs-title">findIndex</span>() 返回第一个满足条件的数组成员的索引，参数是回调函数。</span><br><span class="hljs-function"><span class="hljs-title">fill</span>()把数组中每个元素的值都改为指定的（参数）</span><br><span class="hljs-function"><span class="hljs-title">keys</span>()返回由数组的索引组成的遍历器对象</span><br><span class="hljs-function"><span class="hljs-title">values</span>()返回由数组的元素值组成的遍历器对象</span><br><span class="hljs-function"><span class="hljs-title">entries</span>()返回数组的索引和值组成的遍历器对象</span><br><span class="hljs-function"><span class="hljs-title">includes</span>()  判断数组中是否存在某个值，类似于字符串的 <span class="hljs-variable">includes</span> 方法， <span class="hljs-variable">ES2016</span></span><br><span class="hljs-function"><span class="hljs-title">flat</span>()把多维数组拉平，参数默认是<span class="hljs-number">1</span>表示只拉平一层，可以设置为 <span class="hljs-variable">Infinity</span>， <span class="hljs-variable">ES2019</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="7-对象新增特性"><a href="#7-对象新增特性" class="headerlink" title="7 对象新增特性"></a>7 对象新增特性</h2><h3 id="7-1-属性简写"><a href="#7-1-属性简写" class="headerlink" title="7.1 属性简写"></a>7.1 属性简写</h3><p>定义对象的时候，用变量表示属性的值，并且变量名与属性名是一样的，可以简写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义变量</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;朦朦&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get Info&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 定义对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name,<br>    age,<br>    address: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>    getInfo<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-2-方法简写"><a href="#7-2-方法简写" class="headerlink" title="7.2 方法简写"></a>7.2 方法简写</h3><p>定义对象的时候，方法可以简写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-function"><span class="hljs-title">getAddress</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-3-创建对象时用表达式作为属性名"><a href="#7-3-创建对象时用表达式作为属性名" class="headerlink" title="7.3 创建对象时用表达式作为属性名"></a>7.3 创建对象时用表达式作为属性名</h3><p>创建对象的时候，定义属性，把表达式写在<code>[]</code>中，会把表达式的值作为属性名/</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 定义变量</span><br><span class="hljs-keyword">let</span> prop = <span class="hljs-string">&#x27;address&#x27;</span>;<br><span class="hljs-comment">// 声明对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    username: <span class="hljs-string">&#x27;朦朦&#x27;</span>,<br>    <span class="hljs-string">&#x27;user-age&#x27;</span>: <span class="hljs-number">100</span>,<br>    [<span class="hljs-number">10</span>*<span class="hljs-number">5</span>]: <span class="hljs-string">&#x27;大悲&#x27;</span>,<span class="hljs-comment">// 属性名是 50</span><br>    [prop]: <span class="hljs-string">&#x27;上海&#x27;</span>    <span class="hljs-comment">// 属性名是 address</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-4-super-关键字"><a href="#7-4-super-关键字" class="headerlink" title="7.4 super 关键字"></a>7.4 super 关键字</h3><p><code>super</code> 关键字与 <code>this</code> 类似，在对象的方法中使用：</p><ol><li><code>this</code> 关键字指向调用该方法的对象； <code>super</code> 关键字指向方法所属对象的原型。</li><li><code>this</code> 只与谁调用该方法有关； <code>super</code> 与谁调用该方法无关，只与方法声明的位置有关（确定所属的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;My Name is &#x27;</span>+<span class="hljs-built_in">this</span>.name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;My Name is &#x27;</span>+<span class="hljs-built_in">super</span>.name);<br>  &#125;,<br>&#125;;<br><span class="hljs-comment">//在obj的原型上添加属性</span><br><span class="hljs-built_in">Object</span>.prototype.name = <span class="hljs-string">&#x27;obj proto&#x27;</span>;<br>obj.say();<br><span class="hljs-comment">// this: My Name is obj</span><br><span class="hljs-comment">// super: My Name is obj proto</span><br><br><span class="hljs-comment">// ----------------------------</span><br><span class="hljs-comment">// 定义对象并指定原型对象</span><br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-built_in">Object</span>.create(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1 proto&#x27;</span>&#125;);<br>obj1.name = <span class="hljs-string">&#x27;obj1&#x27;</span>;<br>obj1.say = obj.say;<br>obj1.say();<br><span class="hljs-comment">// this: My Name is obj1</span><br><span class="hljs-comment">// super: My Name is obj proto</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p><code>super</code> 关键字只有在简写的对象方法中才可以使用！</p></blockquote><h3 id="7-5-对象的扩展运算符-ES2018"><a href="#7-5-对象的扩展运算符-ES2018" class="headerlink" title="7.5 对象的扩展运算符 (ES2018)"></a>7.5 对象的扩展运算符 (ES2018)</h3><h4 id="①-把对象转为逗号隔开的键值对序列"><a href="#①-把对象转为逗号隔开的键值对序列" class="headerlink" title="① 把对象转为逗号隔开的键值对序列"></a>① 把对象转为逗号隔开的键值对序列</h4><p>扩展运算符用在等号的右边，可以对象转为逗号隔开的键值对序列。</p><p>可以用于对象的克隆、合并。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;朦朦&#x27;</span>,<br>    age: <span class="hljs-number">17</span>,<br>    address: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 用于等号右边： 把对象转为逗号隔开的键值对序列</span><br><span class="hljs-comment">// 1. 复制对象</span><br><span class="hljs-keyword">let</span> obj1 = &#123;...obj&#125;;<br>obj1.name = <span class="hljs-string">&#x27;大悲&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj1);<br><span class="hljs-built_in">console</span>.log(obj);<br><span class="hljs-comment">// 2. 合并对象</span><br><span class="hljs-keyword">let</span> obj2 = &#123;...obj, ...&#123;<span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;&#125;, <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123;&#125;&#125;&#125;;<br><span class="hljs-built_in">console</span>.log(obj2);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="①-把键值对序列组成一个对象"><a href="#①-把键值对序列组成一个对象" class="headerlink" title="① 把键值对序列组成一个对象"></a>① 把键值对序列组成一个对象</h4><p>用在等号的左边，与对象解构赋值结合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;朦朦&#x27;</span>,<br>    age: <span class="hljs-number">17</span>,<br>    address: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;name, ...users&#125; = obj;<br><span class="hljs-built_in">console</span>.log(name);<br><span class="hljs-built_in">console</span>.log(users);<br></code></pre></td></tr></table></figure><h3 id="7-6-Object-构造函数本身新增的方法"><a href="#7-6-Object-构造函数本身新增的方法" class="headerlink" title="7.6 Object 构造函数本身新增的方法"></a>7.6 Object 构造函数本身新增的方法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ES5:<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Properties()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptor()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>keys<span class="hljs-literal">()</span>  返回对象属性名组成的数组<br><br>ES6 +:<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>is<span class="hljs-literal">()</span>;判断两个数据是否相等，判断规则与<span class="hljs-operator"> === </span>类似，两点不同：<span class="hljs-number">0</span>和-<span class="hljs-number">0</span>不等，NaN和NaN相等。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>assign<span class="hljs-literal">()</span>;把第二个参数往后所有参数中的属性合并到第一个参数中，返回值就是第一个参数； 用于对象的合并、克隆。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf()</span>返回指定对象的原型<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf()</span>设置某个对象的原型<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>values<span class="hljs-literal">()</span>返回对象属性值组成的数组, ES2017<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>entries<span class="hljs-literal">()</span>返回二维数组，每个成员两个元素属性名和属性值组成的数组, ES2017<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Obejct</span>.</span></span>from<span class="hljs-constructor">Entries()</span>entries 方法的逆运算<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptors()</span>得到对象中所有属性的特性<br><br></code></pre></td></tr></table></figure><h3 id="7-7-Object-的实例新增的属性"><a href="#7-7-Object-的实例新增的属性" class="headerlink" title="7.7 Object 的实例新增的属性"></a>7.7 Object 的实例新增的属性</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__proto__</span>返回对象的原型<br></code></pre></td></tr></table></figure><h2 id="8-Class-语法"><a href="#8-Class-语法" class="headerlink" title="8 Class 语法"></a>8 Class 语法</h2><h3 id="8-1-使用-Class-定义类"><a href="#8-1-使用-Class-定义类" class="headerlink" title="8.1 使用 Class 定义类"></a>8.1 使用 Class 定义类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>    <span class="hljs-comment">// 给类的实例定义属性</span><br>    name = <span class="hljs-string">&#x27;朦朦&#x27;</span>;<span class="hljs-comment">// 定义属性并给值</span><br>age; <span class="hljs-comment">// 定义属性先不给值</span><br><br><span class="hljs-comment">// 给类的实例定义方法 </span><br><span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;;<br><br>say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类的特点：</strong></p><ol><li>类本质上仍然是个构造函数，使用 typeof 判断返回 function。</li><li>类只能被实例化，不能被调用。</li><li>类中只能写定义属性和方法的代码，类中也不能直接使用 this； 方法内可以写任意操作的代码和this。</li><li>类中的方法如果使用简写方式，该方法会添加到类的实例的原型上，推荐。</li></ol><h3 id="8-2-类中定义构造器"><a href="#8-2-类中定义构造器" class="headerlink" title="8.2 类中定义构造器"></a>8.2 类中定义构造器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>() </span>&#123;<br>    <span class="hljs-comment">// 定义构造器方法</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类中构造器方法的特定功能：</strong></p><ol><li>构造器方法会在类实例化的时候自动被调用！</li><li>构造器方法可以解构实例化类的时候给的实参，通常用构造器方法给实例的属性进行初始化赋值。</li></ol><h3 id="8-3-类中定义访问器属性"><a href="#8-3-类中定义访问器属性" class="headerlink" title="8.3 类中定义访问器属性"></a>8.3 类中定义访问器属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 定义属性</span><br>    firstName;<br>    lastName;<br><br>    <span class="hljs-comment">// 构造器方法</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">firstName, lastName</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.firstName = firstName;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取访问器属性调用的方法</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27;·&#x27;</span> + <span class="hljs-built_in">this</span>.lastName;<br>    &#125;<br><br>    <span class="hljs-comment">// 写访问器属性调用的方法</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-built_in">this</span>.firstName = val.split(<span class="hljs-string">&#x27;·&#x27;</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">this</span>.lastName = val.split(<span class="hljs-string">&#x27;·&#x27;</span>)[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-4-类中定义静态方法"><a href="#8-4-类中定义静态方法" class="headerlink" title="8.4 类中定义静态方法"></a>8.4 类中定义静态方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-comment">// 定义静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态方法就是类本身的方法！</strong></p><h3 id="8-5-继承"><a href="#8-5-继承" class="headerlink" title="8.5 继承"></a>8.5 继承</h3><h4 id="①-extends-关键字实现继承"><a href="#①-extends-关键字实现继承" class="headerlink" title="① extends 关键字实现继承"></a>① extends 关键字实现继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 定义子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>子类的实例可以继承定义在父类上的属性和方法。</li><li>父类可以被多个子类继承，但是子类只能继承一个父类。</li></ol><h4 id="②-方法和属性的重写"><a href="#②-方法和属性的重写" class="headerlink" title="② 方法和属性的重写"></a>② 方法和属性的重写</h4><p>子类中如果定义了与父类同名的属性和方法，会把继承过来属性和方法重写！称为<strong>属性重写</strong> 和 <strong>方法重写</strong>。</p><h4 id="③-super-关键字"><a href="#③-super-关键字" class="headerlink" title="③ super 关键字"></a>③ super 关键字</h4><p>super 关键字既可以作为对象使用，也可以作为函数使用（调用）； super 作为函数去使用的时候具有如下特点：</p><ol><li>super 函数只能在子类的构造器方法中使用！</li><li>子类的构造器方法中必须已开启就调用 super，再进行其他操作！</li><li>调用 super 就相当于调用了父类的构造器方法， 子类如果重写了构造器方法，必须要先调用 super！</li></ol><h4 id="④-继承内置类"><a href="#④-继承内置类" class="headerlink" title="④ 继承内置类"></a>④ 继承内置类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义类 继承 Array</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>&#123;<br><br>    <span class="hljs-comment">// 重写父类的构造器方法</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的构造器方法</span><br>        <span class="hljs-built_in">super</span>(...args);<br>        <span class="hljs-comment">// 自己的初始化操作</span><br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-Symbol-类型"><a href="#9-Symbol-类型" class="headerlink" title="9 Symbol 类型"></a>9 Symbol 类型</h2><p>ES6 新增了一种新的数据类型，symbol。</p><p>symbol 类型的数据可以用作对象的属性名（原来对象的属性只能是字符串）。</p><p><code>Symbol()</code> 调用 Symbol 函数可以创造一个新的 symbol 类型的数据，每调用一次 Symbol 函数都创建的是全新的 symbol 类型数据。</p><h2 id="10-Set-和-Map"><a href="#10-Set-和-Map" class="headerlink" title="10 Set 和 Map"></a>10 Set 和 Map</h2><h3 id="10-1-Set"><a href="#10-1-Set" class="headerlink" title="10.1 Set"></a>10.1 Set</h3><p>Set 是ES6中新增的一种对象类型，类似于数组，也是值的集合但是值都是唯一的！ 也不具备数组的索引结构。 </p><p>Set 是可遍历对象。</p><h4 id="①-Set-构造函数"><a href="#①-Set-构造函数" class="headerlink" title="① Set 构造函数"></a>① Set 构造函数</h4><p>Set 构造函数接收一个数组或者可遍历对象作为参数，根据参数创建 Set 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>[...s]; <span class="hljs-comment">// []</span><br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<br>[...set]; <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// 例三</span><br><span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]);<br>items.size <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">// 例四</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>));<br>set.size <span class="hljs-comment">// 56</span><br></code></pre></td></tr></table></figure><h4 id="②-Set-的实例的方法"><a href="#②-Set-的实例的方法" class="headerlink" title="② Set 的实例的方法"></a>② Set 的实例的方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">has</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">keys</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">values</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">entries</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">forEach</span><span class="hljs-params">()</span></span><br>size数组，获取值的数量<br></code></pre></td></tr></table></figure><h4 id="③-Set-的应用场景"><a href="#③-Set-的应用场景" class="headerlink" title="③ Set 的应用场景"></a>③ Set 的应用场景</h4><ul><li>需要存储成员不能重复的集合</li><li>借助 Set 实现数组去重。</li></ul><h3 id="10-2-WeakSet"><a href="#10-2-WeakSet" class="headerlink" title="10.2 WeakSet"></a>10.2 WeakSet</h3><p>WeakSet 类似于 Set，也是 ES6 新增的一种对象类型，也是值不能重复的集合，与 Set 相比具有如下不同：</p><ol><li>Set 的成员可以是任意类型的数据， WeakSet 的成员只能是对象类型（不能是原始类型）。</li><li>Set 是可遍历对象； WeakSet是不可遍历的，不能使用扩展运算符。</li></ol><h4 id="①-WeakSet-构造函数"><a href="#①-WeakSet-构造函数" class="headerlink" title="① WeakSet 构造函数"></a>① WeakSet 构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">onst ws1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<br><br><span class="hljs-keyword">const</span> a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> ws2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>(a);    <span class="hljs-comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></code></pre></td></tr></table></figure><h4 id="②-WeakSet-实例的方法"><a href="#②-WeakSet-实例的方法" class="headerlink" title="② WeakSet 实例的方法"></a>② WeakSet 实例的方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">has</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="11-3-Map"><a href="#11-3-Map" class="headerlink" title="11.3 Map"></a>11.3 Map</h3><p>Map 是ES6 新增的一种对象数据类型，与 Object 类似，由键值对组成的集合，传统的对象要求属性名（键）只能用字符串或者Symbol来表示，而 Map 中的键可以是任意类型的数据。</p><p>Map 是可遍历对象。</p><h4 id="①-Map-构造函数"><a href="#①-Map-构造函数" class="headerlink" title="① Map 构造函数"></a>① Map 构造函数</h4><p>Map 构造函数以二维数组作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],<br>  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]<br>]);<br></code></pre></td></tr></table></figure><h4 id="②-Map-实例的方法"><a href="#②-Map-实例的方法" class="headerlink" title="② Map 实例的方法"></a>② Map 实例的方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">keys</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">values</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">entries</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">forEach</span><span class="hljs-params">()</span></span><br>size 属性<br></code></pre></td></tr></table></figure><h3 id="10-4-WeakMap"><a href="#10-4-WeakMap" class="headerlink" title="10.4 WeakMap"></a>10.4 WeakMap</h3><p>WeakMap 与 Map 的区别如下：</p><ol><li>WeakMap 中的键只能是对象类型（不能是原始类型）</li><li>WeakMap 不可遍历</li></ol><p>WeakMap 的实例的方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">has</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h2 id="11-遍历器-iterator"><a href="#11-遍历器-iterator" class="headerlink" title="11 遍历器 iterator"></a>11 遍历器 iterator</h2><h3 id="11-1-iterator-遍历器对象"><a href="#11-1-iterator-遍历器对象" class="headerlink" title="11.1 iterator 遍历器对象"></a>11.1 iterator 遍历器对象</h3><ol><li>iterator 是一种接口，任何数据只要部署了 iterator 接口，该数据就是可遍历对象，能够使用 for … of 进行遍历。</li><li>所有的 iterator 对象都有一个 next() 方法， next 方法返回一个对象，对象中包含 value 属性 和 done 属性。</li><li>iterator 对象有个指针，指向当前的值（默认指向第一个），调用 next，把当前指针指向的值取出，并且指针下移。</li><li>Array的实例、Set的实例和Map的实例具有 keys方法、values方法和entries方法，这些方法都会返回对应的 iterator 对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 do while 遍历遍历器对象（iterator） </span><br><span class="hljs-keyword">do</span> &#123;<br>     <span class="hljs-comment">// 取出当前指向指向的值</span><br>     <span class="hljs-keyword">var</span> res = iter.next();<br>     <span class="hljs-comment">// 输出结果中的值</span><br>     <span class="hljs-keyword">if</span> (res.value) &#123;<br>         <span class="hljs-built_in">console</span>.log(res.value);<br>     &#125;<br> &#125; <span class="hljs-keyword">while</span> (!res.done);<br></code></pre></td></tr></table></figure><h3 id="11-2-iterable-可遍历对象"><a href="#11-2-iterable-可遍历对象" class="headerlink" title="11.2 iterable 可遍历对象"></a>11.2 iterable 可遍历对象</h3><h4 id="①-什么是可遍历对象"><a href="#①-什么是可遍历对象" class="headerlink" title="① 什么是可遍历对象"></a>① 什么是可遍历对象</h4><ol><li>实现了 iterator 接口的数据类型称之为 iterable（可遍历对象）。</li><li>可遍历对象遍历器接口部署在了 [Symbol.iterator] 方法中，该方法返回一个遍历器对象。</li></ol><h4 id="②-内置的可遍历对象"><a href="#②-内置的可遍历对象" class="headerlink" title="② 内置的可遍历对象"></a>② 内置的可遍历对象</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Array</span><br><span class="hljs-built_in">Set</span><br><span class="hljs-built_in">Map</span><br><span class="hljs-built_in">String</span><br>Arguments<br>NodeList<br>HTMLCollection<br></code></pre></td></tr></table></figure><h4 id="③-哪些情况会调用可遍历对象的遍历器接口"><a href="#③-哪些情况会调用可遍历对象的遍历器接口" class="headerlink" title="③  哪些情况会调用可遍历对象的遍历器接口"></a>③  哪些情况会调用可遍历对象的遍历器接口</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用 for of<br><span class="hljs-bullet">2.</span> 解构赋值<br><span class="hljs-bullet">3.</span> 扩展运算符 ...<br><span class="hljs-bullet">4.</span> Set 构造函数的参数<br><span class="hljs-bullet">5.</span> WeakSet 构造函数的参数<br><span class="hljs-bullet">6.</span> Map 构造函数的参数<br><span class="hljs-bullet">7.</span> WeakMap 构造函数的参数<br><span class="hljs-bullet">8.</span> Array.form() 的参数<br></code></pre></td></tr></table></figure><blockquote><p>以上用法都会调用可遍历对象的 iterator 接口， 以上用法必须使用可遍历对象！</p></blockquote><h4 id="④-可遍历对象（iterable）和遍历器对象（iterator）的关系"><a href="#④-可遍历对象（iterable）和遍历器对象（iterator）的关系" class="headerlink" title="④ 可遍历对象（iterable）和遍历器对象（iterator）的关系"></a>④ 可遍历对象（iterable）和遍历器对象（iterator）的关系</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-number">1.</span> <span class="hljs-built_in">iterator</span> 对象也是 <span class="hljs-keyword">iterable</span> 对象<br><span class="hljs-number">2.</span> <span class="hljs-keyword">iterable</span> 对象不一定是 <span class="hljs-built_in">iterator</span> 对象<br></code></pre></td></tr></table></figure><h4 id="⑤-可遍历对象（iterable）和伪数组的关系"><a href="#⑤-可遍历对象（iterable）和伪数组的关系" class="headerlink" title="⑤ 可遍历对象（iterable）和伪数组的关系"></a>⑤ 可遍历对象（iterable）和伪数组的关系</h4><p><strong>伪数组：</strong> 也称之为类数组（Like-Array）; 像数组那样具有索引结构和 length 属性的对象。</p><p><strong>可遍历对象：</strong> 实现了遍历器接口的对象。</p><p>伪数组不一定是可遍历对象，可遍历对象也不一定是伪数组。</p><h3 id="11-3-for-…-of"><a href="#11-3-for-…-of" class="headerlink" title="11.3 for … of"></a>11.3 for … of</h3><p>for … of 可以用来遍历可遍历对象和遍历器对象。</p><h2 id="12-生成器-generator"><a href="#12-生成器-generator" class="headerlink" title="12 生成器 generator"></a>12 生成器 generator</h2><h3 id="12-1-什么是生成器"><a href="#12-1-什么是生成器" class="headerlink" title="12.1 什么是生成器"></a>12.1 什么是生成器</h3><p>生成器就是用于生成遍历器对象的函数。</p><h3 id="12-2-如何定义生成器"><a href="#12-2-如何定义生成器" class="headerlink" title="12.2 如何定义生成器"></a>12.2 如何定义生成器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* 生成器名(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span>; i &lt;= <span class="hljs-number">100</span>; i += <span class="hljs-number">10</span>) &#123;<br>         <span class="hljs-keyword">yield</span> i;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用生成器，得到一个遍历器对象！</p><h3 id="12-3-yield-关键字"><a href="#12-3-yield-关键字" class="headerlink" title="12.3 yield 关键字"></a>12.3 yield 关键字</h3><p>调用生成器函数，生成器里面的代码不会执行，仅仅是得到一个遍历器对象。</p><p>给遍历器对象调用 next() 的时候，执行生成器的代码，遇到 yield 关键字结束，yield 关键字的返回作为 next() 返回的对象中的 value 值； 再次调用 next()，执行到下一个 yield。</p><h3 id="12-4-利用生成器给对象部署-iterator-接口（自定义可遍历对象）"><a href="#12-4-利用生成器给对象部署-iterator-接口（自定义可遍历对象）" class="headerlink" title="12.4 利用生成器给对象部署 iterator 接口（自定义可遍历对象）"></a>12.4 利用生成器给对象部署 iterator 接口（自定义可遍历对象）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;朦朦&#x27;</span>,<br>    age: <span class="hljs-number">198</span>,<br>    address: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>    grade: <span class="hljs-number">10</span>,<br>    <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 给 obj 部署一个 iterator 接口</span><br>obj[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">yield</span> [i, obj[i]];   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="13-新增运算符-ES2020"><a href="#13-新增运算符-ES2020" class="headerlink" title="13 新增运算符 (ES2020)"></a>13 新增运算符 (ES2020)</h2><h3 id="13-1-可选链运算符"><a href="#13-1-可选链运算符" class="headerlink" title="13.1 可选链运算符 ?."></a>13.1 可选链运算符 <code>?.</code></h3><p>可选链运算符( <strong><code>?.</code></strong> )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。</p><p><code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空(null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p><p>当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> adventurer = &#123;<br>  name: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  cat: &#123;<br>    name: <span class="hljs-string">&#x27;Dinah&#x27;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> dogName = adventurer.dog?.name;<br><span class="hljs-built_in">console</span>.log(dogName);   <span class="hljs-comment">//  undefined</span><br><br><span class="hljs-built_in">console</span>.log(adventurer.someNonExistentMethod?.()); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="13-2-空值合并运算符"><a href="#13-2-空值合并运算符" class="headerlink" title="13.2 空值合并运算符??"></a>13.2 空值合并运算符<code>??</code></h3><p><strong>空值合并运算符</strong>（**<code>??</code>**）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与逻辑或运算符符（<code>||</code>）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>&#39;&#39;</code> 或 <code>0</code>）时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;default string&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// &quot;default string&quot;</span><br><br><span class="hljs-keyword">const</span> baz = <span class="hljs-number">0</span> ?? <span class="hljs-number">42</span>;<br><span class="hljs-built_in">console</span>.log(baz);  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BootStrap 教程</title>
    <link href="/2021/02/21/BootStrap%20%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/21/BootStrap%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="BootStrap-教程"><a href="#BootStrap-教程" class="headerlink" title="BootStrap 教程"></a>BootStrap 教程</h1><p><strong>bootstrap 3 文档地址：</strong> <a href="https://v3.bootcss.com/">https://v3.bootcss.com/</a></p><h2 id="1-全局样式"><a href="#1-全局样式" class="headerlink" title="1 全局样式"></a>1 全局样式</h2><h3 id="2-1-栅格系统"><a href="#2-1-栅格系统" class="headerlink" title="2.1 栅格系统"></a>2.1 栅格系统</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">row</span>表示行<br>.<span class="hljs-built_in">col</span>-xs/sm/md/<span class="hljs-built_in">lg</span>-数字列，指定占多少份<br></code></pre></td></tr></table></figure><blockquote><p>把父元素分为 12 份，子元素指定占其中多少份的宽度！</p></blockquote><p><strong>列偏移</strong>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">col</span>-xs/<span class="hljs-keyword">sm</span>/md/<span class="hljs-keyword">lg</span>-offset-*<br></code></pre></td></tr></table></figure><blockquote><p>实现原理： 设置 margin-left</p></blockquote><p><strong>列排序：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">col</span>-xs/<span class="hljs-keyword">sm</span>/md/<span class="hljs-keyword">lg</span>-push-*元素位置向右偏移<br><span class="hljs-keyword">col</span>-xs/<span class="hljs-keyword">sm</span>/md/<span class="hljs-keyword">lg</span>-pull-*元素位置向左偏移<br></code></pre></td></tr></table></figure><blockquote><p>实现元素：通过设置相对定位。</p></blockquote><h3 id="2-2-响应式"><a href="#2-2-响应式" class="headerlink" title="2.2 响应式"></a>2.2 响应式</h3><table><thead><tr><th></th><th>超小屏幕</th><th>小屏幕</th><th>中等屏幕</th><th>大屏幕</th></tr></thead><tbody><tr><td>视口大小</td><td>&lt; 768px</td><td>768px ~ 992px</td><td>992px ~ 1200px</td><td>&gt;= 1200px</td></tr><tr><td>媒体查询语法</td><td>默认</td><td><code>@media (min-width: 768px)</code></td><td><code>@media (min-width: 992px)</code></td><td><code>@meida )(min-width: 1200px)</code></td></tr><tr><td><code>.container</code> 的宽度</td><td>100%</td><td>750px</td><td>970px</td><td>1170px;</td></tr><tr><td>列的类名</td><td><code>.col-xs-*</code></td><td><code>.col-sm-*</code></td><td><code>.col-md-*</code></td><td><code>.col-lg-*</code></td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ol><li>可以设置列宽在不同尺寸的屏幕下，所占的份数不同。</li><li>如果只设置了某列在中等屏幕下的宽度，比中等屏幕大的屏幕也按照该设置；比中等屏幕小的默认设置 100%；</li></ol></blockquote><h3 id="2-3-表格"><a href="#2-3-表格" class="headerlink" title="2.3 表格"></a>2.3 表格</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.table</span>基本样式<br><span class="hljs-selector-class">.table-striped</span>条纹表格<br><span class="hljs-selector-class">.table-bordered</span>带边框的表格<br><span class="hljs-selector-class">.table-hover</span>表格每一行鼠标悬停背景色变化<br><span class="hljs-selector-class">.table-condensed</span>    更紧缩的表格（单元格边框与内容间距小）<br><span class="hljs-selector-class">.active</span> (灰色) <span class="hljs-selector-class">.success</span>(绿色)、<span class="hljs-selector-class">.info</span>(蓝色)、<span class="hljs-selector-tag">warning</span>(黄色)、<span class="hljs-selector-tag">danger</span>(红色)  类名添加给 <span class="hljs-selector-tag">tr</span> 或 <span class="hljs-selector-tag">td</span><br></code></pre></td></tr></table></figure><h3 id="2-4-表单"><a href="#2-4-表单" class="headerlink" title="2.4 表单"></a>2.4 表单</h3><h4 id="①-基本样式"><a href="#①-基本样式" class="headerlink" title="① 基本样式"></a>① 基本样式</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">form<br>.form-group<br>表单控件 .form-control<br></code></pre></td></tr></table></figure><h4 id="②-水平排列的表单"><a href="#②-水平排列的表单" class="headerlink" title="② 水平排列的表单"></a>② 水平排列的表单</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.form-horizontal</span><br><span class="hljs-selector-class">.form-group</span>相当于行<br><span class="hljs-selector-class">.control-label</span><span class="hljs-selector-class">.col-</span>*<span class="hljs-selector-tag">-</span>*<br><span class="hljs-selector-class">.col-</span>*<span class="hljs-selector-tag">-</span>*<br><span class="hljs-selector-class">.form-control</span><br></code></pre></td></tr></table></figure><h3 id="2-5-按钮"><a href="#2-5-按钮" class="headerlink" title="2.5 按钮"></a>2.5 按钮</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">基本类：<br><span class="hljs-title">.btn</span><br><br>按钮的背景色：<br><span class="hljs-title">.btn-default透明色</span><br><span class="hljs-title">.btn-primary深蓝色</span><br><span class="hljs-title">.btn-sucess绿色</span><br><span class="hljs-title">.btn-info浅蓝色</span><br><span class="hljs-title">.btn-warning黄色</span><br><span class="hljs-title">.btn-danger红色</span><br><span class="hljs-title">.btn-link链接样式的按钮</span><br><br>按钮尺寸：<br><span class="hljs-title">.btn-lg</span><br><span class="hljs-title">.btn-sm</span><br><br>块级元素按钮：<br><span class="hljs-title">.btn-block</span><br></code></pre></td></tr></table></figure><h3 id="2-6-辅助类"><a href="#2-6-辅助类" class="headerlink" title="2.6 辅助类"></a>2.6 辅助类</h3><h4 id="①-文字颜色"><a href="#①-文字颜色" class="headerlink" title="① 文字颜色"></a>① 文字颜色</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">text</span>-muted灰色<br><span class="hljs-type">text</span>-<span class="hljs-keyword">primary</span>深蓝色<br><span class="hljs-type">text</span>-success绿色<br><span class="hljs-type">text</span>-<span class="hljs-keyword">info</span>浅蓝色<br><span class="hljs-type">text</span>-<span class="hljs-built_in">warning</span>黄色<br><span class="hljs-type">text</span>-danger红色<br></code></pre></td></tr></table></figure><h4 id="②-背景颜色"><a href="#②-背景颜色" class="headerlink" title="② 背景颜色"></a>② 背景颜色</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bg-priamry</span>深蓝色<br><span class="hljs-keyword">bg-success</span><br><span class="hljs-keyword">bg-info</span><br><span class="hljs-keyword">bg-warning</span><br><span class="hljs-keyword">bg-dannger</span><br></code></pre></td></tr></table></figure><h3 id="2-7-响应式工具类"><a href="#2-7-响应式工具类" class="headerlink" title="2.7 响应式工具类"></a>2.7 响应式工具类</h3><h4 id="①-显示"><a href="#①-显示" class="headerlink" title="① 显示"></a>① 显示</h4><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-symbol">visible</span>-xs-*只有超小屏幕显示，其他都隐藏<br><span class="hljs-symbol">visible</span>-sm-*只有小屏幕显示，其他都隐藏<br><span class="hljs-symbol">visible</span>-md-*只有中等屏幕显示，其他都隐藏<br><span class="hljs-symbol">visible</span>-lg-*只有大屏幕显示，其他都隐藏<br></code></pre></td></tr></table></figure><blockquote><p><code>*</code> 可以写 block    inline    inline-block</p></blockquote><h4 id="②-隐藏"><a href="#②-隐藏" class="headerlink" title="② 隐藏"></a>② 隐藏</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">hidden</span>-xs只有超小屏幕隐藏，其他都显示<br><span class="hljs-keyword">hidden</span>-sm只有小屏幕隐藏，其他都显示<br><span class="hljs-keyword">hidden</span>-md只有中等屏幕隐藏，其他都显示<br><span class="hljs-keyword">hidden</span>-lg只有大屏幕隐藏，其他都显示<br></code></pre></td></tr></table></figure><h2 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">导航条   <span class="hljs-string">navbar</span><br><span class="hljs-string"></span>下拉菜单 <span class="hljs-string">dropdown</span><br><span class="hljs-string"></span>输入框组<span class="hljs-string">input-group</span><br><span class="hljs-string"></span>徽章  <span class="hljs-string">badge</span><br><span class="hljs-string"></span>路径导航    <span class="hljs-string">breadcrumb</span><br><span class="hljs-string"></span>缩略图<span class="hljs-string">thumbnail</span><br><span class="hljs-string"></span>分页<span class="hljs-string">paganation</span><br><span class="hljs-string"></span>进度条<span class="hljs-string">progress-bar</span><br><span class="hljs-string"></span>列表组<span class="hljs-built_in">list-group</span><br><span class="hljs-built_in">媒体对象</span><span class="hljs-string">media-object</span><br></code></pre></td></tr></table></figure><h2 id="3-JavaScript-插件"><a href="#3-JavaScript-插件" class="headerlink" title="3 JavaScript 插件"></a>3 JavaScript 插件</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">下拉菜单<span class="hljs-selector-tag">dropdown</span><span class="hljs-selector-class">.js</span><br>显示隐藏插件   <span class="hljs-selector-tag">collapse</span><span class="hljs-selector-class">.js</span><br>模态框  <span class="hljs-selector-tag">modal</span><span class="hljs-selector-class">.js</span><br>轮播图<span class="hljs-selector-tag">carousel</span><span class="hljs-selector-class">.js</span><br>选项卡<span class="hljs-selector-tag">tab</span><span class="hljs-selector-class">.js</span><br>滚动监听<span class="hljs-selector-tag">scroll</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><h2 id="4-BootStrap-定制和主题"><a href="#4-BootStrap-定制和主题" class="headerlink" title="4 BootStrap 定制和主题"></a>4 BootStrap 定制和主题</h2><p>定制 BootStrap： <a href="https://v3.bootcss.com/customize/">https://v3.bootcss.com/customize/</a></p><p>BootStrap 主题分享网站： <a href="https://bootswatch.com/3/">https://bootswatch.com/3/</a></p><h2 id="6-自定义栅格系统"><a href="#6-自定义栅格系统" class="headerlink" title="6 自定义栅格系统"></a>6 自定义栅格系统</h2><h3 id="6-1-基本原理"><a href="#6-1-基本原理" class="headerlink" title="6.1 基本原理"></a>6.1 基本原理</h3><p><strong>基本栅格系统：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">.col-<span class="hljs-number">1</span> &#123;<br>    width: <span class="hljs-number">8.33</span>%;<br>&#125;<br>.col-<span class="hljs-number">2</span> &#123;<br>    width: <span class="hljs-number">16.66</span>%;<br>&#125;<br>...<br>.col-<span class="hljs-number">12</span> &#123;<br>    width: <span class="hljs-number">100</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>响应式栅格系统：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.col-xs-1</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">8.33%</span>;<br>&#125;<br><span class="hljs-selector-class">.col-xs-2</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">16.66</span>;<br>&#125;<br>...<br><span class="hljs-selector-class">.col-xs-12</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">768px</span>) &#123;<br><span class="hljs-selector-class">.col-sm-1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">8.33%</span>;<br>    &#125;<br>    <span class="hljs-selector-class">.col-sm-2</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">16.66</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-selector-class">.col-sm-12</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">992px</span>) &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">@meida</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">1200px</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Less-自定义栅格系统"><a href="#6-2-Less-自定义栅格系统" class="headerlink" title="6.2 Less 自定义栅格系统"></a>6.2 Less 自定义栅格系统</h3><h4 id="①-目录结构"><a href="#①-目录结构" class="headerlink" title="① 目录结构"></a>① 目录结构</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">| -- aootstrap.less总入口文件</span><br><span class="hljs-string">| -- variables.less用于定义变量</span><br><span class="hljs-string">| -- mixins.less导入混合</span><br><span class="hljs-string">| -- normailze.less重置样式</span><br><span class="hljs-string">| -- layout.less全局样式</span><br><span class="hljs-string">| -- grid.less栅格系统样式</span><br><span class="hljs-string">| -- mixins存放混合的文件夹</span><br><span class="hljs-string">| ---- clearfix.less定义了清除浮动的混合</span><br><span class="hljs-string">| ---- grid.less定义了栅格系统相关的混合</span><br></code></pre></td></tr></table></figure><h4 id="②-递归调用混合实现了循环结构"><a href="#②-递归调用混合实现了循环结构" class="headerlink" title="② 递归调用混合实现了循环结构"></a>② 递归调用混合实现了循环结构</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.make-col</span>(<span class="hljs-variable">@class</span>) &#123;<br>    <span class="hljs-comment">// 定义混合</span><br>    <span class="hljs-selector-class">.col</span>(<span class="hljs-variable">@num</span>)<span class="hljs-keyword">when</span>(<span class="hljs-variable">@num</span>&lt;=<span class="hljs-variable">@grid-columns</span>)  &#123;<br>        <span class="hljs-comment">// 输出样式代码</span><br>        <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-</span><span class="hljs-variable">@&#123;num&#125;</span> &#123;<br>            <span class="hljs-attribute">width</span>: percentage((<span class="hljs-variable">@num</span>/<span class="hljs-variable">@grid-columns</span>));<br>        &#125;<br>        <span class="hljs-comment">// 递归调用</span><br>        <span class="hljs-selector-class">.col</span>(<span class="hljs-variable">@num</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 调用混合</span><br>    <span class="hljs-selector-class">.col</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jQuery 教程</title>
    <link href="/2021/02/21/jQuery%20%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/21/jQuery%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery-教程"><a href="#jQuery-教程" class="headerlink" title="jQuery 教程"></a>jQuery 教程</h1><h2 id="1-jQuery-的基础"><a href="#1-jQuery-的基础" class="headerlink" title="1 jQuery 的基础"></a>1 jQuery 的基础</h2><p>官网地址：<a href="https://jquery.com/">https://jquery.com/</a></p><p>在线手册地址：<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a></p><h3 id="1-1-jQuery-的版本"><a href="#1-1-jQuery-的版本" class="headerlink" title="1.1 jQuery 的版本"></a>1.1 jQuery 的版本</h3><h4 id="不同的开发版本"><a href="#不同的开发版本" class="headerlink" title="不同的开发版本"></a>不同的开发版本</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jquery</span>-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.js完整版本<br><span class="hljs-attribute">jquery</span>-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.min.js压缩版（去掉了空格换行，简化了变量名）（适合于生产环境）<br><span class="hljs-attribute">jquery</span>-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.slim.js瘦身版（不再兼容IE，去掉了动画等功能）<br></code></pre></td></tr></table></figure><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">1<span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span> 版本： 可以兼容 <span class="hljs-selector-tag">IE8</span><br>2<span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span>/3<span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span> 版本： 不兼容 <span class="hljs-selector-tag">IE8</span><br></code></pre></td></tr></table></figure><h3 id="1-2-如何使用-jQuery"><a href="#1-2-如何使用-jQuery" class="headerlink" title="1.2 如何使用 jQuery"></a>1.2 如何使用 jQuery</h3><h4 id="①-导入本地的-jQuery-文件"><a href="#①-导入本地的-jQuery-文件" class="headerlink" title="① 导入本地的 jQuery 文件"></a>① 导入本地的 jQuery 文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../jquery/jquery-3.4.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>把 jQuey 从官网下载到本地，使用相对路径导入到页面中。</p><h4 id="②-导入-CDN-上的-jQuery-文件"><a href="#②-导入-CDN-上的-jQuery-文件" class="headerlink" title="② 导入 CDN 上的 jQuery 文件"></a>② 导入 CDN 上的 jQuery 文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="③-根据浏览器版本加载不同版本的-jQuery"><a href="#③-根据浏览器版本加载不同版本的-jQuery" class="headerlink" title="③ 根据浏览器版本加载不同版本的 jQuery"></a>③ 根据浏览器版本加载不同版本的 jQuery</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!--IE9及以上以及其他浏览器--&gt;<br>&lt;!--[<span class="hljs-keyword">if</span> gt IE <span class="hljs-number">8</span>]&gt;&lt;!--&gt;<br>&lt;script src=<span class="hljs-string">&quot;../../dist/jquery-3.1.1.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;!--&lt;![endif]--&gt;<br>&lt;!--IE8以及以下浏览器--&gt;<br>&lt;!--[<span class="hljs-keyword">if</span> lte IE <span class="hljs-number">8</span>]&gt;<br>&lt;script src=<span class="hljs-string">&quot;../../dist/jquery-1.12.4.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;![endif]--&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-核心函数-jQuery-对象"><a href="#1-3-核心函数-jQuery-对象" class="headerlink" title="1.3 核心函数 / jQuery 对象"></a>1.3 核心函数 / jQuery 对象</h3><h4 id="①-使用核心函数获取页面中的元素"><a href="#①-使用核心函数获取页面中的元素" class="headerlink" title="① 使用核心函数获取页面中的元素"></a>① 使用核心函数获取页面中的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;选择器&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>参数是字符串，里面写 jQuery 选择器（基本与 CSS 选择器一致）</p><p>核心函数返回获取到元素对象（jQuery DOM）</p></blockquote><h4 id="②-把原生-DOM-转为-jQuery-DOM"><a href="#②-把原生-DOM-转为-jQuery-DOM" class="headerlink" title="② 把原生 DOM 转为 jQuery DOM"></a>② 把原生 DOM 转为 jQuery DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(原生dom对象)<br></code></pre></td></tr></table></figure><blockquote><p>参数是原生 DOM 对象</p><p>返回时 jQuery DOM 对象（对应的元素与元素DOM对应的元素一致）</p></blockquote><h4 id="③-文档就绪事件的简写"><a href="#③-文档就绪事件的简写" class="headerlink" title="③ 文档就绪事件的简写"></a>③ 文档就绪事件的简写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    code ...<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>参数是回调函数！</p></blockquote><h4 id="④-创建新元素"><a href="#④-创建新元素" class="headerlink" title="④ 创建新元素"></a>④ 创建新元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>);  <span class="hljs-comment">// 创建了空的元素 没有内容</span><br>$(<span class="hljs-string">&#x27;&lt;div&gt;文本内容&lt;/div&gt;&#x27;</span>);  <span class="hljs-comment">// 如果创建元素的时候需要指定里面的文本内容，把双标签写完成</span><br></code></pre></td></tr></table></figure><blockquote><p>参数是字符串，但是字符串内容是 html 标签。</p><p>返回包含了新创建的元素的 jQuery DOM 对象。</p></blockquote><h3 id="1-4-jQuery-DOM-对象"><a href="#1-4-jQuery-DOM-对象" class="headerlink" title="1.4 jQuery DOM 对象"></a>1.4 jQuery DOM 对象</h3><h4 id="①-jQuery-DOM-对象"><a href="#①-jQuery-DOM-对象" class="headerlink" title="① jQuery DOM 对象"></a>① jQuery DOM 对象</h4><p>使用jQuery 方式获取的元素对象就是jQuery DOM。</p><h4 id="②-原生-DOM"><a href="#②-原生-DOM" class="headerlink" title="② 原生 DOM"></a>② 原生 DOM</h4><p>使用原生 js 方式获取的元素对象，就是原生DOM</p><h4 id="③-原生-DOM-和-jQuery-DOM-互相转换"><a href="#③-原生-DOM-和-jQuery-DOM-互相转换" class="headerlink" title="③  原生 DOM 和 jQuery DOM 互相转换"></a>③  原生 DOM 和 jQuery DOM 互相转换</h4><p><strong>原生DOM 和 jQuery DOM 是不同类型的对象，方法属性都不一致，但是都是用于操作文档结构中的元素</strong></p><p><strong>把原生 DOM 转为 jQuery DOM：</strong> 使用 jQuery 核心函数。</p><p><strong>把 jQuery DOM 转为原生 DOM：</strong> jQuery 是个伪数组，是由原生 DOM 组成的集合，通过索引取出其中的成员就可以得到原生 DOM。</p><h3 id="1-5-文档就绪事件"><a href="#1-5-文档就绪事件" class="headerlink" title="1.5 文档就绪事件"></a>1.5 文档就绪事件</h3><h4 id="①-语法"><a href="#①-语法" class="headerlink" title="① 语法"></a>① 语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 完整的写法</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    code ...<br>&#125;);<br>    <br><span class="hljs-comment">// 简写</span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   code ... <br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="②-ready-事件与-load-的事件区别"><a href="#②-ready-事件与-load-的事件区别" class="headerlink" title="② ready 事件与 load 的事件区别"></a>② ready 事件与 load 的事件区别</h4><p><strong>ready 事件：</strong> 等到页面中所有的元素加载完毕触发事件，类似于 DOMContentLoaded 事件。</p><p><strong>load 事件：</strong> 等到页面中所有的一切加载完毕（包括所有的元素和外部的其他资源）。</p><h3 id="1-6-链式调用（连贯操作）"><a href="#1-6-链式调用（连贯操作）" class="headerlink" title="1.6 链式调用（连贯操作）"></a>1.6 链式调用（连贯操作）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(dom).css().width().height()<br></code></pre></td></tr></table></figure><blockquote><p><strong>实现原理：</strong> 方法中返回 this 即可（谁调用方法，方法就返回谁）</p></blockquote><h2 id="2-jQuery-选择器"><a href="#2-jQuery-选择器" class="headerlink" title="2 jQuery 选择器"></a>2 jQuery 选择器</h2><h3 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a>2.1 基本选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#ID</span><span class="hljs-selector-tag">ID</span> 名选择器<br><span class="hljs-selector-class">.className</span>类名选择器<br><span class="hljs-selector-tag">tagName</span>标签名选择器<br>*全局选择器<br><span class="hljs-selector-tag">selector01</span>,<span class="hljs-selector-tag">selector02</span> 并集选择器<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.item</span>交集选择器<br></code></pre></td></tr></table></figure><blockquote><p>与 css3 基本选择器一致！</p></blockquote><h3 id="2-2-层级选择器"><a href="#2-2-层级选择器" class="headerlink" title="2.2 层级选择器"></a>2.2 层级选择器</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">selector01</span> selector<span class="hljs-number">02</span>后代元素选择器<br><span class="hljs-attribute">selector01</span>&gt;selector<span class="hljs-number">02</span>子元素选择器<br><span class="hljs-attribute">selector01</span>+selector<span class="hljs-number">02</span>相邻兄弟元素选择器（后面紧邻的一个兄弟元素）<br><span class="hljs-attribute">selector01</span>~selector<span class="hljs-number">02</span>通用兄弟元素选择器（后面所有的兄弟元素）<br></code></pre></td></tr></table></figure><blockquote><p>与 CSS3 层级选择器一致！</p></blockquote><h3 id="2-3-过滤选择器"><a href="#2-3-过滤选择器" class="headerlink" title="2.3 过滤选择器"></a>2.3 过滤选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">与 <span class="hljs-selector-tag">CSS3</span> 选择器一致的：<br><span class="hljs-selector-pseudo">:root</span><br><span class="hljs-selector-pseudo">:lang()</span><br><span class="hljs-selector-pseudo">:target</span><br><span class="hljs-selector-pseudo">:focus</span><br><span class="hljs-selector-pseudo">:not(selector)</span><br><br><span class="hljs-selector-tag">jQuery</span> 所特有的：<br><span class="hljs-selector-pseudo">:first</span><br><span class="hljs-selector-pseudo">:last</span><br><span class="hljs-selector-pseudo">:eq(n)</span><span class="hljs-selector-tag">n</span> 从 0 开始<br><span class="hljs-selector-pseudo">:odd</span><br><span class="hljs-selector-pseudo">:even</span><br><span class="hljs-selector-pseudo">:lt(n)</span><br><span class="hljs-selector-pseudo">:gt(n)</span><br><span class="hljs-selector-pseudo">:header</span>选择<span class="hljs-selector-tag">h1</span>~<span class="hljs-selector-tag">h6</span><br><span class="hljs-selector-pseudo">:animated</span>选择正在执行动画的元素（<span class="hljs-selector-tag">jQuery</span>动画）<br></code></pre></td></tr></table></figure><h3 id="2-4-内容选择器"><a href="#2-4-内容选择器" class="headerlink" title="2.4 内容选择器"></a>2.4 内容选择器</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">与 CSS3 选择器一致：<br>:empty选择既没有后代也没有内容的元素<br><br>jQuery 所独有的选择器：<br><span class="hljs-meta">:parent选择有后代或者有内容的元素，与 :empty</span> 相反<br>:contains(text)选择包含指定文本内容的元素（自己包含或者后代元素包含）<br>:has(选择器)选择包含指定后代的某个元素（根据儿子找老子）<br></code></pre></td></tr></table></figure><h3 id="2-5-可见性选择器"><a href="#2-5-可见性选择器" class="headerlink" title="2.5 可见性选择器"></a>2.5 可见性选择器</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">:hidden选择不可见的元素（display设置为none的元素或者隐藏域）<br><span class="hljs-meta">:visible选择可见的元素（不满足 :hidden,就满足</span> :visible）<br></code></pre></td></tr></table></figure><h3 id="2-6-属性选择器"><a href="#2-6-属性选择器" class="headerlink" title="2.6 属性选择器"></a>2.6 属性选择器</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">与 CSS3 选择器一致：<br>[<span class="hljs-meta">attrName</span>]选择包含指定属性的元素<br>[<span class="hljs-meta">attrName=<span class="hljs-meta-string">&quot;value&quot;</span></span>]选择属性的值是<span class="hljs-keyword">value</span>的元素<br>[<span class="hljs-meta">attrName^=<span class="hljs-meta-string">&quot;value&quot;</span></span>]选择属性的值以<span class="hljs-keyword">value</span>开头的元素<br>[<span class="hljs-meta">attrName$=<span class="hljs-meta-string">&quot;value&quot;</span></span>]选择属性的值以<span class="hljs-keyword">value</span>结尾的元素<br>[<span class="hljs-meta">attrName*=<span class="hljs-meta-string">&quot;value&quot;</span></span>]选择属性的值中包含<span class="hljs-keyword">value</span>的元素<br><br>jQuery选择器所特有：<br>[<span class="hljs-meta">attrName!=<span class="hljs-meta-string">&quot;value&quot;</span></span>]选择属性的值不是 <span class="hljs-keyword">value</span> 的元素<br></code></pre></td></tr></table></figure><h3 id="2-7-子元素选择器"><a href="#2-7-子元素选择器" class="headerlink" title="2.7 子元素选择器"></a>2.7 子元素选择器</h3><p>jQuery 中的子元素选择器与 CSS3 中结构伪类一致</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:first-child</span><br><span class="hljs-symbol">:last-child</span><br><span class="hljs-symbol">:nth-child</span>()<br><span class="hljs-symbol">:nth-last-child</span>()<br><span class="hljs-symbol">:only-child</span>()<br><br><span class="hljs-symbol">:first-of-type</span><br><span class="hljs-symbol">:last-of-type</span><br><span class="hljs-symbol">:nth-of-type</span>()<br><span class="hljs-symbol">:nth-last-of-type</span>()<br><span class="hljs-symbol">:only-of-type</span>()<br></code></pre></td></tr></table></figure><blockquote><p>与 CSS3 结构伪类选择器一致</p></blockquote><h3 id="2-8-表单选择器"><a href="#2-8-表单选择器" class="headerlink" title="2.8 表单选择器"></a>2.8 表单选择器</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">:<span class="hljs-type">text</span>选择到 <span class="hljs-keyword">type</span> 值是 <span class="hljs-type">text</span> 的 <span class="hljs-keyword">input</span> 元素<span class="hljs-keyword">input</span>[<span class="hljs-keyword">type</span>=&quot;text&quot;]<br>:<span class="hljs-keyword">password</span>选择到 <span class="hljs-keyword">type</span> 值是 <span class="hljs-keyword">password</span> 的 <span class="hljs-keyword">input</span> 元素<br>:radio选择到 <span class="hljs-keyword">type</span> 值是 radio 的 <span class="hljs-keyword">input</span> 元素<br>:checkbox选择到 <span class="hljs-keyword">type</span> 值是 checkbox 的 <span class="hljs-keyword">input</span> 元素<br>:submit选择到 <span class="hljs-keyword">type</span> 值是 submit 的 <span class="hljs-keyword">input</span> 元素或者 button 元素<br>:<span class="hljs-keyword">reset</span>选择到 <span class="hljs-keyword">type</span> 值是 <span class="hljs-keyword">reset</span> 的 <span class="hljs-keyword">input</span> 元素或者 button 元素<br>:button选择到 <span class="hljs-keyword">type</span> 值是 button 的 <span class="hljs-keyword">input</span> 元素或者 button 元素<br>:<span class="hljs-keyword">input</span>选择到所有的表单控件<br></code></pre></td></tr></table></figure><h3 id="2-9-表单对象选择器"><a href="#2-9-表单对象选择器" class="headerlink" title="2.9 表单对象选择器"></a>2.9 表单对象选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:enabled</span>选择可用的表单控件<br><span class="hljs-selector-pseudo">:disabled</span>选择不可用的表单控件（设置了属性 <span class="hljs-selector-tag">disabled</span>）<br><span class="hljs-selector-pseudo">:checked</span>选择被选中的单选按钮或者复选框<br><span class="hljs-selector-pseudo">:selected</span>选择被选中的下拉选项<br></code></pre></td></tr></table></figure><blockquote><p>与 CSS3 UI 伪类选择器一致</p></blockquote><h3 id="2-10-注意事项"><a href="#2-10-注意事项" class="headerlink" title="2.10 注意事项"></a>2.10 注意事项</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">:<span class="hljs-built_in">first</span>与 :<span class="hljs-built_in">first</span>-child 区别：<br><span class="hljs-number">1</span>. :<span class="hljs-built_in">first</span> 从所有满足条件的元素中选择第一个<br><span class="hljs-number">2</span>. :<span class="hljs-built_in">first</span>-child  分别从相同父元素的兄弟元素中选择第一个<br><br><span class="hljs-built_in">li</span>:<span class="hljs-built_in">first</span> 与 <span class="hljs-built_in">li</span> :<span class="hljs-built_in">first</span> 区别：<br><span class="hljs-number">1</span>. <span class="hljs-built_in">li</span>:<span class="hljs-built_in">first</span>,先找到所有的 <span class="hljs-built_in">li</span>，再从里面选择第一个。<br><span class="hljs-number">2</span>. <span class="hljs-built_in">li</span> :<span class="hljs-built_in">first</span>,先找到 <span class="hljs-built_in">li</span> 所有的后代，再从里面选择第一个<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>不论是 CSS 选择器还是 jQuery 选择器，带 : 的选择器，都没有找后代元素或者祖先元素的； 都是对已经选择到的元素中进行过滤。</p></blockquote><h2 id="3-jQuery-筛选器方法"><a href="#3-jQuery-筛选器方法" class="headerlink" title="3 jQuery 筛选器方法"></a>3 jQuery 筛选器方法</h2><h3 id="3-1-过滤方法"><a href="#3-1-过滤方法" class="headerlink" title="3.1 过滤方法"></a>3.1 过滤方法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">first</span><span class="hljs-params">()</span></span>返回集合中的第一个<br><span class="hljs-function"><span class="hljs-title">last</span><span class="hljs-params">()</span></span>返回集合中的最后一个<br><span class="hljs-function"><span class="hljs-title">eq</span><span class="hljs-params">(n)</span></span>返回集合中的第 n 个， n 从 <span class="hljs-number">0</span> 开始数<br><span class="hljs-function"><span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-string">&#x27;选择器&#x27;</span>)</span></span>返回集合中满足条件的元素<br><span class="hljs-function"><span class="hljs-title">not</span><span class="hljs-params">(<span class="hljs-string">&#x27;选择器&#x27;</span>)</span></span>排除满足条件的元素<br><span class="hljs-function"><span class="hljs-title">has</span><span class="hljs-params">(<span class="hljs-string">&#x27;选择器&#x27;</span>)</span></span>返回包含指定后代元素的元素<br><span class="hljs-function"><span class="hljs-title">slice</span><span class="hljs-params">(start, end)</span></span>从集合中截取一部分<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><ol><li>过滤方法返回的仍然是一个 jQuery DOM 对象，但是所包含的元素与调用该方法的 jQuery DOM 包含的元素并不一致。</li><li>过滤方法返回的 jQuery DOM 是调用该方法的 jQuery DOM 的子集。</li></ol></blockquote><h3 id="3-2-查找方法"><a href="#3-2-查找方法" class="headerlink" title="3.2 查找方法"></a>3.2 查找方法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">后代元素：<br><span class="hljs-function"><span class="hljs-title">children</span><span class="hljs-params">([选择器])</span></span>返回子元素中所有满足条件的，如果不写参数就返回所有的子元素<br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">(选择器)</span></span>返回后代元素中所有满足条件的，参数必写。<br><br>祖先元素（父元素）：<br><span class="hljs-function"><span class="hljs-title">parent</span><span class="hljs-params">([选择器])</span></span>返回父元素<br><span class="hljs-function"><span class="hljs-title">parents</span><span class="hljs-params">([选择器])</span></span>返回所有的满足条件祖先元素，不写参数就是所有的祖先元素<br><span class="hljs-function"><span class="hljs-title">parentsUnti</span><span class="hljs-params">([选择器])</span></span>从父元素开始向上查找知道满足选择器条件的祖先元素，所有组成的集合（满足选择器条件的是不包含在内的） 不写参数，返回所有的祖先元素<br><br>兄弟元素：<br><span class="hljs-function"><span class="hljs-title">next</span><span class="hljs-params">([选择器])</span></span>返回紧邻在后面的兄弟元素<br><span class="hljs-function"><span class="hljs-title">nextAll</span><span class="hljs-params">([选择器])</span></span>返回后面所有满足条件的兄弟元素，没有参数就是所有后面的兄弟元素<br><span class="hljs-function"><span class="hljs-title">nextUntil</span><span class="hljs-params">([选择器])</span></span>后面的兄弟元素，直到满足选择器条件的就停下来（满足条件的元素不包含在内） 不写参数就是后面所有的兄弟元素<br><span class="hljs-function"><span class="hljs-title">prev</span><span class="hljs-params">([选择器])</span></span>返回紧邻在前面的兄弟元素<br><span class="hljs-function"><span class="hljs-title">prevAll</span><span class="hljs-params">([选择器])</span></span>返回前面所有的满足条件的兄弟元素，没有参数返回前面所有的兄弟元素<br><span class="hljs-function"><span class="hljs-title">prevUntil</span><span class="hljs-params">([选择器])</span></span>往前找兄弟元素，知道碰到满足条件的就停下来（满足条件的元素不包含在集合中），如果不写参数，就返回前面所有的兄弟元素<br><span class="hljs-function"><span class="hljs-title">siblings</span><span class="hljs-params">([选择器])</span></span>返回所有满足条件的兄弟元素（不包括自己）， 不写参数就返回所有的兄弟元素。<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意事项：</strong></p><ol><li>如果调用查找方法的 jQueryDOM 中包含多个元素，就分别选择到各个元素的亲戚元素，把它们的亲戚元素放在一起组成新的集合返回</li><li>查找方法返回的仍然是 jQuery DOM 对象，所包含的元素与调用查找方法的jQuery DOM 所包含的元素不一样。</li><li>查找方法返回的 jQuery DOM <strong>不是</strong>调用该方法的 jQuery DOM 的子集。</li></ol></blockquote><h3 id="3-3-串联方法"><a href="#3-3-串联方法" class="headerlink" title="3.3 串联方法"></a>3.3 串联方法</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add(选择器)</span>返回新的 <span class="hljs-keyword">jQueryDOM，新的 </span><span class="hljs-keyword">jQueryDOM </span>中由调用<span class="hljs-keyword">add方法的jQueryDOM中的元素和满足条件的元素组成。</span><br><span class="hljs-keyword">addBack()</span>  返回新的 <span class="hljs-keyword">jQueryDOM，新的 </span><span class="hljs-keyword">jQueryDOM包含调用 </span><span class="hljs-keyword">addBack </span>的<span class="hljs-keyword">jQuery </span>DOM 中元素 和 上一次破坏性操作前面的 <span class="hljs-keyword">jQuery </span>DOM 中的元素<br>end()  返回最近的一次破坏性操作前面的<span class="hljs-keyword">jQuery </span>DOM<br></code></pre></td></tr></table></figure><blockquote><p><strong>破坏性操作：</strong> 方法返回的 jQuery DOM 与调用该方法的 jQuery DOM 包含的元素不一致， 如过滤方法和查找方法就是破坏性操作。</p><p><strong>非破坏性操作：</strong> 方法返回的 jQueryDOM 与调用该方法的 jQuery DOM 一致。 样式操作、属性操作 等大部分 jQuery 方法都是非破坏性的。</p></blockquote><h3 id="3-4-其他方法"><a href="#3-4-其他方法" class="headerlink" title="3.4 其他方法"></a>3.4 其他方法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">is</span><span class="hljs-params">(选择器)</span></span>返回布尔值，判断调用该方法的jQueryDOM是否满足选择器条件<br><span class="hljs-function"><span class="hljs-title">map</span><span class="hljs-params">(callback)</span></span>返回新的jQueryDOM，jQueryDOM的成员个数与调用该方法的jQueryDOM成员个数一致，里面的组成取决于函数的返回值<br></code></pre></td></tr></table></figure><h2 id="4-元素的创建、添加、删除、克隆"><a href="#4-元素的创建、添加、删除、克隆" class="headerlink" title="4 元素的创建、添加、删除、克隆"></a>4 元素的创建、添加、删除、克隆</h2><h3 id="4-1-内部插入"><a href="#4-1-内部插入" class="headerlink" title="4.1 内部插入"></a>4.1 内部插入</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">append</span><span class="hljs-params">()</span></span>父元素调用最后面追加子元素，参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">appendTo</span><span class="hljs-params">()</span></span>子元素调用追加到指定的父元素中， 参数：jQueryDOM、原生DOM、选择器形式的字符串<br><span class="hljs-function"><span class="hljs-title">prepend</span><span class="hljs-params">()</span></span>父元素调用在最前面添加子元素，参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">prependTo</span><span class="hljs-params">()</span></span>子元素调用添加到指定父元素的最前面， 参数：jQueryDOM、原生DOM、选择器形式的字符串<br></code></pre></td></tr></table></figure><h3 id="4-2-外部插入"><a href="#4-2-外部插入" class="headerlink" title="4.2 外部插入"></a>4.2 外部插入</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">after</span><span class="hljs-params">()</span></span>在元素的后面添加兄弟元素参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">insertAfter</span><span class="hljs-params">()</span></span>新元素调用，作为兄弟元素添加到元素的后面 参数：jQueryDOM、原生DOM、选择器形式的字符串<br><span class="hljs-function"><span class="hljs-title">before</span><span class="hljs-params">()</span></span>在元素的前面面添加兄弟元素参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">insertBefore</span><span class="hljs-params">()</span></span>新元素调用，作为兄弟元素添加到元素的前面 参数：jQueryDOM、原生DOM、选择器形式的字符串<br></code></pre></td></tr></table></figure><h3 id="4-3-包裹"><a href="#4-3-包裹" class="headerlink" title="4.3 包裹"></a>4.3 包裹</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">wrap</span><span class="hljs-params">()</span></span>给jQueryDOM中每个元素的外面包裹一层元素参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">wrapAll</span><span class="hljs-params">()</span></span>给jQueryDOM所有元素的最外面包裹一层元素，   参数类型同上<br><span class="hljs-function"><span class="hljs-title">wrappInner</span><span class="hljs-params">()</span></span>在元素和原来的内容之间添加一层，参数类型同上。<br><span class="hljs-function"><span class="hljs-title">unwrap</span><span class="hljs-params">()</span></span>去掉包裹元素，不需要参数<br></code></pre></td></tr></table></figure><h3 id="4-4-替换"><a href="#4-4-替换" class="headerlink" title="4.4 替换"></a>4.4 替换</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">repalceWith</span><span class="hljs-params">()</span></span>旧的元素调用，参数是新元素； 参数：jQueryDOM、原生DOM、HTML标签形式的字符串<br><span class="hljs-function"><span class="hljs-title">replaceAll</span><span class="hljs-params">()</span></span>新元素调用，参数是旧元素；  参数：jQueryDOM、原生DOM、选择器形式的字符串 <br></code></pre></td></tr></table></figure><h3 id="4-5-删除"><a href="#4-5-删除" class="headerlink" title="4.5 删除"></a>4.5 删除</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span>清空元素内所有的内容<br><span class="hljs-function"><span class="hljs-title">remove</span><span class="hljs-params">()</span></span>谁调用删除谁<br></code></pre></td></tr></table></figure><h3 id="4-6-克隆"><a href="#4-6-克隆" class="headerlink" title="4.6 克隆"></a>4.6 克隆</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">clone</span><span class="hljs-params">()</span></span>克隆，深度克隆<br></code></pre></td></tr></table></figure><h2 id="5-属性和样式操作"><a href="#5-属性和样式操作" class="headerlink" title="5 属性和样式操作"></a>5 属性和样式操作</h2><h3 id="5-1-属性操作"><a href="#5-1-属性操作" class="headerlink" title="5.1 属性操作"></a>5.1 属性操作</h3><h4 id="①-属性操作"><a href="#①-属性操作" class="headerlink" title="① 属性操作"></a>① 属性操作</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">prop</span><span class="hljs-params">(属性名 [,值])</span></span>设置或获取内置属性<br><span class="hljs-function"><span class="hljs-title">removeProp</span><span class="hljs-params">(属性名)</span></span>删除内置属性<br><span class="hljs-function"><span class="hljs-title">attr</span><span class="hljs-params">(属性名 [,值])</span></span>      设置或获取自定属性<br><span class="hljs-function"><span class="hljs-title">removeAttr</span><span class="hljs-params">(属性名)</span></span>删除自定属性<br></code></pre></td></tr></table></figure><h4 id="②-data-开头的自定义属性"><a href="#②-data-开头的自定义属性" class="headerlink" title="② data- 开头的自定义属性"></a>② data- 开头的自定义属性</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">$(dom).<span class="hljs-class"><span class="hljs-keyword">data</span>(&#x27;属性名&#x27; [,值]);   // 属性名只写 <span class="hljs-keyword">data</span>- 后面的即可  读取或设置<span class="hljs-keyword">data</span>-开头的自定义属性的值</span><br></code></pre></td></tr></table></figure><blockquote><p>使用该方法设置属性值的时候，无法设置 html 标签上的属性值，值可以设置 jQuery DOM 对象上的属性值。</p></blockquote><h4 id="③-类名操作"><a href="#③-类名操作" class="headerlink" title="③ 类名操作"></a>③ 类名操作</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addClass</span><span class="hljs-params">()</span></span>新增一个类名<br><span class="hljs-function"><span class="hljs-title">removeClass</span><span class="hljs-params">()</span></span>删除一个类名<br><span class="hljs-function"><span class="hljs-title">toggleClass</span><span class="hljs-params">()</span></span>切换一个类名（有就删除，没有就添加）<br><span class="hljs-function"><span class="hljs-title">hasClass</span><span class="hljs-params">()</span></span>判断是否存在某个类名返回布尔值<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>addClass()、removeClass()、toggleClass() 都是谁调用返回谁，不是破坏性操作。</p><p>hasClass()    返回布尔值</p></blockquote><h4 id="④-代码-文本-值"><a href="#④-代码-文本-值" class="headerlink" title="④ 代码/文本/值"></a>④ 代码/文本/值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">html</span><span class="hljs-params">([value])</span></span>读取或设置元素内的代码内容类似于原生DOM的 innerHTML 属性<br><span class="hljs-function"><span class="hljs-title">text</span><span class="hljs-params">([value])</span></span>读取或设置元素内的文本内容类似于原生DOM的 textContent/innerText属性<br><span class="hljs-function"><span class="hljs-title">val</span><span class="hljs-params">([value])</span></span>读取或设置输入框中输入的内容类似于原生DOM的 value 属性<br></code></pre></td></tr></table></figure><h3 id="5-2-样式操作"><a href="#5-2-样式操作" class="headerlink" title="5.2 样式操作"></a>5.2 样式操作</h3><h4 id="①-css-方法"><a href="#①-css-方法" class="headerlink" title="① css 方法"></a>① css 方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">css</span><span class="hljs-params">()</span></span>读取或设置元素的样式； 设置的样式会设置到行内，读取样式读取的是计算样式。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置 box 元素的样式</span><br>$(<span class="hljs-string">&#x27;#box&#x27;</span>).css(<span class="hljs-string">&#x27;border&#x27;</span>, <span class="hljs-string">&#x27;5px solid red&#x27;</span>);<br><br><span class="hljs-comment">// 使用 CSS 方法同时多个样式</span><br>$(<span class="hljs-string">&#x27;#box&#x27;</span>).css(<span class="hljs-string">&#x27;margin-top&#x27;</span>, <span class="hljs-string">&#x27;100px&#x27;</span>).css(<span class="hljs-string">&#x27;box-shadow&#x27;</span>, <span class="hljs-string">&#x27;5px 5px 15px&#x27;</span>);<br><br><span class="hljs-comment">// 同时设置多个样式</span><br>$(<span class="hljs-string">&#x27;#box&#x27;</span>).css(&#123;<br>    <span class="hljs-string">&#x27;background-image&#x27;</span>: <span class="hljs-string">&#x27;url(../dist/images/db02.jpeg)&#x27;</span>,<br>    <span class="hljs-string">&#x27;margin-left&#x27;</span>: <span class="hljs-string">&#x27;200px&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="②-元素的尺寸"><a href="#②-元素的尺寸" class="headerlink" title="② 元素的尺寸"></a>② 元素的尺寸</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">width</span><span class="hljs-params">()</span></span>/ <span class="hljs-attribute">height</span>()设置或者获取元素内容的尺寸<br><span class="hljs-function"><span class="hljs-title">innerWidth</span><span class="hljs-params">()</span></span> / innerHeight()设置或获取元素内容+内边距的尺寸<br><span class="hljs-function"><span class="hljs-title">outerWidth</span><span class="hljs-params">()</span></span> / outerHeight()设置或获取元素整体尺寸（内容+内边距+边框宽度）<br></code></pre></td></tr></table></figure><h4 id="③-元素的位置"><a href="#③-元素的位置" class="headerlink" title="③ 元素的位置"></a>③ 元素的位置</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">offset</span><span class="hljs-params">()</span></span>设置或读取元素在整个页面上的位置<br><span class="hljs-function"><span class="hljs-title">scrollLeft</span><span class="hljs-params">()</span></span> / scrollTop()设置或读取元素中内容的位置<br></code></pre></td></tr></table></figure><blockquote><p>没有参数就是获取元素的位置，返回一个对象，对象中有 left 和 top 两个属性。</p><p>想要设置元素的位置，需要给一个有left和top属性的对象作为参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#box&#x27;</span>).offset(&#123;<br>    left: <span class="hljs-number">10</span>,<br>    top: <span class="hljs-number">20</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-3-注意：属性和样式操作方法的特点"><a href="#5-3-注意：属性和样式操作方法的特点" class="headerlink" title="5.3 注意：属性和样式操作方法的特点"></a>5.3 注意：属性和样式操作方法的特点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 如果设置属性值或者样式，jQuery 有几个元素就设置几个元素的属性值或样式。<br><span class="hljs-bullet">2.</span> 如果读取属性值或者样式，读取 jQuery DOM 中第一元素的属性值或样式。<br><span class="hljs-bullet">3.</span> 属性和样式操作的方法都既可以读取值也可以设置值； 读取值的时候，方法返回的是属性或样式的值； 使用方法设置属性或样式的时候，方法仍然返回调用该方法的 jQueryDOM，可以进行链式调用。<br></code></pre></td></tr></table></figure><h2 id="6-事件机制"><a href="#6-事件机制" class="headerlink" title="6 事件机制"></a>6 事件机制</h2><h3 id="6-1-添加事件监听"><a href="#6-1-添加事件监听" class="headerlink" title="6.1 添加事件监听"></a>6.1 添加事件监听</h3><blockquote><p><strong>注意：</strong> jQuery 添加事件的方法仍然返回 jQueryDOM对象，谁调用返回值！可以链式调用。</p></blockquote><h4 id="①-事件作为方法"><a href="#①-事件作为方法" class="headerlink" title="① 事件作为方法"></a>① 事件作为方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(dom).事件名(回调函数)<br></code></pre></td></tr></table></figure><h4 id="②-使用-on-方法"><a href="#②-使用-on-方法" class="headerlink" title="② 使用 on 方法"></a>② 使用 on 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(dom).on(<span class="hljs-string">&#x27;事件名&#x27;</span>, 回调函数)<br></code></pre></td></tr></table></figure><h4 id="③-事件只能触发一次"><a href="#③-事件只能触发一次" class="headerlink" title="③ 事件只能触发一次"></a>③ 事件只能触发一次</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(dom).one(<span class="hljs-string">&#x27;事件名&#x27;</span>, 回调函数)<br></code></pre></td></tr></table></figure><h3 id="6-2-移除事件监听"><a href="#6-2-移除事件监听" class="headerlink" title="6.2  移除事件监听"></a>6.2  移除事件监听</h3><p>jQuery中，不论是采用哪种方式添加的事件监听，都使用 off 方法解除事件监听。</p><p>off() 方法返回 jQuery DOM 对象，谁调用返回谁，支持链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">off(<span class="hljs-string">&#x27;事件名&#x27;</span>);   <span class="hljs-comment">// 解除元素上指定的事件监听</span><br>off();<span class="hljs-comment">// 没有参数，解除元素上所有的事件监听</span><br></code></pre></td></tr></table></figure><h3 id="6-3-使用代码触发事件"><a href="#6-3-使用代码触发事件" class="headerlink" title="6.3 使用代码触发事件"></a>6.3 使用代码触发事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一种方式 把事件作为方法调用，不要给参数</span><br>$(dom).事件名();<br><br><span class="hljs-comment">// 第二种方式 使用 trigger()</span><br>$(dom).trigger(<span class="hljs-string">&#x27;事件名&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 这两种方法，谁调用返回谁，支持链式调用！</p></blockquote><h3 id="6-4-事件委托"><a href="#6-4-事件委托" class="headerlink" title="6.4 事件委托"></a>6.4 事件委托</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#box&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-built_in">this</span>).toggleClass(<span class="hljs-string">&#x27;active&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>基本原理，与原生DOM中的事件委托一致；把事件委托给要触发事件元素的父元素或者其他祖先元素。</p><p>jQuery 中直接使用 on 方法可以实现事件委托，要实现事件委托 on 方法需要指定三个参数，分别是事件名、选择器（选择到目标元素）、回调函数</p><p>jQuery on 实现事件委托，回调函数中的 this 指向具体触发了事件的元素。</p></blockquote><h3 id="6-5-jQuery-中的事件"><a href="#6-5-jQuery-中的事件" class="headerlink" title="6.5 jQuery 中的事件"></a>6.5 jQuery 中的事件</h3><p>原生 DOM 中有什么事件，jQuery 中也有什么事件！</p><p>相比于原生DOM，jQuery中定义了几个独有的事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ready文档就绪事件，监听给 $(<span class="hljs-built_in">document</span>)<br>hover鼠标进入和离开都会触发，mouseenter 和 mouseleave 集合在一起<br>focusin当表单控件获取焦点，监听表单控件的父元素（祖先元素）<br>focusout当表单控件失去焦点，监听表单控件的父元素（祖先元素）<br></code></pre></td></tr></table></figure><h3 id="6-6-Event-对象"><a href="#6-6-Event-对象" class="headerlink" title="6.6 Event 对象"></a>6.6 Event 对象</h3><p>jQuery 事件中得到的 Event 对象与原生 JS 事件中得到的 Event 对象类型不一致，但是属性和方法都是一样，Event 对象的获取方式也是一样。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">属性：<br>clientX / clientY鼠标在视口上的位置<br>pageX / pageY鼠标在整个页面上的位置<br>screenX / screenY鼠标在屏幕上的位置<br>offsetX / offsetY鼠标在目标元素上的位置<br>target返回目标元素，原生DOM<br><span class="hljs-selector-tag">button</span>鼠标按键的值， <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br>keyCode键盘按键的 ascii 码<br>which键盘按键的 ascii 码<br>key键盘按键的值<br><br>方法：<br><span class="hljs-function"><span class="hljs-title">stopPropagation</span><span class="hljs-params">()</span></span>阻止事件冒泡<br><span class="hljs-function"><span class="hljs-title">preventDefault</span><span class="hljs-params">()</span></span>阻止默认行为<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li><p>jQuery 事件的回调函数中，如果 <code>return false</code>, 既可以阻止事件冒泡又可以阻止默认行为。</p></li><li><p>原生 JS 事件，如果是事件名作为方法方式监听的事件，回调函数中 <code>return false</code> 只能够阻止默认行为无法阻止冒泡； 如果使用 <code>addEventListener()</code> 方式监听的事件，回调函数中 <code>return false</code> 既不能阻止默认行为也不能阻止冒泡。</p></li></ol></blockquote><h2 id="7-动画效果"><a href="#7-动画效果" class="headerlink" title="7 动画效果"></a>7 动画效果</h2><h3 id="7-1-动画效果方法"><a href="#7-1-动画效果方法" class="headerlink" title="7.1 动画效果方法"></a>7.1 动画效果方法</h3><h4 id="①-基本效果"><a href="#①-基本效果" class="headerlink" title="① 基本效果"></a>① 基本效果</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hide</span><span class="hljs-params">()</span></span>隐藏<br><span class="hljs-function"><span class="hljs-title">show</span><span class="hljs-params">()</span></span>显示<br><span class="hljs-function"><span class="hljs-title">toggle</span><span class="hljs-params">()</span></span>如果元素隐藏就显示，如果元素显示就隐藏<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>设置动画执行的时间： 给动画方法设置参数，使用关键字指定：fast、normal、slow，使用数字指定（单位是毫秒），不指定默认瞬间完成。</li><li>给动画方法第二个参数设置为回调函数，该回调函数在动画执行完毕后调用。</li><li>动画执行过程，与宽高有关的（width、height、内边距、边框宽度）和 opacity 在变化。</li></ol></blockquote><h4 id="②-滑动效果"><a href="#②-滑动效果" class="headerlink" title="② 滑动效果"></a>② 滑动效果</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">slideUp</span><span class="hljs-params">()</span></span>隐藏<br><span class="hljs-function"><span class="hljs-title">slideDown</span><span class="hljs-params">()</span></span>显示<br><span class="hljs-function"><span class="hljs-title">slideToggle</span><span class="hljs-params">()</span></span>如果元素隐藏就显示，如果元素显示就隐藏<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>设置动画执行的时间： 给动画方法设置参数，使用关键字指定：fast、normal、slow，使用数字指定（单位是毫秒），不指定默认 noraml</li><li>给动画方法第二个参数设置为回调函数，该回调函数在动画执行完毕后调用。</li><li>动画执行过程，与元素高度有关（height、上下内外边距、上下边框宽度）在变化。</li></ol></blockquote><h4 id="③-淡入淡出效果"><a href="#③-淡入淡出效果" class="headerlink" title="③ 淡入淡出效果"></a>③ 淡入淡出效果</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fadeOut</span><span class="hljs-params">()</span></span>隐藏<br><span class="hljs-function"><span class="hljs-title">fadeIn</span><span class="hljs-params">()</span></span>显示<br><span class="hljs-function"><span class="hljs-title">fadeToggle</span><span class="hljs-params">()</span></span>如果元素隐藏就显示，如果元素显示就隐藏<br><span class="hljs-function"><span class="hljs-title">fadeTo</span><span class="hljs-params">(s, o [,fn])</span></span>把元素的不透明度变化到指定的位置 第一个参数是动画时间，第二个参数是oapcity的值<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>设置动画执行的时间： 给动画方法设置参数，使用关键字指定：fast、normal、slow，使用数字指定（单位是毫秒），不指定默认 noraml</li><li>给动画方法第二个参数设置为回调函数，该回调函数在动画执行完毕后调用。(fadeTo 是第三个参数)</li><li>动画执行过程，只有 opacity 的值在变化。</li></ol></blockquote><h4 id="④-自定义动画效果"><a href="#④-自定义动画效果" class="headerlink" title="④ 自定义动画效果"></a>④ 自定义动画效果</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">animate</span><span class="hljs-params">(对象，时间, 回调函数)</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>第一个参数，指定对象，对象中的属性就是发生变化的 css 属性（长度）</li><li>第二个参数指定动画持续时间，默认是 normal</li><li>指定动画执行完毕后的回调函数。</li></ol></blockquote><h3 id="7-2-动画控制方法"><a href="#7-2-动画控制方法" class="headerlink" title="7.2 动画控制方法"></a>7.2 动画控制方法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span>延迟动画的执行，参数指定时间<br><span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">()</span></span>停止动画，动画执行到哪里就停到哪里<br><span class="hljs-function"><span class="hljs-title">finish</span><span class="hljs-params">()</span></span>瞬间完成动画，瞬间显示为动画的最终状态（动画队列中的最终状态）<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意事项：</strong></p><ol><li>如果元素调用了多个动画方法，会按照调用顺序加入<strong>动画队列</strong>，动画会依次执行，上一个动画执行结束下一个动画开始执行。</li><li>如果元素触发事件执行jQuery动画，通常执行动画之前先调用 stop()，防止事件触发频繁，导致动画队列加入的动画过多。</li></ol></blockquote><h2 id="8-jQuery-工具方法"><a href="#8-jQuery-工具方法" class="headerlink" title="8 jQuery 工具方法"></a>8 jQuery 工具方法</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dom</span>)</span>.index<span class="hljs-literal">()</span>返回jQueryDOM中元素的索引位置， 如果jQueryDOM包含多个元素，返回第一元素的索引位置<br><span class="hljs-constructor">$(<span class="hljs-params">dom</span>)</span>.each(callback)遍历jQuery DOM<br></code></pre></td></tr></table></figure><h2 id="9-自定义-jQuery-插件"><a href="#9-自定义-jQuery-插件" class="headerlink" title="9 自定义 jQuery 插件"></a>9 自定义 jQuery 插件</h2><h3 id="9-1-给-jQueryDOM-扩展方法-重点"><a href="#9-1-给-jQueryDOM-扩展方法-重点" class="headerlink" title="9.1 给 jQueryDOM 扩展方法 (重点)"></a>9.1 给 jQueryDOM 扩展方法 (重点)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$.fn.extend(&#123;<br>    方法名: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9-2-给-jQuery-对象本身扩展方法"><a href="#9-2-给-jQuery-对象本身扩展方法" class="headerlink" title="9.2 给 jQuery 对象本身扩展方法"></a>9.2 给 jQuery 对象本身扩展方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$.extend(&#123;<br>    方法名: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 高级</title>
    <link href="/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-高级"><a href="#JavaScript-高级" class="headerlink" title="JavaScript 高级"></a>JavaScript 高级</h1><h2 id="1-基础深入总结"><a href="#1-基础深入总结" class="headerlink" title="1 基础深入总结"></a>1 基础深入总结</h2><h3 id="1-1-基础问题总结"><a href="#1-1-基础问题总结" class="headerlink" title="1.1 基础问题总结"></a>1.1 基础问题总结</h3><h4 id="1-null-和-undefined"><a href="#1-null-和-undefined" class="headerlink" title="(1) null 和 undefined"></a>(1) null 和 undefined</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">、</span> <span class="hljs-literal">null</span> <span class="hljs-string">和</span> <span class="hljs-string">undefined</span> <span class="hljs-string">什么区别？</span><br><span class="hljs-string">undefined：</span> <span class="hljs-string">变量定义了但是没有值。</span><br><span class="hljs-literal">null</span><span class="hljs-string">：</span> <span class="hljs-string">变量定义了值为</span> <span class="hljs-literal">null</span><span class="hljs-string">。</span><br><br><span class="hljs-number">2</span><span class="hljs-string">、</span> <span class="hljs-string">什么时候得到</span> <span class="hljs-string">undefined</span> <span class="hljs-string">？</span><br><span class="hljs-string">没有赋值的变量</span><br>    <span class="hljs-string">没有赋值的属性或获取对象中不存在的属性以及获取数组中不存在的元素</span><br>    <span class="hljs-string">没有返回值的函数，默认返回</span> <span class="hljs-string">undefined</span><br>    <span class="hljs-string">形参没有给对应的实参。</span><br><br><br><span class="hljs-number">3</span><span class="hljs-string">、</span> <span class="hljs-string">什么时候得到</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span><br><span class="hljs-string">定义了变量暂时不知道赋什么值，先赋值为</span> <span class="hljs-literal">null</span><span class="hljs-string">。</span><br><span class="hljs-string">获取dom对象的时候，如果没有满足条件的元素，得到</span> <span class="hljs-literal">null</span><span class="hljs-string">。</span><br></code></pre></td></tr></table></figure><h4 id="2-变量、数据和内存"><a href="#2-变量、数据和内存" class="headerlink" title="(2) 变量、数据和内存"></a>(2) 变量、数据和内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">数据是存储在一块内存区域内，变量就是对这一块内存的标识。<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = xxx, <span class="hljs-keyword">a</span>内存中到底保存的是什么?<br><br>如果 xxx 是原始类型/值类型，变量存在栈结构中，值也存在栈结构中<br>如果 xxx 是对象类型/引用类型，对象存在堆结构中，变量在栈中，对象的地址与变量存在一起。<br>如果 xxx 是变量，变量 xxx 栈中存的是什么，变量 <span class="hljs-keyword">a</span> 的栈中就存什么。<br></code></pre></td></tr></table></figure><h3 id="1-2-JavaScript-中的垃圾回收机制（GC）"><a href="#1-2-JavaScript-中的垃圾回收机制（GC）" class="headerlink" title="1.2 JavaScript 中的垃圾回收机制（GC）"></a>1.2 JavaScript 中的垃圾回收机制（GC）</h3><h4 id="1-垃圾回收相关概念"><a href="#1-垃圾回收相关概念" class="headerlink" title="(1) 垃圾回收相关概念"></a>(1) 垃圾回收相关概念</h4><h5 id="①-什么是垃圾"><a href="#①-什么是垃圾" class="headerlink" title="① 什么是垃圾"></a>① 什么是垃圾</h5><p>没用被引用的对象就是<strong>垃圾</strong>。</p><h5 id="②-什么是垃圾回收。"><a href="#②-什么是垃圾回收。" class="headerlink" title="② 什么是垃圾回收。"></a>② 什么是垃圾回收。</h5><p>销毁垃圾对象，释放内存，就是垃圾回收。</p><p>C / C++： 手动回收垃圾。</p><p>JavaScript / Java / Python / php 等： 自动回收垃圾。</p><h5 id="③-变量的生命周期（何时会被回收）"><a href="#③-变量的生命周期（何时会被回收）" class="headerlink" title="③ 变量的生命周期（何时会被回收）"></a>③ 变量的生命周期（何时会被回收）</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">全局变量: 全局代码执行完毕，变量会被销毁。</span><br>局部变量：本作用域代码执行完毕，局部变量被销毁。<br></code></pre></td></tr></table></figure><h5 id="④-垃圾没有及时回收的后果"><a href="#④-垃圾没有及时回收的后果" class="headerlink" title="④ 垃圾没有及时回收的后果"></a>④ 垃圾没有及时回收的后果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">垃圾对象不及时回收，常驻内存，导致内存容量不够，造成内存泄漏。<br></code></pre></td></tr></table></figure><h4 id="⑤-垃圾回收的常见算法"><a href="#⑤-垃圾回收的常见算法" class="headerlink" title="⑤ 垃圾回收的常见算法"></a>⑤ 垃圾回收的常见算法</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>引用计数  （老版本 IE）<br><span class="hljs-bullet">- </span>标记清除（大部分现代浏览器）<br></code></pre></td></tr></table></figure><h4 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="(2) 引用计数"></a>(2) 引用计数</h4><h5 id="①-原理"><a href="#①-原理" class="headerlink" title="① 原理"></a>① 原理</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>每个对象建立一个引用标记，用来标记被引用的次数<br><span class="hljs-bullet">- </span>对象没增加一次引用，引用标记就 +1<br><span class="hljs-bullet">- </span>对象被减少一次被引用，引用标记就 -1<br><span class="hljs-bullet">- </span>如果对象的引用标记变为 0，被认为是垃圾对象，立即被清除（回收）<br></code></pre></td></tr></table></figure><h5 id="②-优缺点："><a href="#②-优缺点：" class="headerlink" title="② 优缺点："></a>② 优缺点：</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>优点： 垃圾回收非常及时，引用计数一旦为0立即被回收。<br><span class="hljs-bullet">- </span>缺点： 对象互相引用导致引用计数永远无法为0，不能被回收，造成内存泄漏。<br></code></pre></td></tr></table></figure><h4 id="3-标记清除"><a href="#3-标记清除" class="headerlink" title="(3) 标记清除"></a>(3) 标记清除</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">定时进行标记清除，每次标记清除分为两个阶段：<br><span class="hljs-bullet">- </span>标记阶段：从根对象开始，一层一层地向下访问对象，能访问到的对象，添加一个标记，称之为可到达对象，不能访问到的成为不可到达对象。<br><span class="hljs-bullet">- </span>清除阶段： 遍历内存中所有的对象，如果没有可到达的标记，就被认为是垃圾对象，被回收。<br></code></pre></td></tr></table></figure><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>优点： 不会造成内存泄漏<br><span class="hljs-bullet">- </span>缺点： 需要深层递归，效率较低，垃圾对象不如引用计算算法回收得及时<br></code></pre></td></tr></table></figure><h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2 函数高级"></a>2 函数高级</h2><h3 id="2-1-执行上下文和执行栈"><a href="#2-1-执行上下文和执行栈" class="headerlink" title="2.1 执行上下文和执行栈"></a>2.1 执行上下文和执行栈</h3><h4 id="1-执行上下文"><a href="#1-执行上下文" class="headerlink" title="(1) 执行上下文"></a>(1) 执行上下文</h4><h5 id="①-全局执行上下文"><a href="#①-全局执行上下文" class="headerlink" title="① 全局执行上下文"></a>① 全局执行上下文</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span> 将 <span class="hljs-built_in">window</span> 确定为全局执行上下文对象。<br><span class="hljs-number">2.</span> 对全局作用域下的数据进行预处理：<br>① 所有 <span class="hljs-keyword">var</span> 声明的全局变量，都作为全局执行上下文对象的属性，默认赋值 <span class="hljs-literal">undefined</span>。<br>② 所有 <span class="hljs-keyword">function</span> 关键字形式声明的全局函数，都作为全局执行上下文对象的方法，有值。<br>③ 将 <span class="hljs-built_in">this</span> 的值确定为 <span class="hljs-built_in">window</span>（全局执行上下文对象）<br><span class="hljs-number">3.</span> 执行全局代码。<br></code></pre></td></tr></table></figure><h5 id="②-函数内的执行上下文"><a href="#②-函数内的执行上下文" class="headerlink" title="② 函数内的执行上下文"></a>② 函数内的执行上下文</h5><p>函数每调用一次，就创建新的执行上下文对象。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span> 当函数调用的时候，先创建该函数的执行上下文对象。<br><span class="hljs-number">2.</span> 对函数内的数据进行预处理：<br>① 给形参进行赋值，把形参作为执行上下文对象的属性。<br>② 给 <span class="hljs-built_in">arguments</span> 赋值，把 <span class="hljs-built_in">arguments</span> 作为执行上下文对象的属性。<br>③ 把函数内 <span class="hljs-keyword">var</span> 声明的变量，作为执行山下文对象的属性，值 <span class="hljs-literal">undefined</span>。<br>④ 把函数内 <span class="hljs-keyword">function</span> 关键字形式声明的函数，作为执行上下文对象的方法，有值。<br>⑤ 将 <span class="hljs-built_in">this</span> 的值确定为调用该函数的对象<br><span class="hljs-number">3.</span> 执行函数体内的代码<br></code></pre></td></tr></table></figure><h4 id="2-执行栈"><a href="#2-执行栈" class="headerlink" title="(2) 执行栈"></a>(2) 执行栈</h4><p>执行栈是用来存储执行上下文对象的存储结构，是具有先进后出（后进先出）特性的栈结构。</p><p>把数据放入栈结构的过程称为<strong>压栈</strong>，销毁栈中的某个数据称为<strong>出栈</strong>.</p><p>哪个执行上下文对象先创建，就哪个先压栈。先压栈的往往最后一个出栈。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 代码执行之前，先创建执行栈结构<br><span class="hljs-bullet">2.</span> 当确定了全局执行上下文对象之后，就将全局执行上下文对象压栈，开始执行该上下文对象中的语句。<br><span class="hljs-bullet">3.</span> 当调用某个函数的时候，创建该函数的执行上下文对象，执行上下文对象压栈，执行函数体内语句。<br><span class="hljs-bullet">4.</span> 当函数调用结束，该函数的执行上下文对象出栈<br><span class="hljs-bullet">5.</span> 等到所有的函数执行上下文对象都出栈了，全局执行上下文对象才出栈，意味着整个js脚本执行结束。<br></code></pre></td></tr></table></figure><h4 id="3-作用域和执行上下文的关系"><a href="#3-作用域和执行上下文的关系" class="headerlink" title="(3)  作用域和执行上下文的关系"></a>(3)  作用域和执行上下文的关系</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>区别：作用域是静态的，函数声明的时候就确定了； 执行上下文对象是函数调用的时候动态创建的，没调用一次就创建一次。<br><span class="hljs-bullet">- </span>联系：执行上下文对象也是有作用域的，全局执行上下文对象-&gt;全局作用域； 函数内的执行上下文对象-&gt;本函数。<br><span class="hljs-code">       全局变量都是全局执行上下文对象的属性。</span><br><span class="hljs-code">       局部变量都是该函数执行上下文对象的属性。</span><br></code></pre></td></tr></table></figure><h3 id="2-2-闭包"><a href="#2-2-闭包" class="headerlink" title="2.2 闭包"></a>2.2 闭包</h3><h4 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="(1) 什么是闭包？"></a>(1) 什么是闭包？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">可以访问其他作用域中的数据，这种现象就是闭包<br></code></pre></td></tr></table></figure><h4 id="2-如何产生闭包"><a href="#2-如何产生闭包" class="headerlink" title="(2) 如何产生闭包"></a>(2) 如何产生闭包</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1</span>. 函数 <span class="hljs-keyword">A</span> 中创建函数 B<br><span class="hljs-number">2</span>. 函数 B 中使用函数 <span class="hljs-keyword">A</span> 作用域中的数据<br><span class="hljs-number">3</span>. 在函数 <span class="hljs-keyword">A</span> 中，要把函数 B 返回，或者以其他方式引用（如函数B作为回调函数） （切记：函数B不在函数<span class="hljs-keyword">A</span>中调用）<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">引用函数 B 的方式：<br><span class="hljs-bullet">1.</span> 把函数 B 返回<br><span class="hljs-bullet">2.</span> 函数B被其他变量或属性引用<br><span class="hljs-bullet">3.</span> 函数B作为回调函数（事件或定时器）<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;  <br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>;  <br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span>&#123;  <br>    <span class="hljs-keyword">return</span> a+b;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> B;  <br>&#125;  <br><span class="hljs-keyword">var</span> fn = A(); <span class="hljs-comment">// 返回的是函数B</span><br><br>fn();<br></code></pre></td></tr></table></figure><h4 id="3-闭包和作用域"><a href="#3-闭包和作用域" class="headerlink" title="(3) 闭包和作用域"></a>(3) 闭包和作用域</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>. 调用 <span class="hljs-meta">fn</span>(). <span class="hljs-meta">fn</span> 和 <span class="hljs-keyword">B</span> 都是函数，调用 <span class="hljs-meta">fn</span>， 执行的是函数 <span class="hljs-keyword">B</span> 里的语句<br><span class="hljs-number">2</span>. 函数 <span class="hljs-keyword">B</span> 使用上层作用域的变量 a 和 <span class="hljs-keyword">b</span> （a 和 <span class="hljs-keyword">b</span> 在函数 A 的作用域中）<br><span class="hljs-number">3</span>. 最终现象： 函数 <span class="hljs-meta">fn</span> 中可以使用 函数 A 作用域中的数据<br></code></pre></td></tr></table></figure><blockquote><p>作用域只与函数声明的位置有关系。</p></blockquote><h4 id="4-闭包和垃圾回收"><a href="#4-闭包和垃圾回收" class="headerlink" title="(4) 闭包和垃圾回收"></a>(4) 闭包和垃圾回收</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>. 当函数 A 调用结束之后，函数 A 的局部变量应该被回收。<br><span class="hljs-number">2</span>. 但是变量 <span class="hljs-meta">fn</span> 引用函数 B，函数 <span class="hljs-keyword">B</span> 的语句又引用了 a 和 b，导致函数和两个值都不会被回收<br></code></pre></td></tr></table></figure><blockquote><p>闭包可以延长函数内局部变量的声明周期！</p></blockquote><h4 id="5-闭包的缺点"><a href="#5-闭包的缺点" class="headerlink" title="(5) 闭包的缺点"></a>(5) 闭包的缺点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">闭包会造成数据长时间在内存中，具有内存泄漏的风险！<br><br>闭包注意事项：<br><span class="hljs-bullet">1.</span> 有闭包以外的其他方案解决，就使用其他方案。<br><span class="hljs-bullet">2.</span> 减少引用次数，必要时断开引用（给变量重新赋值）<br></code></pre></td></tr></table></figure><h4 id="6-闭包的应用"><a href="#6-闭包的应用" class="headerlink" title="(6) 闭包的应用"></a>(6) 闭包的应用</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 循环给多个元素监听事件，需要用闭包存储一些数据。<br><span class="hljs-bullet">2.</span> JS 模块化，使用闭包暴露数据<br></code></pre></td></tr></table></figure><h2 id="3-对象高级"><a href="#3-对象高级" class="headerlink" title="3 对象高级"></a>3 对象高级</h2><h3 id="3-1-创建对象的方式"><a href="#3-1-创建对象的方式" class="headerlink" title="3.1 创建对象的方式"></a>3.1 创建对象的方式</h3><h4 id="①-Object-构造函数"><a href="#①-Object-构造函数" class="headerlink" title="① Object 构造函数"></a>① Object 构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><h4 id="②-直接量-字面量方式"><a href="#②-直接量-字面量方式" class="headerlink" title="② 直接量/字面量方式"></a>② 直接量/字面量方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="③-工厂模式"><a href="#③-工厂模式" class="headerlink" title="③ 工厂模式"></a>③ 工厂模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义工厂函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">200</span>) &#123;<br>        age = <span class="hljs-number">200</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        name: name,<br>        age: age<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = factory(<span class="hljs-string">&#x27;朦朦&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">var</span> obj2 = factory(<span class="hljs-string">&#x27;大悲&#x27;</span>, <span class="hljs-number">398</span>);<br></code></pre></td></tr></table></figure><h4 id="④-自定义构造函数"><a href="#④-自定义构造函数" class="headerlink" title="④ 自定义构造函数"></a>④ 自定义构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">new</span> User();<br></code></pre></td></tr></table></figure><h4 id="⑤-自定义构造函数和原型结合"><a href="#⑤-自定义构造函数和原型结合" class="headerlink" title="⑤ 自定义构造函数和原型结合"></a>⑤ 自定义构造函数和原型结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>User.prototype.getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-原型链总结"><a href="#3-2-原型链总结" class="headerlink" title="3.2 原型链总结"></a>3.2 原型链总结</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">__proto__该属性指向自身的原型对象<br>prototype该属性指向实例的原型，（该属性只有构造函数才有）<br><span class="hljs-function"><span class="hljs-keyword">constructor</span>指向以该对象为原型的对象的构造函数</span><br></code></pre></td></tr></table></figure><h3 id="3-3-面向对象继承"><a href="#3-3-面向对象继承" class="headerlink" title="3.3 面向对象继承"></a>3.3 面向对象继承</h3><h4 id="①-面向对象语言的继承规则"><a href="#①-面向对象语言的继承规则" class="headerlink" title="① 面向对象语言的继承规则"></a>① 面向对象语言的继承规则</h4><p>一般，面向对象语言继承都是 类和类之间继承。</p><h4 id="②-JS-中继承关系的特点"><a href="#②-JS-中继承关系的特点" class="headerlink" title="② JS 中继承关系的特点"></a>② JS 中继承关系的特点</h4><p>JS中，继承是通过原型链继承，继承发生在对象（实例）和对象（实例）之间。</p><p><code>instanceof</code> 判断一个对象是否是某个构造函数的实例； 第二个操作写一个构造函数，该构造函数是第一个操作数的构造函数或者第一个操作数原型链上的某个对象的构造函数，都成立，返回 <code>true</code></p><h4 id="③-实现JS中构造函数和构造函数之间继承"><a href="#③-实现JS中构造函数和构造函数之间继承" class="headerlink" title="③ 实现JS中构造函数和构造函数之间继承"></a>③ 实现JS中构造函数和构造函数之间继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Girl</span>(<span class="hljs-params">name, age, address</span>) </span>&#123;<br>    <span class="hljs-comment">// 给从父类继承过来的属性赋值</span><br>    Person.call(<span class="hljs-built_in">this</span>, name, age);<br>    <span class="hljs-comment">// 给自身实例的属性赋值</span><br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br><span class="hljs-comment">// 设置 Gril 的实例的原型是 Person 的实例</span><br>Girl.prototype = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// 设置 Girl 的实例的原型上 constructor 属性，指向 Girl</span><br>Girl.prototype.constructor = Girl;<br><br><br><span class="hljs-comment">// 创建 Girl 的实例</span><br><span class="hljs-keyword">var</span> g = <span class="hljs-keyword">new</span> Girl();<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">对象 g 的原型链：<br><br>对象g -&gt; Girl.protype<span class="hljs-function"><span class="hljs-params">(Person的实例)</span> -&gt;</span> Person.protype<span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">Object</span>的实例)</span> -&gt;</span> <span class="hljs-built_in">Object</span>.protype<br></code></pre></td></tr></table></figure><h3 id="3-4-对象属性的高级特性"><a href="#3-4-对象属性的高级特性" class="headerlink" title="3.4 对象属性的高级特性"></a>3.4 对象属性的高级特性</h3><h4 id="①-数据属性"><a href="#①-数据属性" class="headerlink" title="① 数据属性"></a>① 数据属性</h4><p>数据属性具有如下 4 个特性：</p><p><strong>configurable</strong>  可配置性，决定是否可以用 <code>delete</code> 运算符删除该属性， 默认是 true。</p><p><strong>enumerable</strong> 可遍历性，决定是否可以用 <code>for in</code> 遍历出该属性，默认是 true。</p><p><strong>writeable</strong> 可写性，决定是否可以修改该属性的值。</p><p><strong>value</strong>  值，存放该属性的值。</p><h4 id="②-访问器属性"><a href="#②-访问器属性" class="headerlink" title="② 访问器属性"></a>② 访问器属性</h4><p>访问器属性是不具备数据值的属性，设置属性和访问属性会调用 set 和 get 两个函数，访问器属性具有如下特性：</p><p><strong>configurable</strong>  可配置性，决定是否可以用 <code>delete</code> 运算符删除该属性， 默认是 true。</p><p><strong>enumerable</strong> 可遍历性，决定是否可以用 <code>for in</code> 遍历出该属性，默认是 true。</p><p><strong>get</strong>: 访问该属性时调用的函数，该函数的返回值就是属性值。</p><p><strong>set</strong>: 给该属性设置值的时候调用的函数，可以接受新设置的值作为参数。</p><h4 id="③-设置属性的特性"><a href="#③-设置属性的特性" class="headerlink" title="③ 设置属性的特性"></a>③ 设置属性的特性</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">Object.<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ineProperty</span><span class="hljs-params">(对象, 属性名, &#123;&#125;)</span></span><br>Object.<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ineProperties</span><span class="hljs-params">(对象, &#123;&#125;)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置数据属性的特性</span><br><span class="hljs-comment">// 如果属性已经存在就修改该属性特性；如果属性不存在就添加新属性</span><br><span class="hljs-built_in">Object</span>.definedProperty(对象, 属性名, &#123;<br>    configurable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    writeable: <span class="hljs-literal">true</span>,<br>    value: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 给 obj 添加一个访问器属性</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;<br>    configurable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._age;<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span> &amp;&amp; value &lt;= <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-built_in">this</span>._age = value;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 同时设置多个属性的特性</span><br><span class="hljs-comment">// 添加属性并设置特性</span><br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>    name: &#123;<br>        configurable: <span class="hljs-literal">true</span>,<br>        enumerable: <span class="hljs-literal">false</span>,<br>        writable: <span class="hljs-literal">true</span>,<br>        value: <span class="hljs-string">&#x27;朦朦&#x27;</span><br>    &#125;,<br>    age: &#123;<br>        value: <span class="hljs-number">100</span><br>    &#125;,<br>    address: &#123;<br>        configurable: <span class="hljs-literal">false</span>,<br>        enumerable: <span class="hljs-literal">false</span>,<br>        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        &#125;,<br>        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="④-获取对象中一个属性的特性"><a href="#④-获取对象中一个属性的特性" class="headerlink" title="④ 获取对象中一个属性的特性"></a>④ 获取对象中一个属性的特性</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptor(对象, &#x27;属性名&#x27;)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-安全的类型检测"><a href="#3-5-安全的类型检测" class="headerlink" title="3.5 安全的类型检测"></a>3.5 安全的类型检测</h3><h4 id="①-typeof"><a href="#①-typeof" class="headerlink" title="① typeof"></a>① typeof</h4><p>只能查看 number、string、boolean、function，其他都返回 object</p><h4 id="②-instanceof"><a href="#②-instanceof" class="headerlink" title="② instanceof"></a>② instanceof</h4><p>可以判断一个对象是否是某个构造函数的实例； </p><p>对象自己的构造函数返回 true，原型链上的对象的构造函数也会返回 true。</p><h4 id="③-对象的-constructor-属性"><a href="#③-对象的-constructor-属性" class="headerlink" title="③ 对象的 constructor 属性"></a>③ 对象的 constructor 属性</h4><p>有些对象可以通过该属性返回自己的构造函数。</p><p>但是，作为其他对象原型的对象， 返回的是以他为原型的那个对象的构造函数。</p><h4 id="④-安全的类型检测"><a href="#④-安全的类型检测" class="headerlink" title="④ 安全的类型检测"></a>④ 安全的类型检测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装获取对象类型的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSafeType</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> typeStr = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj)<br>    <span class="hljs-keyword">return</span> typeStr.slice(<span class="hljs-number">8</span>, typeStr.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-单线程和事件轮询机制"><a href="#4-单线程和事件轮询机制" class="headerlink" title="4 单线程和事件轮询机制"></a>4 单线程和事件轮询机制</h2><h3 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4.1 进程和线程"></a>4.1 进程和线程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 什么是进程？<br>系统进行资源调度和分配的基本单位。<br><br><span class="hljs-bullet">2.</span> 什么是线程？<br>系统进行运算的最小调度单位，是进程的实际运作单位。<br><br><br><span class="hljs-bullet">3.</span> 进程和线程：<br><span class="hljs-bullet">-</span> 一个进程中至少有一个线程，称为主线程。<br><span class="hljs-bullet">-</span> 一个进程可以有多个线程，多线程运行。<br><span class="hljs-bullet">-</span> 同一个进程中线程，可以共享数据。<br><span class="hljs-bullet">-</span> 不同进程之间是不能资源共享。<br></code></pre></td></tr></table></figure><h3 id="4-2-JS-单线程运行"><a href="#4-2-JS-单线程运行" class="headerlink" title="4.2 JS 单线程运行"></a>4.2 JS 单线程运行</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">为什么 <span class="hljs-keyword">JS </span>选择单线程运行？<br><span class="hljs-keyword">JS </span>设计之初，主要作用就是操作 DOM 完成页面效果，如果是多线程执行无法解决页面渲染同步问题、<br></code></pre></td></tr></table></figure><h3 id="4-3-同步代码和异步代码"><a href="#4-3-同步代码和异步代码" class="headerlink" title="4.3 同步代码和异步代码"></a>4.3 同步代码和异步代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">同步代码：<br>也叫同步任务，安装顺序依次执行，后面的代码需等到前面代码执行完毕才执行<br><br>异步代码：<br>也叫异步任务，当开始异步任务之后，会监听异步代码的满足条件，不影响同步代码继续执行；但异步任务满足条件且同步代码都执行完毕，异步代码才行。<br><br>哪些是异步代码？<br><span class="hljs-bullet">1.</span> 定时器的回调函数<br><span class="hljs-bullet">2.</span> DOM 事件的回调函数<br><span class="hljs-bullet">3.</span> Ajax 的回调函数<br><span class="hljs-bullet">4.</span> Promise 的回调函数<br><br></code></pre></td></tr></table></figure><h3 id="4-4-事件轮询机制"><a href="#4-4-事件轮询机制" class="headerlink" title="4.4 事件轮询机制"></a>4.4 事件轮询机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">执行栈（调用栈）： 所有代码要执行必须进入执行栈。<br><br>管理模块： 包括定时器的管理模块、DOM事件的管理模块、Ajax的管理模块等， 检测异步任务什么时候满足条件（定时器事件到、事件触发、ajax获取响应），满足条件之后，将回调函数放入回调队列。<br><br>回调队列： 队列是一种先进先出的数据结构，回调队列用于存放待执行的回调函数。<br><br>事件轮询模块： 负责检测执行栈什么时候空闲，一旦有空闲，就取出回调队列中最前面的回调函数，放入执行栈执行，<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript BOM&amp;DOM</title>
    <link href="/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-BOM&amp;DOM/"/>
    <url>/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-BOM&amp;DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-BOM-amp-DOM"><a href="#JavaScript-BOM-amp-DOM" class="headerlink" title="JavaScript BOM&amp;DOM"></a>JavaScript BOM&amp;DOM</h1><h2 id="1-BOM"><a href="#1-BOM" class="headerlink" title="1 BOM"></a>1 BOM</h2><h3 id="1-1-BOM-的概念"><a href="#1-1-BOM-的概念" class="headerlink" title="1.1 BOM 的概念"></a>1.1 BOM 的概念</h3><h4 id="1-什么是-BOM"><a href="#1-什么是-BOM" class="headerlink" title="(1) 什么是 BOM"></a>(1) 什么是 BOM</h4><p>BOM 全称 Browser Object Model，译为浏览器对象模型。</p><p>BOM 是浏览器为 JavaScript 提供的能够对浏览器进行相关操作的 API。</p><h4 id="2-BOM-的作用"><a href="#2-BOM-的作用" class="headerlink" title="(2) BOM 的作用"></a>(2) BOM 的作用</h4><p>1）弹出新浏览器窗口的能力。</p><p>2）移动、关闭和更改浏览器窗口大小的能力。</p><p>3）可提供WEB浏览器详细信息的导航对象。</p><p>4）可提供浏览器载入页面详细信息的本地对象。</p><p>5）可提供用户屏幕分辨率详细信息的屏幕对象；</p><p>6）支持Cookies。</p><h4 id="3-BOM-对象"><a href="#3-BOM-对象" class="headerlink" title="(3) BOM 对象"></a>(3) BOM 对象</h4><p>浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构，一共有 5 个对象：</p><p>1）window</p><p>2）location</p><p>3）history</p><p>4）navigator</p><p>5）screen</p><h3 id="1-2-window"><a href="#1-2-window" class="headerlink" title="1.2 window"></a>1.2 window</h3><h4 id="①-弹框"><a href="#①-弹框" class="headerlink" title="① 弹框"></a>① 弹框</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">alert（）   警告框<br><span class="hljs-function"><span class="hljs-title">confirm</span><span class="hljs-params">()</span></span>确认框，返回布尔值<br><span class="hljs-function"><span class="hljs-title">prompt</span><span class="hljs-params">()</span></span>输入框，返回用户输入的内容<br></code></pre></td></tr></table></figure><h4 id="②-打开新窗口"><a href="#②-打开新窗口" class="headerlink" title="② 打开新窗口"></a>② 打开新窗口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 打开新的空白页面窗口</span><br><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 在新窗口打开指定的页面</span><br><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>);<br><br><span class="hljs-comment">// 在指定的窗口打开页面</span><br><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;窗口的名字&#x27;</span>);<br><br><span class="hljs-comment">// 打开新窗口并指定窗口大小</span><br><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;./01-window的属性.html&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;width=400,height=300&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="③-页面滚动"><a href="#③-页面滚动" class="headerlink" title="③ 页面滚动"></a>③ 页面滚动</h4><p>滚动到页面中的某个坐标:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.scrollTo( <span class="hljs-number">0</span>, <span class="hljs-number">1000</span> );<br><br><span class="hljs-comment">// 设置滚动行为改为平滑的滚动</span><br><span class="hljs-built_in">window</span>.scrollTo(&#123; <br>    top: <span class="hljs-number">1000</span>, <br>    behavior: <span class="hljs-string">&quot;smooth&quot;</span> <br>&#125;);<br></code></pre></td></tr></table></figure><p>在窗口中按指定的偏移量滚动文档:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向下滚动一页：</span><br><span class="hljs-built_in">window</span>.scrollBy(<span class="hljs-number">0</span>, <span class="hljs-built_in">window</span>.innerHeight);<br><br><span class="hljs-comment">// 向上滚动一页：</span><br><span class="hljs-built_in">window</span>.scrollBy(<span class="hljs-number">0</span>, -<span class="hljs-built_in">window</span>.innerHeight);<br><br><span class="hljs-comment">// 平滑滚动</span><br><span class="hljs-built_in">window</span>.scrollBy(&#123;   <br>  top: <span class="hljs-number">100</span>,<br>  left: <span class="hljs-number">100</span>,   <br>  behavior: <span class="hljs-string">&quot;smooth&quot;</span> <br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="④-定时器"><a href="#④-定时器" class="headerlink" title="④ 定时器"></a>④ 定时器</h4><p><strong>多次定时：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 开启定时器 第一个参数可以是字符串，字符串中写代码</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello world&quot;)&#x27;</span>, <span class="hljs-number">2000</span>);<br><br><span class="hljs-comment">// 开启定时器，第一个参数是回调函数,第二个参数间隔时间，单位是毫秒</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <br>&#125;, <span class="hljs-number">2000</span>);<br><br><span class="hljs-comment">// 开启定时器，回调函数可以有形参。</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>    <br>&#125;, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;朦朦&#x27;</span>);<br><br><span class="hljs-comment">// setInterval 的返回值就是该定时器的唯一标识</span><br><span class="hljs-comment">// 取消定时器 需要指定定时器唯一标识</span><br><span class="hljs-built_in">clearInterval</span>(定时器ID)<br><br></code></pre></td></tr></table></figure><p><strong>单次定时：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 开启单次定时 setTimeout 与 setInterval 的语法一模一样</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// 清除单次定时器</span><br><span class="hljs-built_in">clearTimeout</span>(单次定时器ID);<br></code></pre></td></tr></table></figure><h4 id="⑤-window-对象属性和方法总结"><a href="#⑤-window-对象属性和方法总结" class="headerlink" title="⑤ window 对象属性和方法总结"></a>⑤ window 对象属性和方法总结</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs isbl">属性：<br><span class="hljs-variable">name</span>当前的窗口的名字，可读可写<br><span class="hljs-variable">innerWidth</span>视口宽度，只读<br><span class="hljs-variable">innerHeight</span>视口高度，只读<br><span class="hljs-variable">document</span><br><span class="hljs-variable">location</span><br><span class="hljs-variable">history</span><br><span class="hljs-variable">screen</span><br><span class="hljs-variable">navigator</span><br><br><br>方法：<br><span class="hljs-function"><span class="hljs-title">alert</span>()警告框</span><br><span class="hljs-function"><span class="hljs-title">confirm</span>()确认框</span><br><span class="hljs-function"><span class="hljs-title">prompt</span>()输入框</span><br><span class="hljs-function"><span class="hljs-title">open</span>()打开新窗口</span><br><span class="hljs-function"><span class="hljs-title">close</span>()关闭窗口（窗口必须是被 <span class="hljs-variable">open</span> 打开的）</span><br><span class="hljs-function"><span class="hljs-title">print</span>()开启打印预览</span><br><span class="hljs-function"><span class="hljs-title">scrollTo</span>()滚动到页面指定位置</span><br><span class="hljs-function"><span class="hljs-title">scrollBy</span>()滚动一定的距离</span><br><span class="hljs-function"><span class="hljs-title">setInterval</span>()开启多次定时器</span><br><span class="hljs-function"><span class="hljs-title">clearInterval</span>()清除多次定时器</span><br><span class="hljs-function"><span class="hljs-title">setTimeout</span>()开启单次定时器</span><br><span class="hljs-function"><span class="hljs-title">clearTimeout</span>()清除单次定时器</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h3 id="1-3-history"><a href="#1-3-history" class="headerlink" title="1.3 history"></a>1.3 history</h3><p>history 用于描述<strong>本窗口</strong>的历史记录。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">属性：<br>length获取本窗口历史记录的个数<br><br>方法：<br>back()跳转到历史记录中的上一个页面<br>forward()跳转到历史记录中的下一个页面<br>go()跳转到历史记录中的上<span class="hljs-built_in">n</span>个或下<span class="hljs-built_in">n</span>个页面，指定数字作为参数，正数下<span class="hljs-built_in">n</span>个，负数上<span class="hljs-built_in">n</span>个<br></code></pre></td></tr></table></figure><h3 id="1-4-location"><a href="#1-4-location" class="headerlink" title="1.4 location"></a>1.4 location</h3><p>location 对象用于描述当前页面的地址信息</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elm">属性：（可读可写）<br>href完整的地址<br>protocol协议部分<br>host主机名+端口号<br>hostname主机名部分<br><span class="hljs-keyword">port</span>端口号部分<br>pathname路径部分<br>hash锚点部分<br>search查询部分<br><br>方法：<br>reload()重新加载<br>assign()页面跳转，保留历史记录<br>replace()页面跳转，原网页不在历史记录保留<br></code></pre></td></tr></table></figure><h3 id="1-5-navigator"><a href="#1-5-navigator" class="headerlink" title="1.5 navigator"></a>1.5 navigator</h3><p>navigator 对象用于描述浏览器以及系统的信息。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">属性：<br><span class="hljs-keyword">user</span>Agent获取浏览器信息<br></code></pre></td></tr></table></figure><h3 id="1-6-screen"><a href="#1-6-screen" class="headerlink" title="1.6 screen"></a>1.6 screen</h3><p>screen 对象用于描述屏幕信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">属性：<br><span class="hljs-built_in">width</span>屏幕的宽度<br><span class="hljs-built_in">height</span>屏幕的高度<br></code></pre></td></tr></table></figure><h2 id="2-DOM-操作"><a href="#2-DOM-操作" class="headerlink" title="2 DOM 操作"></a>2 DOM 操作</h2><h3 id="2-1-DOM-介绍"><a href="#2-1-DOM-介绍" class="headerlink" title="2.1 DOM 介绍"></a>2.1 DOM 介绍</h3><p><strong><font color="red">MDN 文档对象模型手册</font>：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model</a></p><h3 id="2-2-Node-节点"><a href="#2-2-Node-节点" class="headerlink" title="2.2 Node 节点"></a>2.2 Node 节点</h3><h4 id="1-五大节点类型"><a href="#1-五大节点类型" class="headerlink" title="(1) 五大节点类型"></a>(1) 五大节点类型</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">元素节点 <span class="hljs-keyword">element</span><br>属性节点 <span class="hljs-keyword">attribute</span><br>文本节点text<br>注释节点<span class="hljs-keyword">comment</span><br>文档节点<span class="hljs-keyword">document</span><br></code></pre></td></tr></table></figure><h4 id="2-节点的属性"><a href="#2-节点的属性" class="headerlink" title="(2) 节点的属性"></a>(2) 节点的属性</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">nodeName节点名，元素节点的节点名是标签名。<br>nodeValue节点值。<br>nodeType节点类型。 <br>元素：<span class="hljs-number">1</span>，属性：<span class="hljs-number">2</span>，文本：<span class="hljs-number">3</span>，注释：<span class="hljs-number">8</span>，<span class="hljs-built_in">document</span>：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="2-3-获取元素"><a href="#2-3-获取元素" class="headerlink" title="2.3 获取元素"></a>2.3 获取元素</h3><h4 id="①-通过-ID-名"><a href="#①-通过-ID-名" class="headerlink" title="① 通过 ID 名"></a>① 通过 ID 名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ID名&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>返回对应的元素对象，如果没有找到该 ID 名的元素，返回 <code>null</code></p></blockquote><h4 id="②-通过标签名"><a href="#②-通过标签名" class="headerlink" title="② 通过标签名"></a>② 通过标签名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// document 的方法，从document的后代中查找(整个文档)</span><br><span class="hljs-built_in">document</span>.getElementsByTagName()<br><br><span class="hljs-comment">// 元素对象的方法，从指定元素的后代中查找</span><br>element.getElementsByTagName()<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>getElementsByTagName() 方法返回一个 HTMLCollection 对象，里面是所有满足条件的元素的集合，是个伪数组。</p><p>如果没有满足条件的元素，返回空的 HTMLCollection 对象。</p></blockquote><h4 id="③-通过类名（了解，IE8-支持）"><a href="#③-通过类名（了解，IE8-支持）" class="headerlink" title="③ 通过类名（了解，IE8 + 支持）"></a>③ 通过类名（了解，IE8 + 支持）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// document 的方法，从document的后代中查找(整个文档)</span><br><span class="hljs-built_in">document</span>.getElementsByClassName()<br><br><span class="hljs-comment">// 元素对象的方法，从指定元素的后代中查找</span><br>element.getElementsByClassName()<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>getElementsByClassName() 方法返回一个 HTMLCollection 对象，里面是所有满足条件的元素的集合，是个伪数组。</p><p>如果没有满足条件的元素，返回空的 HTMLCollection 对象。</p></blockquote><h4 id="④-通过-name-属性值-（了解）"><a href="#④-通过-name-属性值-（了解）" class="headerlink" title="④ 通过 name 属性值 （了解）"></a>④ 通过 name 属性值 （了解）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&#x27;name值&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>返回一个 NodeList 对象，与 HTMLCollection 类似，也是伪数组，也是由满足条件的元素组成。</p></blockquote><h4 id="⑤-通过选择器获取元素-推荐"><a href="#⑤-通过选择器获取元素-推荐" class="headerlink" title="⑤ 通过选择器获取元素 (推荐)"></a>⑤ 通过选择器获取元素 (推荐)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 从整个文档中获取</span><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;css 选择器&#x27;</span>);<span class="hljs-comment">// 返回一个元素； 如果满足选择器条件的元素有多个，只返回第一个元素；如果没有满足条件的元素，返回 null。</span><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;css 选择器&#x27;</span>);  <span class="hljs-comment">// 返回一个 NodeList 对象，是一个右所有满足条件的元素组成的集合，是个伪数组。</span><br><br><span class="hljs-comment">// 从某个元素的后代中获取</span><br>element.querySelector(<span class="hljs-string">&#x27;css 选择器&#x27;</span>);<br>element.querySelectorAll(<span class="hljs-string">&#x27;css 选择器&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="⑥-获取所有的元素"><a href="#⑥-获取所有的元素" class="headerlink" title="⑥ 获取所有的元素"></a>⑥ 获取所有的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.all<br></code></pre></td></tr></table></figure><blockquote><p>document.all 是一个语法糖，可以用来判断浏览器是 IE 还是 非IE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.all) &#123;<br>  <span class="hljs-comment">// IE10 以及以下</span><br>  alert(<span class="hljs-string">&#x27;啊，我是IE浏览器&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// chrome firefox safari opera Edge IE11</span><br>  alert(<span class="hljs-string">&#x27;嘿嘿，我不是IE浏览器！&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-4-文档结构（元素关系）"><a href="#2-4-文档结构（元素关系）" class="headerlink" title="2.4 文档结构（元素关系）"></a>2.4 文档结构（元素关系）</h3><h4 id="1-节点树"><a href="#1-节点树" class="headerlink" title="(1) 节点树"></a>(1) 节点树</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">parentNode</span>返回父节点<br><br>firstChild第一个子节点<br><span class="hljs-literal">last</span>Child最后一个子节点<br>childNodes所有子节点组成的集合（NodeList 对象）<br><br>nextSibling紧邻在后面的兄弟节点<br>previousSibling紧邻在前面的兄弟节点<br></code></pre></td></tr></table></figure><h4 id="2-元素树"><a href="#2-元素树" class="headerlink" title="(2) 元素树"></a>(2) 元素树</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">parentElement</span>返回父元素<br><br>firstElementChild第一个子元素<br><span class="hljs-literal">last</span>ElementChild最后一个子元素<br>children所有子元素组成的集合（HTMLCollection 对象）<br><br>nextElementSibling紧邻在后面的兄弟元素<br>previousElementSibling紧邻在前面的兄弟元素<br></code></pre></td></tr></table></figure><blockquote><p>所有的元素，除了 html 元素，父节点和父元素是一样的； html 元素没有父元素，但是父节点是 document</p></blockquote><h3 id="2-5-属性操作"><a href="#2-5-属性操作" class="headerlink" title="2.5 属性操作"></a>2.5 属性操作</h3><h4 id="1-读写内置属性"><a href="#1-读写内置属性" class="headerlink" title="(1) 读写内置属性"></a>(1) 读写内置属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.属性名;<br>element[<span class="hljs-string">&#x27;属性名&#x27;</span>];<br></code></pre></td></tr></table></figure><h4 id="2-读写自定义属性"><a href="#2-读写自定义属性" class="headerlink" title="(2) 读写自定义属性"></a>(2) 读写自定义属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 读取属性的值</span><br>element.getAttribute(<span class="hljs-string">&#x27;属性名&#x27;</span>);<br><br><span class="hljs-comment">// 设置属性的值</span><br>element.setAttribute(<span class="hljs-string">&#x27;属性名&#x27;</span>, <span class="hljs-string">&#x27;值&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>该方法不分属性是内置的还是自定义的，只要写在元素上的就可以操作！</p></blockquote><h4 id="3-data-形式的自定义属性"><a href="#3-data-形式的自定义属性" class="headerlink" title="(3) data-* 形式的自定义属性"></a>(3) <code>data-*</code> 形式的自定义属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">data-spm-age</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 读写属性</span><br>divBox.dataset.name;<br>divBox.dataset.spmAge;<br></code></pre></td></tr></table></figure><h3 id="2-6-样式操作"><a href="#2-6-样式操作" class="headerlink" title="2.6 样式操作"></a>2.6 样式操作</h3><h4 id="1-操作行内样式"><a href="#1-操作行内样式" class="headerlink" title="(1) 操作行内样式"></a>(1) 操作行内样式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置样式</span><br>ele.style.width = <span class="hljs-string">&#x27;100px&#x27;</span>;  <span class="hljs-comment">// 带单位</span><br>ele.style.backgroundColor = <span class="hljs-string">&#x27;#f90&#x27;</span>;  <span class="hljs-comment">// 带 - 的css属性名自动转为小驼峰</span><br>ele.style[<span class="hljs-string">&#x27;background-color&#x27;</span>] = <span class="hljs-string">&#x27;red&#x27;</span>;  <span class="hljs-comment">// 带 - 的css属性，可以使用 []</span><br><br><span class="hljs-comment">// 获取样式</span><br>ele.style.height;<br>ele.style.backgroundColor;<br>ele.style[<span class="hljs-string">&#x27;border-width&#x27;</span>];<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li><code>.style</code> 方式设置的样式，设置在行内。</li><li><code>.style</code> 方式获取元素某个样式，只能获取设置在行内的样式，其他地方的样式得到空字符串。</li></ol></blockquote><h4 id="2-读取计算样式"><a href="#2-读取计算样式" class="headerlink" title="(2) 读取计算样式"></a>(2) 读取计算样式</h4><p>所谓计算样式，指的是所有作用在元素上的样式，不论是设置到哪里； 哪怕没有设置该样式，还可以得到默认值。 元素的计算样式是<strong>只读的</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非 IE （包括 IE11 和 Edge）</span><br><span class="hljs-built_in">window</span>.getComputedStyle(元素).属性名<br><br><span class="hljs-comment">// IE 浏览器</span><br>元素.currentStyle.属性名<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 兼容性得获取元素的计算样式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>element  HTML 元素对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>attrName string   css的属性名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>css属性值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">ele, attrName</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.getComputedStyle) &#123;<br>        <span class="hljs-comment">// 非IE浏览器（包括IE11 和 EDGE）</span><br>        <span class="hljs-keyword">return</span> getComputedStyle(ele)[attrName];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ele.currentStyle) &#123;<br>        <span class="hljs-comment">// IE 浏览器</span><br>        <span class="hljs-keyword">return</span> ele.currentStyle[attrName];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-通过类名操作"><a href="#3-通过类名操作" class="headerlink" title="(3) 通过类名操作"></a>(3) 通过类名操作</h4><h4 id="①-className"><a href="#①-className" class="headerlink" title="① className"></a>① className</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ele.className;  <span class="hljs-comment">// 可读可写</span><br></code></pre></td></tr></table></figure><h4 id="②-classList"><a href="#②-classList" class="headerlink" title="② classList"></a>② classList</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">ele.classList.add(<span class="hljs-string">&#x27;类名&#x27;</span>);<span class="hljs-comment">// 在原有类型的基础上添加类名</span><br>ele.classList.remove(<span class="hljs-string">&#x27;类名&#x27;</span>);<span class="hljs-comment">// 移除指定的类名，其他类名不受影响</span><br>ele.classList.toggle(<span class="hljs-string">&#x27;类名&#x27;</span>);<span class="hljs-comment">// 如果存在类名就移除，如果没有类名就添加</span><br>ele.classList.length; <span class="hljs-comment">// 属性，表示元素类名的个数</span><br></code></pre></td></tr></table></figure><blockquote><p>元素的 classList 属性可以得到一个对象，有类名组成的伪数组。</p></blockquote><h3 id="2-7-元素的文本内容（可读可写）"><a href="#2-7-元素的文本内容（可读可写）" class="headerlink" title="2.7 元素的文本内容（可读可写）"></a>2.7 元素的文本内容（可读可写）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ele<span class="hljs-selector-class">.innerHTML</span>读取或设置元素中的 <span class="hljs-selector-tag">html</span> 内容（读取：标签代码能够读取到；设置:标签代码能被解析）<br>ele<span class="hljs-selector-class">.outerHTML</span>相对于 innerHTML，读写的时候包括自己在内的 <span class="hljs-selector-tag">html</span> 代码。<br>ele<span class="hljs-selector-class">.innerText</span>读取元素中的文字内容（读取：标签代码被去掉；设置：标签代码变为实体）<br>ele<span class="hljs-selector-class">.textContent</span>与innerText类似，保留内容中的缩进格式。<br></code></pre></td></tr></table></figure><h3 id="2-8-元素的尺寸位置（只读）"><a href="#2-8-元素的尺寸位置（只读）" class="headerlink" title="2.8 元素的尺寸位置（只读）"></a>2.8 元素的尺寸位置（只读）</h3><h4 id="1-元素的尺寸"><a href="#1-元素的尺寸" class="headerlink" title="(1)元素的尺寸"></a>(1)元素的尺寸</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">offsetWidth获取元素的宽度（内容宽+左右内边距+左右边框宽度）<br>offsetHeight获取元素的高度（内容高+上下内边距+上下边框宽度）<br><br>clientWidth获取宽度（内容宽+左右内边距)<br>clientHeight获取高度（内容高+上下内边距)<br><br>scrollWidth在 clientWidth 的基础上添加溢出内容的宽度<br>scrollHeight在 clientHeight 的基础上添加溢出内容的高度<br><br><span class="hljs-function"><span class="hljs-title">getBoundingClientRect</span><span class="hljs-params">()</span></span>返回一个对象，对象中有 <span class="hljs-attribute">width</span> 属性和 height 属性，分别获取元素的宽高（同 offsetWidth 和 offsetHeight 一致）<br></code></pre></td></tr></table></figure><blockquote><p><strong>快速获取 html 元素和 body 元素的方式：</strong></p><p><code>document.documentElement</code>    可以得到 html 根元素。</p><p><code>document.body</code> 可以得到 body 元素。</p></blockquote><blockquote><p><strong>获取视口的宽高：</strong></p><p><code>window.innerWidth</code> 和 <code>window.innerHeight</code>, 会算上滚动条自身的大小。</p><p><code>document.documentElement.clientWidth</code> 和 <code>document.documentElement.clientHeight</code> </p></blockquote><h4 id="2-元素的位置-（只读）"><a href="#2-元素的位置-（只读）" class="headerlink" title="(2) 元素的位置 （只读）"></a>(2) 元素的位置 （只读）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">offsetLeft获取元素在第一个定位的祖先元素上的 x 坐标； 如果祖先元素没有定位，参考根元素<br>offsetTop获取元素在第一个定位的祖先元素山的 y 坐标； 如果祖先元素没有定位，参考根元素<br><br>clientLeft元素左边框的宽度<br>clientTop元素上边框的宽度<br><br><span class="hljs-function"><span class="hljs-title">getBoundingClientRect</span><span class="hljs-params">()</span></span>返回对象，对象中具有如下属性<br><span class="hljs-attribute">left</span>:元素在视口上的 x 坐标<br><span class="hljs-attribute">top</span>:    元素在视口上的 y 坐标<br>x:同 <span class="hljs-attribute">left</span><br>y:同 <span class="hljs-attribute">top</span><br><span class="hljs-attribute">right</span>:元素右下角在视口上的 x 坐标<br><span class="hljs-attribute">bottom</span>: 元素右下角在视口上的 y 坐标<br></code></pre></td></tr></table></figure><h4 id="3-内容的位置（可读可写）"><a href="#3-内容的位置（可读可写）" class="headerlink" title="(3) 内容的位置（可读可写）"></a>(3) 内容的位置（可读可写）</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scrollLeft</span>内容向左偏移的距离<br><span class="hljs-keyword">scrollTop</span>内容向上偏移的距离<br></code></pre></td></tr></table></figure><blockquote><p><strong>内容可以滚动的生效前提：</strong> 元素的 <code>overflow</code> 属性的值不是 <code>visible</code>。 </p></blockquote><h3 id="2-9-节点（元素）的创建添加删除替换克隆"><a href="#2-9-节点（元素）的创建添加删除替换克隆" class="headerlink" title="2.9 节点（元素）的创建添加删除替换克隆"></a>2.9 节点（元素）的创建添加删除替换克隆</h3><h4 id="1-创建元素节点"><a href="#1-创建元素节点" class="headerlink" title="(1) 创建元素节点"></a>(1) 创建元素节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.crateElement(<span class="hljs-string">&#x27;标签名&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>方法返回创建好的元素对象； 新创建的元素不会出现在文档结构中。</p></blockquote><h4 id="2-添加子节点"><a href="#2-添加子节点" class="headerlink" title="(2) 添加子节点"></a>(2) 添加子节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElement.appendChild(新节点);<span class="hljs-comment">// 新节点会作为父元素的最后一个节点</span><br>parentElement.insertBefore(新节点，旧节点);<span class="hljs-comment">// 指定位置添加子节点；新节点出现在旧节点的前面</span><br></code></pre></td></tr></table></figure><h4 id="3-删除子节点"><a href="#3-删除子节点" class="headerlink" title="(3) 删除子节点"></a>(3) 删除子节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElement.removeChild(要删除的节点)；<span class="hljs-comment">// 删除指定的子节点</span><br></code></pre></td></tr></table></figure><h4 id="4-替换子节点"><a href="#4-替换子节点" class="headerlink" title="(4) 替换子节点"></a>(4) 替换子节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElement.replaceChild(新节点，旧节点);<br></code></pre></td></tr></table></figure><h4 id="5-节点克隆"><a href="#5-节点克隆" class="headerlink" title="(5) 节点克隆"></a>(5) 节点克隆</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ele.cloneNode(<span class="hljs-literal">true</span>);<span class="hljs-comment">// 返回元素的克隆版, 参数指定为 true，连同元素的内容以及后代一起克隆；默认是 false，只克隆元素本身不包括内容和后代</span><br></code></pre></td></tr></table></figure><h3 id="2-10-documnt-对象"><a href="#2-10-documnt-对象" class="headerlink" title="2.10 documnt 对象"></a>2.10 documnt 对象</h3><p>document 对象表示整个文档，不是元素，是节点； document 是 html 根元素的父节点。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">属性：<br>lastModified代码最后一次修改时间（只读）<br>title页面标题（可读可写）<br>documentElement获取 <span class="hljs-selector-tag">html</span> 根元素（只读）<br><span class="hljs-selector-tag">body</span>获取 <span class="hljs-selector-tag">body</span> 元素（只读）<br>head获取 head 元素（只读）<br>all获取所有元素的集合，返回 HTMLCollection 对象。（只读）<br><br>方法：<br><span class="hljs-function"><span class="hljs-title">write</span><span class="hljs-params">()</span></span>将内容写入文档流<br></code></pre></td></tr></table></figure><h3 id="2-11-documentFragment-对象"><a href="#2-11-documentFragment-对象" class="headerlink" title="2.11 documentFragment 对象"></a>2.11 documentFragment 对象</h3><h4 id="1-创建-documentFragment-对象"><a href="#1-创建-documentFragment-对象" class="headerlink" title="(1) 创建 documentFragment 对象"></a>(1) 创建 documentFragment 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.createDocumentFrament();  <span class="hljs-comment">// 该方法返回一个新创建的 documentFragment 对象</span><br></code></pre></td></tr></table></figure><h4 id="2-documentFragment-对象的特点"><a href="#2-documentFragment-对象的特点" class="headerlink" title="(2) documentFragment 对象的特点"></a>(2) documentFragment 对象的特点</h4><p>documentFragment 对象也是一种节点，nodeType 是 11。</p><p>documentFragment 对象不会出现在页面结构中，但是可以作为一个容器拥有子节点。</p><p>把 documentFragment 对象作为子节点添加到一个页面的元素中，documentFragment 对象会把自己的子节点作为元素的子节点。</p><h4 id="3-documentFragment-对象的应用"><a href="#3-documentFragment-对象的应用" class="headerlink" title="(3) documentFragment 对象的应用"></a>(3) documentFragment 对象的应用</h4><ol><li>批量添加子节点，可以先把子节点添加到 documentFragment 对象中，再把documentFragment 对象一次性添加要添加的元素中。可以提高浏览器渲染效率。</li><li>借助于documentFragment 对象实现元素的翻转。</li></ol><h2 id="3-HTML-DOM"><a href="#3-HTML-DOM" class="headerlink" title="3 HTML DOM"></a>3 HTML DOM</h2><h3 id="3-1-表单相关元素"><a href="#3-1-表单相关元素" class="headerlink" title="3.1 表单相关元素"></a>3.1 表单相关元素</h3><h4 id="①-form-元素"><a href="#①-form-元素" class="headerlink" title="① form 元素"></a>① form 元素</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">方法：<br><span class="hljs-function"><span class="hljs-title">submit</span><span class="hljs-params">()</span></span><span class="hljs-selector-tag">form</span> 元素对象调用该方法，表单会提交<br><span class="hljs-function"><span class="hljs-title">reset</span><span class="hljs-params">()</span></span><span class="hljs-selector-tag">form</span> 元素对象调用该方法，表单会重置<br></code></pre></td></tr></table></figure><h4 id="②-文本输入框和文本域（input-和-textarea）"><a href="#②-文本输入框和文本域（input-和-textarea）" class="headerlink" title="② 文本输入框和文本域（input 和 textarea）"></a>② 文本输入框和文本域（input 和 textarea）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">方法：<br><span class="hljs-function"><span class="hljs-title">focus</span><span class="hljs-params">()</span></span>获取焦点<br><span class="hljs-function"><span class="hljs-title">blur</span><span class="hljs-params">()</span></span>失去焦点<br><span class="hljs-function"><span class="hljs-title">select</span><span class="hljs-params">()</span></span>选中里面的文字<br></code></pre></td></tr></table></figure><h4 id="③-select-元素"><a href="#③-select-元素" class="headerlink" title="③ select 元素"></a>③ select 元素</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">属性：<br><span class="hljs-keyword">value</span>获取选中的选项的 <span class="hljs-keyword">value</span> 值<br>length获取拉下选选项的数量<br>selectedIndex获取选中的选项的索引<br><br>方法：<br><span class="hljs-keyword">add</span>(<span class="hljs-keyword">option</span>元素)添加一个 <span class="hljs-keyword">option</span> 元素<br>remove(<span class="hljs-keyword">index</span>)删除一个选项，指定要删除选项的索引<br><br>创建 <span class="hljs-keyword">option</span> 元素的方式：<br><span class="hljs-built_in">new</span> <span class="hljs-keyword">Option</span>(中间的内容，<span class="hljs-keyword">value</span>值)<br><br></code></pre></td></tr></table></figure><h3 id="3-2-表格相关元素"><a href="#3-2-表格相关元素" class="headerlink" title="3.2 表格相关元素"></a>3.2 表格相关元素</h3><h4 id="①-table-元素"><a href="#①-table-元素" class="headerlink" title="① table 元素"></a>① table 元素</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">属性：<br>rows获取表格中所有 <span class="hljs-selector-tag">tr</span> 元素的集合<br>cells获取表格中所有 <span class="hljs-selector-tag">td</span> 或 <span class="hljs-selector-tag">th</span> 元素的集合<br><br>方法：<br><span class="hljs-function"><span class="hljs-title">insertRow</span><span class="hljs-params">()</span></span>向表格中插入一行，可以指定位置<br><span class="hljs-function"><span class="hljs-title">deleteRow</span><span class="hljs-params">()</span></span>删除一行，指定要删除行的索引<br></code></pre></td></tr></table></figure><h4 id="②-tableRow-元素（tr-元素）"><a href="#②-tableRow-元素（tr-元素）" class="headerlink" title="② tableRow 元素（tr 元素）"></a>② tableRow 元素（tr 元素）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">属性：<br>rowIndex返回当前行的索引<br>cells返回本行内所有单元格集合<br><br>方法：<br><span class="hljs-function"><span class="hljs-title">insertCell</span><span class="hljs-params">()</span></span>向行内添加一个单元格，可以指定位置<br><span class="hljs-function"><span class="hljs-title">deleteCell</span><span class="hljs-params">()</span></span>删除行内的一个单元格，指定要删除单元格的索引<br></code></pre></td></tr></table></figure><h4 id="③-tableCell-元素-（td-或-th）"><a href="#③-tableCell-元素-（td-或-th）" class="headerlink" title="③ tableCell 元素 （td 或 th）"></a>③ tableCell 元素 （td 或 th）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">属性：<br>cellIndex本单元格在行里的索引<br></code></pre></td></tr></table></figure><h3 id="3-3-快速创建-img-元素"><a href="#3-3-快速创建-img-元素" class="headerlink" title="3.3 快速创建 img 元素"></a>3.3 快速创建 img 元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Image();<br></code></pre></td></tr></table></figure><blockquote><p>所创建的 img 元素与 document.createElement(‘img’) 一样。</p></blockquote><h2 id="4-事件"><a href="#4-事件" class="headerlink" title="4 事件"></a>4 事件</h2><h3 id="4-1事件的监听（绑定）方式"><a href="#4-1事件的监听（绑定）方式" class="headerlink" title="4.1事件的监听（绑定）方式"></a>4.1事件的监听（绑定）方式</h3><h4 id="①-第一种方式-把事件作为标签的属性"><a href="#①-第一种方式-把事件作为标签的属性" class="headerlink" title="① 第一种方式 把事件作为标签的属性"></a>① 第一种方式 把事件作为标签的属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;js代码...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="②-第二种方式-把事件作为元素对象的方法"><a href="#②-第二种方式-把事件作为元素对象的方法" class="headerlink" title="② 第二种方式 把事件作为元素对象的方法"></a>② 第二种方式 把事件作为元素对象的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取到元素对象</span><br><span class="hljs-comment">// 给元素对象监听事件</span><br>element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    js 代码....<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-第三种方式-使用-AddEventListener"><a href="#③-第三种方式-使用-AddEventListener" class="headerlink" title="③ 第三种方式 使用 AddEventListener"></a>③ 第三种方式 使用 AddEventListener</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取到元素对象</span><br><span class="hljs-comment">// 给元素对象监听事件</span><br>element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    js 代码...<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><strong>第三种方式监听事件的特定：</strong></p><ol><li>事件名是不包括 <code>on</code> 的，前两种监听事件的方式需要在事件名前面添加<code>on</code>，addEventListener 方式不需要添加 <code>on</code>。</li><li>前两种方式同一种事件无法监听多次；addEventListener 方式可以监听多次同一种事件。</li><li>addEventListener 方式需要 IE8 以上浏览器支持； 前两种兼容性非常好。</li></ol></blockquote><h3 id="4-2-解除事件的监听（绑定）"><a href="#4-2-解除事件的监听（绑定）" class="headerlink" title="4.2 解除事件的监听（绑定）"></a>4.2 解除事件的监听（绑定）</h3><h4 id="①-解除第一种方式和第二种方式监听的事件"><a href="#①-解除第一种方式和第二种方式监听的事件" class="headerlink" title="① 解除第一种方式和第二种方式监听的事件"></a>① 解除第一种方式和第二种方式监听的事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 重新设置事件，覆盖前面</span><br>element.onclick = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h4 id="②-解除第三种方式监听的事件"><a href="#②-解除第三种方式监听的事件" class="headerlink" title="② 解除第三种方式监听的事件"></a>② 解除第三种方式监听的事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用方法</span><br>element.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, 回调函数名);<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> addEventListener 监听的事件如果将来打算取消监听，回调函数就不能是匿名的。</p></blockquote><h3 id="4-3-事件流"><a href="#4-3-事件流" class="headerlink" title="4.3 事件流"></a>4.3 事件流</h3><p>事件的触发会经过三个阶段：</p><p><strong>捕获阶段：</strong> 从 window  开始到 document，到 html，到 body 一直到目标元素（发生事件动作的元素）</p><p><strong>目标阶段：</strong> 找到目标元素了，标志着捕获阶段的结束，冒泡阶段的开始。</p><p><strong>冒泡阶段：</strong> 从目标元素开始，层层向上，一直到 body、html、document、window。</p><p>给元素监听了事件，事件默认会在冒泡阶段触发！</p><p><code>addEventListener()</code> 第三个参数如果设置为 true，表示该事件在捕获阶段触发！第一种和第二种监听事件的方式只能在冒泡阶段触发。</p><h3 id="4-4-事件回调函数中-this-的指向"><a href="#4-4-事件回调函数中-this-的指向" class="headerlink" title="4.4 事件回调函数中 this 的指向"></a>4.4 事件回调函数中 this 的指向</h3><ol><li>this 的指向规则，仍然是谁调用了方法，方法中的 this 就执行谁。</li><li>触发事件的元素调用了对应的回调函数。 <strong>事件回调函数中的 this 指向触发事件的元素！</strong></li></ol><h3 id="4-5-常用事件"><a href="#4-5-常用事件" class="headerlink" title="4.5 常用事件"></a>4.5 常用事件</h3><h4 id="1-鼠标事件"><a href="#1-鼠标事件" class="headerlink" title="(1) 鼠标事件"></a>(1) 鼠标事件</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">click单击<br>dblclick双击<br>contextmenu右击<br><span class="hljs-built_in">mousedown</span>鼠标按键按下<br><span class="hljs-built_in">mouseup</span>鼠标按键抬起<br><span class="hljs-built_in">mousemove</span>鼠标按键移动<br>mouseenter鼠标进入元素（IE9+） 代替 mouseover<br>mouseleave鼠标离开元素（IE9+） 代替 mouseout<br></code></pre></td></tr></table></figure><h4 id="2-键盘事件"><a href="#2-键盘事件" class="headerlink" title="(2) 键盘事件"></a>(2) 键盘事件</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">keydown</span>键盘按键按下，所有按键都可以触发<br>keyup键盘按键抬起，所有按键都可以触发<br>keypress键盘按键按下，但是只有非控制字符按键才可以触发<br></code></pre></td></tr></table></figure><blockquote><p><strong>如何获取到按的是哪个按键？</strong></p><ol><li>通过 <code>event.keyCode</code> 属性得到按键对应的 acsii 值。</li><li><code>keydown</code> 获取的按键是不区分字母大小写， <code>keypress</code> 可以区分字母按键的大小写。</li></ol></blockquote><h4 id="3-文档事件"><a href="#3-文档事件" class="headerlink" title="(3) 文档事件"></a>(3) 文档事件</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">load</span>页面中所有的一切加载完毕，触发；通常监听给 <span class="hljs-built_in">window</span> 元素。<br>DOMContentLoaded页面中的元素加载完毕，触发；通常监听给 <span class="hljs-built_in">window</span> 元素。推荐。<br>beforeunload文档关闭的时候触发。<br></code></pre></td></tr></table></figure><blockquote><p><strong>load 事件和 DOMContentLoaded 事件的区别：</strong></p><ol><li>DOMContentLoad 只要页面中所有的元素加载完毕就可以触发，而 load 事件必须等到页面中所有的一切（包括外部文件，如图片）加载完毕才触发。</li><li>DOMContentLoaded 只能使用 addEventListener 方式监听。</li></ol></blockquote><h4 id="4-表单事件"><a href="#4-表单事件" class="headerlink" title="(4) 表单事件"></a>(4) 表单事件</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">submit监听给 <span class="hljs-keyword">form</span> 元素，当表单被提交的时候，触发事件。<br>reset监听给 <span class="hljs-keyword">form</span> 元素，当表单被重置的时候，触发事件。<br>focus监听给表单控件，当获取焦点的时候触发事件。<br>blur监听给表单控件，当失去焦点的时候触发事件。<br><span class="hljs-keyword">select</span>监听给可输入元素，当里面的内容被选中，触发事件。<br><span class="hljs-built_in">change</span>监听给表单控件，更适合复选框、单选按钮、下拉选项，有变化就触发。<br></code></pre></td></tr></table></figure><blockquote><p><strong>输入框监听 change 事件，触发条件：</strong></p><ol><li>输入框内容要改变。</li><li>输入框要失去焦点。</li></ol></blockquote><h4 id="5-图片事件"><a href="#5-图片事件" class="headerlink" title="(5) 图片事件"></a>(5) 图片事件</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">load监听给 img 元素，等到图片加载完毕。<br><span class="hljs-keyword">error</span>监听给 img 元素，图片加载失败。<br></code></pre></td></tr></table></figure><h4 id="6-其他事件"><a href="#6-其他事件" class="headerlink" title="(6) 其他事件"></a>(6) 其他事件</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">scroll</span>监听给有滚动条的元素或<span class="hljs-built_in">window</span>，一滚动就不停地触发。<br>resize监听给 <span class="hljs-built_in">window</span>，视口尺寸发生变化。<br></code></pre></td></tr></table></figure><blockquote><p><strong>获取页面整体滚动（偏移）的距离：</strong></p><p>document.documentElement.scrollTop || document.body.scrollTop</p></blockquote><h3 id="4-6-Event-对象"><a href="#4-6-Event-对象" class="headerlink" title="4.6 Event 对象"></a>4.6 Event 对象</h3><h4 id="1-获取-Event-对象"><a href="#1-获取-Event-对象" class="headerlink" title="(1) 获取 Event 对象"></a>(1) 获取 Event 对象</h4><p>给事件的回调函数，设置一个形参，自动获取本次事件触发对应的事件对象。</p><h4 id="2-鼠标事件对象-MouseEvent-的属性和方法"><a href="#2-鼠标事件对象-MouseEvent-的属性和方法" class="headerlink" title="(2) 鼠标事件对象 MouseEvent 的属性和方法"></a>(2) 鼠标事件对象 MouseEvent 的属性和方法</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">clientX</span> / clientY获取鼠标在视口上的位置<br><span class="hljs-attribute">pageX</span> / pageY获取鼠标在整个文档（整个页面）上的位置<br><span class="hljs-attribute">screenX</span> / screenY获取鼠标在屏幕上的位置<br><span class="hljs-attribute">offsetX</span> / offsetY获取鼠标在目标元素上的位置<br><span class="hljs-attribute">button</span>获取鼠标按的哪个按键； 值是 <span class="hljs-number">0</span> 表示左键、值是 <span class="hljs-number">1</span> 表示中间的滚轮、值是 <span class="hljs-number">2</span> 表示右键<br></code></pre></td></tr></table></figure><h4 id="3-键盘事件对象-KeyBorardEvent-的属性和方法"><a href="#3-键盘事件对象-KeyBorardEvent-的属性和方法" class="headerlink" title="(3) 键盘事件对象 KeyBorardEvent 的属性和方法"></a>(3) 键盘事件对象 KeyBorardEvent 的属性和方法</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">keyCode</span>获取按键的ascii值<br>which同 <span class="hljs-built_in">keyCode</span><br><span class="hljs-built_in">key</span>获取按键的值<br></code></pre></td></tr></table></figure><h4 id="4-所有的事件对象都有的属性和方法"><a href="#4-所有的事件对象都有的属性和方法" class="headerlink" title="(4) 所有的事件对象都有的属性和方法"></a>(4) 所有的事件对象都有的属性和方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type获取事件名<br>target获取目标元素<br>timeStamp获取触发事件的那一刻距离打开页面的那一刻相差的毫秒数<br><span class="hljs-function"><span class="hljs-title">stopPropagation</span><span class="hljs-params">()</span></span>阻止冒泡<br><span class="hljs-function"><span class="hljs-title">preventDefault</span><span class="hljs-params">()</span></span>阻止浏览器默认行为<br></code></pre></td></tr></table></figure><h4 id="5-阻止事件冒泡"><a href="#5-阻止事件冒泡" class="headerlink" title="(5) 阻止事件冒泡"></a>(5) 阻止事件冒泡</h4><p>在事件的回调函数中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event.stopPropagation();<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>return false</code> 在原生 js 中不能阻止冒泡。 </p></blockquote><h4 id="6-浏览器的默认行为"><a href="#6-浏览器的默认行为" class="headerlink" title="(6)  浏览器的默认行为"></a>(6)  浏览器的默认行为</h4><h5 id="①-浏览器有哪些默认行为"><a href="#①-浏览器有哪些默认行为" class="headerlink" title="① 浏览器有哪些默认行为"></a>① 浏览器有哪些默认行为</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">在页面中右击，出现菜单<br>超连接点击跳转<br>表单的提交和重置<br>等<br></code></pre></td></tr></table></figure><h5 id="②-阻止浏览器默认行为"><a href="#②-阻止浏览器默认行为" class="headerlink" title="② 阻止浏览器默认行为"></a>② 阻止浏览器默认行为</h5><p>在事件的回调函数中调用语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event.preventDefault();<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>如果是使用第二种方式监听事件（把事件作为元素对象的方法），回调函数中写 <code>return false</code> 同样可以阻止默认行为，与 <code>event.preventDefault（）</code> 功效一致！</p></blockquote><h3 id="4-6-事件委托"><a href="#4-6-事件委托" class="headerlink" title="4.6 事件委托"></a>4.6 事件委托</h3><p><strong>如何实现事件委托：</strong></p><p>把事件委托监听给要监听事件元素 的祖先元素，触发事件的时候，判断目标元素是否是监听事件的元素，如果是就执行相关操作，不是什么也不做。</p><p><strong>事件委托解决什么问题：</strong></p><p>事件委托主要解决新增的元素也能监听上事件。</p><h2 id="5-深入分析-DOM-对象"><a href="#5-深入分析-DOM-对象" class="headerlink" title="5 深入分析 DOM 对象"></a>5 深入分析 DOM 对象</h2><h3 id="5-1-元素对象的原型链关系"><a href="#5-1-元素对象的原型链关系" class="headerlink" title="5.1 元素对象的原型链关系"></a>5.1 元素对象的原型链关系</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">div元素对象 -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HTMLDivElement</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HTMLElement</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Element</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Node</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventTarget</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype<br></code></pre></td></tr></table></figure><h3 id="5-2-事件对象的原型链关系"><a href="#5-2-事件对象的原型链关系" class="headerlink" title="5.2 事件对象的原型链关系"></a>5.2 事件对象的原型链关系</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">鼠标事件对象 -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MouseEvent</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIEvent</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Event</span>.</span></span>prototype -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype<br></code></pre></td></tr></table></figure><h3 id="5-3-HTMLCollection-和-NodeList-的区别"><a href="#5-3-HTMLCollection-和-NodeList-的区别" class="headerlink" title="5.3 HTMLCollection 和 NodeList 的区别"></a>5.3 HTMLCollection 和 NodeList 的区别</h3><p><strong>NodeList 类型的对象：</strong></p><ol><li>NodeList 对象是节点组成的集合，成员中可以有元素节点、属性节点等所有类型的节点。</li><li>具有 forEach 方法。</li><li>该对象是静态的，获取完对象再添加元素，对已经获取的对象没有影响。</li><li><code>querySelectorAll()</code>、<code>getElementsByName()</code> 的返回值和 <code>childNodes</code> 的属性值 得到一个 NodeList 对象。</li></ol><p><strong>HTMLCollection 类型的对象：</strong></p><ol><li>HTMLCollection 对象是元素组成的集合，成员中只能是元素。</li><li>没有 forEach 方法</li><li>该对象是动态的，获取完对象再添加元素，对象中包含新的元素。</li><li><code>getElementsByTagName()</code> 和 <code>getElementsByClassName()</code> 的返回值和 <code>children</code>的属性值可以得到一个 HTMLCollection 对象。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 基础</title>
    <link href="/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/19/JavaScript%E6%95%99%E7%A8%8B-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h2><h3 id="1-1-JavaScript-在-HTML-中使用的三种方式"><a href="#1-1-JavaScript-在-HTML-中使用的三种方式" class="headerlink" title="1.1 JavaScript 在 HTML 中使用的三种方式"></a>1.1 JavaScript 在 HTML 中使用的三种方式</h3><h4 id="①-行内式"><a href="#①-行内式" class="headerlink" title="① 行内式"></a>① 行内式</h4><p>需要结合 JS 的事件来使用，把 JS 事件作为 HTML 标签的属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;code...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="②-内嵌式"><a href="#②-内嵌式" class="headerlink" title="② 内嵌式"></a>② 内嵌式</h4><p>使用 <code>script</code> 标签，把 js 代码写在 <code>script</code> 标签里面。 <code>script</code> 标签放在页面中的任意位置，代码都可以执行，建议 <code>script</code> 放在所有元素的后面（等到其他元素加载完了，在执行 JS）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    code...<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="③-外链式"><a href="#③-外链式" class="headerlink" title="③ 外链式"></a>③ 外链式</h4><p>把 JS 代码写在文件后缀是<code>.js</code> 的文件中，使用 <code>script</code> 标签的 <code>src</code> 属性指定外部 JS 文件的地址。标签仍然建议放在所有元素的最后面。</p><p>虽然外链式和内嵌式使用的都是 <code>script</code> 标签，但是一个 <code>script</code> 标签无法既外链又内嵌。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js文件地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-JavaScript-注释"><a href="#1-2-JavaScript-注释" class="headerlink" title="1.2 JavaScript 注释"></a>1.2 JavaScript 注释</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单行注释</span><br><br><span class="hljs-comment">// 后面的内容都会被注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="1-3-JavaScript-语法特点"><a href="#1-3-JavaScript-语法特点" class="headerlink" title="1.3 JavaScript 语法特点"></a>1.3 JavaScript 语法特点</h3><ul><li>JS 严格区分大小写。</li><li>JS 由一条一条的语句组成（指令）；每一条语句的结束需要写一个指令结束符； 指令结束符可以是换行也可以是分号。</li></ul><h3 id="1-4-JavaScript-中输出内容"><a href="#1-4-JavaScript-中输出内容" class="headerlink" title="1.4 JavaScript 中输出内容"></a>1.4 JavaScript 中输出内容</h3><h4 id="①-输出到弹框"><a href="#①-输出到弹框" class="headerlink" title="① 输出到弹框"></a>① 输出到弹框</h4><p>弹框出来之后，会暂停js程序的执行，直到用户点了确定，弹框后面的代码才继续执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">alert(内容)<br></code></pre></td></tr></table></figure><h4 id="②-输出到页面"><a href="#②-输出到页面" class="headerlink" title="② 输出到页面"></a>② 输出到页面</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.write(内容)<br></code></pre></td></tr></table></figure><h4 id="③-输出到控制台"><a href="#③-输出到控制台" class="headerlink" title="③ 输出到控制台"></a>③ 输出到控制台</h4><p>需要打开浏览器调试工具，切换到 <code>console</code> 就可以看到控制台输出。 推荐。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(内容)<br></code></pre></td></tr></table></figure><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h2><h3 id="2-1-数据、直接量、变量"><a href="#2-1-数据、直接量、变量" class="headerlink" title="2.1 数据、直接量、变量"></a>2.1 数据、直接量、变量</h3><p><strong>数据：</strong> 计算机计算的就是数据，计算机可以对数据进行存储、计算。</p><p><strong>直接量：</strong> 直接使用数据就是直接量。   </p><p><strong>变量：</strong> 给数据取了个名字，通过名字可以使用数据。 变量也可以认为是存储数据的容器。</p><h3 id="2-2-变量的意义"><a href="#2-2-变量的意义" class="headerlink" title="2.2 变量的意义"></a>2.2 变量的意义</h3><p>把数据赋值给变量之后，就把这个数据存了下来，（在程序执行过程中）在任何适合时候使用变量都可以取到该数据。</p><p>使用变量可以保证数据的前后一致。</p><h3 id="2-3-变量的语法"><a href="#2-3-变量的语法" class="headerlink" title="2.3 变量的语法"></a>2.3 变量的语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 声明变量并给变量赋值</span><br><span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;朦朦&#x27;</span>;<br><br><span class="hljs-comment">// 2. 声明变量，不赋值</span><br><span class="hljs-keyword">var</span> age;<br><br><span class="hljs-comment">// 3. 一次同时声明多个变量</span><br><span class="hljs-comment">// var a = 100;</span><br><span class="hljs-comment">// var b;</span><br><span class="hljs-comment">// var c = 300;</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>, b, c = <span class="hljs-number">300</span>;<br><br><span class="hljs-comment">// 4. 修改变量的值, 给已经声明过的变量重新赋值，无需关键子 var</span><br>username = <span class="hljs-string">&#x27;小乐&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>声明变量使用关键字 <code>var</code>，可以声明变量的同时赋值，也可以只声明变量然后以后赋值。</li><li>变量的值可以修改，如果变量已经声明过，修改变量值的时候，无需添加关键字 <code>var</code>。</li><li>如果使用不存在的变量，会报错。</li></ul><h3 id="2-4-变量的命名规范（标识符的命名规范）"><a href="#2-4-变量的命名规范（标识符的命名规范）" class="headerlink" title="2.4 变量的命名规范（标识符的命名规范）"></a>2.4 变量的命名规范（标识符的命名规范）</h3><p>JS 中，变量名要遵循<strong>标识符</strong>的命名规范。</p><h4 id="①-强制规范"><a href="#①-强制规范" class="headerlink" title="① 强制规范"></a>① 强制规范</h4><ul><li>标识符必须由数字、字母、下划线、$ 组成，且不能以数字开头。</li><li>标识符不能是关键字和保留字。</li><li>标识符严格区分大小写。</li></ul><blockquote><p><strong>关键字：</strong> JS 中具有特殊含义的一些词。</p><p><strong>保留字：</strong> 当前还不是关键字但是以后可能成为关键字的词。</p></blockquote><h4 id="①-建议规范"><a href="#①-建议规范" class="headerlink" title="① 建议规范"></a>① 建议规范</h4><ul><li>变量名要有意义，最好通过变量名就可以明白所表示的数据。</li><li>如果变量名由多个单词组成，建议使用小驼峰命名法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 小驼峰命名法</span><br><span class="hljs-keyword">var</span> userInfo = [];<br><span class="hljs-keyword">var</span> vipUserAddress = &#123;&#125;;<br><br><span class="hljs-comment">// 大驼峰命名法</span><br><span class="hljs-keyword">var</span> UserInfo = [];<br><span class="hljs-keyword">var</span> VipUserAddress = &#123;&#125;;<br><br><span class="hljs-comment">// _ 命名法</span><br><span class="hljs-keyword">var</span> user_info = [];<br><span class="hljs-keyword">var</span> vip_info_address = &#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h2><h3 id="3-1-数据类型的划分"><a href="#3-1-数据类型的划分" class="headerlink" title="3.1 数据类型的划分"></a>3.1 数据类型的划分</h3><h4 id="①-原始类型"><a href="#①-原始类型" class="headerlink" title="① 原始类型"></a>① 原始类型</h4><p>JS 中共有 5 种原始类型：</p><ol><li>number    数字类型</li><li>string  字符串类型</li><li>boolean 布尔类型</li><li>undefined  未定义类型</li><li>null   空类型</li></ol><h4 id="②-对象类型"><a href="#②-对象类型" class="headerlink" title="② 对象类型"></a>② 对象类型</h4><ul><li>Object 类型</li><li>Array 类型</li><li>…..</li></ul><h3 id="3-2-判断数据的类型"><a href="#3-2-判断数据的类型" class="headerlink" title="3.2 判断数据的类型"></a>3.2 判断数据的类型</h3><p>使用 JS 内置的函数 <code>typeof()</code> 来进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span>(变量/直接量)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>数据类型是 null 的数据，使用 typeof 判断会得到 object。</p></blockquote><h3 id="3-3-number-数值类型"><a href="#3-3-number-数值类型" class="headerlink" title="3.3 number 数值类型"></a>3.3 number 数值类型</h3><h4 id="①-整型"><a href="#①-整型" class="headerlink" title="① 整型"></a>① 整型</h4><p>整数会以整型的形式进行存储和运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">3453245</span>;   <span class="hljs-comment">// 10 进制表示</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">010</span>;       <span class="hljs-comment">// 8 进制表示</span><br><span class="hljs-keyword">var</span> num3 = <span class="hljs-number">0x10</span>;      <span class="hljs-comment">// 16 进制表示  </span><br></code></pre></td></tr></table></figure><h4 id="②-浮点型"><a href="#②-浮点型" class="headerlink" title="② 浮点型"></a>② 浮点型</h4><p>小数会以浮点型的形式进行存储和运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num4 = <span class="hljs-number">2.45</span>; <span class="hljs-comment">// 普通小数</span><br><span class="hljs-keyword">var</span> num5 = <span class="hljs-number">.67</span>;  <span class="hljs-comment">// 0.67 建议写成 .67</span><br><span class="hljs-keyword">var</span> num6 = <span class="hljs-number">8.56e3</span>;  <span class="hljs-comment">// 科学计数法  即使最终是个整数也安装浮点型存储</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>浮点型数字的运算存在<strong>精度问题</strong>，因为转为 2 进制小数的时候计算机无法精准转换。</p></blockquote><h4 id="③-NaN"><a href="#③-NaN" class="headerlink" title="③ NaN"></a>③ NaN</h4><p>NaN 是一个特殊的 number 值，虽然不是常规的数字，但是数据类型就是 number。</p><p><strong>NaN 的特点：</strong></p><ol><li>NaN 与任何数进行任何运算，结果还是NaN。</li><li>NaN 与任何数都不相等，包括自己。</li></ol><p><strong>NaN 的意义：</strong></p><p>我们不会主动定义 NaN ，主要是其他数据类型转为 number 类型的时候，可能会转为 NaN，NaN 都是被动获取的。</p><p><strong>isNaN() 函数</strong></p><p>该函数用来判断数据是不是 NaN，如果是 NaN，返回 true，否则返回 false。</p><h4 id="④-JavaScript-中数字的有效范围"><a href="#④-JavaScript-中数字的有效范围" class="headerlink" title="④ JavaScript 中数字的有效范围"></a>④ JavaScript 中数字的有效范围</h4><p>如果数字超过 JS 可表示的最大有效范围，会表示为 <code>Infinity</code> 和 <code>-Infinity</code>； </p><p><code>Infinity</code> 和 <code>-Infinity</code> 也可以认为是特殊的 number 值，数据类型任然是 <code>number</code>。</p><p><strong>isFinite() 函数：</strong></p><p>用来判断一个数字是否在有效范围内，如果在有效范围内，返回 true； 如果不在有效范围内（Infinity、-Infinity、NaN） 返回 false。</p><h3 id="3-4-string-字符串类型"><a href="#3-4-string-字符串类型" class="headerlink" title="3.4 string 字符串类型"></a>3.4 string 字符串类型</h3><h4 id="①-字符串的表示方式"><a href="#①-字符串的表示方式" class="headerlink" title="① 字符串的表示方式"></a>① 字符串的表示方式</h4><ul><li>定义一个字符串，可以使用双引号也可以使用单引号，二者没有任何区别。</li><li>双引号表示的字符串中不能有双引号，单引号表示的字符串中不能有单引号，否则语法错误； 非要嵌套可以转义。</li></ul><h4 id="②-转义字符"><a href="#②-转义字符" class="headerlink" title="② 转义字符"></a>② 转义字符</h4><p>转义字符用来表示无法在字符串中正常书写的字符。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\n</span>表示换行符<br><span class="hljs-string">\&#x27;</span>单引号的转义，用于单引号表示的字符串内<br><span class="hljs-string">\&quot;</span>双引号的转义，用于双引号表示的字符串内<br><span class="hljs-string">\\</span>对反斜杠本身的转义<br><span class="hljs-string">\uxxxx</span>使用<span class="hljs-number">4</span>个<span class="hljs-number">16</span>进制数字表示 unicode 编码对应的字符<br></code></pre></td></tr></table></figure><h3 id="3-5-boolean-布尔类型"><a href="#3-5-boolean-布尔类型" class="headerlink" title="3.5 boolean 布尔类型"></a>3.5 boolean 布尔类型</h3><p>boolean 类型的值就两个，true 和 false；</p><p>true 表示真，表示肯定； false 表示假，表示否定。</p><p>布尔值主要用来表示某种判断的计算结果。</p><h3 id="3-6-null-和-undefined"><a href="#3-6-null-和-undefined" class="headerlink" title="3.6 null 和 undefined"></a>3.6 null 和 undefined</h3><p><strong>undefined</strong> 类型的值就 undefined 自己。表示没有定义值，如变量声明没赋值，变量的值就是 undefined； undefined 一般被动产生的。</p><p><strong>null</strong> 类型的值就 null 自己，表示空的、没有。 一般是主动定义的。</p><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4 运算符"></a>4 运算符</h2><h3 id="4-1-运算符和表达式"><a href="#4-1-运算符和表达式" class="headerlink" title="4.1 运算符和表达式"></a>4.1 运算符和表达式</h3><h4 id="①-运算符"><a href="#①-运算符" class="headerlink" title="① 运算符"></a>① 运算符</h4><p>运算符就是参与运算的符号，像<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 等。</p><p>与运算符一起运算的变量、直接量、表达式称之为<strong>操作数</strong>。</p><h4 id="②-表达式"><a href="#②-表达式" class="headerlink" title="② 表达式"></a>② 表达式</h4><p><strong>表达式</strong>是进行计算的式子、表达式有一个最终计算结果，称之为<strong>表达式的值</strong>。</p><p>最简单的表达式称之为<strong>原始表达式</strong>，一个直接量、一个变量都是原始表达式。</p><p>通过运算符可以把简单表达式组合成复杂一些的表达式。</p><p>有些表达式具有副作用，表达式在计算的过程中，会对参与运算的变量进行修改，称之为<strong>表达式的副作用</strong>， 表达式的副作用是由运算符决定的。</p><h3 id="4-2-运算符的分类"><a href="#4-2-运算符的分类" class="headerlink" title="4.2 运算符的分类"></a>4.2 运算符的分类</h3><h4 id="①-按照运算符需要的操作数的个数"><a href="#①-按照运算符需要的操作数的个数" class="headerlink" title="① 按照运算符需要的操作数的个数"></a>① 按照运算符需要的操作数的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">一元运算分（一目运算符）<br>二元运算符（二目运算符）<br>三元运算符（三目运算符）<br></code></pre></td></tr></table></figure><h4 id="②-按照运算符的功能"><a href="#②-按照运算符的功能" class="headerlink" title="② 按照运算符的功能"></a>② 按照运算符的功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">算术运算符<br>关系运算符（比较运算符）<br>逻辑运算符<br>位运算符<br>赋值运算符<br>其他运算符<br></code></pre></td></tr></table></figure><h3 id="4-3-运算符详细解（按照功能）"><a href="#4-3-运算符详细解（按照功能）" class="headerlink" title="4.3 运算符详细解（按照功能）"></a>4.3 运算符详细解（按照功能）</h3><h4 id="①-算术运算符"><a href="#①-算术运算符" class="headerlink" title="① 算术运算符"></a>① 算术运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>操作数个数</th><th>操作数的类型要求</th><th>组成的表达式的值的类型</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>加</td><td>2</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>-</code></td><td>减</td><td>2</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>*</code></td><td>乘</td><td>2</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>/</code></td><td>除</td><td>2</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>%</code></td><td>取余</td><td>2</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>+</code></td><td>正号</td><td>1</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>-</code></td><td>负号</td><td>1</td><td>number</td><td>number</td><td>无</td></tr><tr><td><code>++</code></td><td>累加</td><td>1</td><td>number</td><td>number</td><td>有</td></tr><tr><td><code>--</code></td><td>累减</td><td>1</td><td>number</td><td>number</td><td>有</td></tr></tbody></table><blockquote><p><strong><code>+</code> 正号运算符</strong>：</p><p>把操作数的值作为所组成的表达式值的值，不会做任何运算； 但是会创造一个 number 的运算环境，非 number 类型操作数会自动转换； 所以，该运算符经常用来把其他类型转为 number 类型。</p></blockquote><blockquote><p><strong>累加和累减</strong>：</p><p>累加或累减的运算符，可以在操作数的前面，也可以在后面； 运算符在前与在后，主要是表达式的值有所不同，但是副作用是一致的。</p><p>如果运算符在操作数的前面：把操作数累加或累减之后的值作为表达式的值。</p><p>如果运算符在操作数的后面：把操作数没有进行累加或累减之前的值作为表达式的值。</p></blockquote><h4 id="②-关系运算符（比较运算符）"><a href="#②-关系运算符（比较运算符）" class="headerlink" title="② 关系运算符（比较运算符）"></a>② 关系运算符（比较运算符）</h4><table><thead><tr><th>运算符</th><th>含义</th><th>操作数个数</th><th>操作数的类型要求</th><th>组成的表达式的值的类型</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>==</code></td><td>相等</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>!=</code></td><td>不相等</td><td>2</td><td>number / string</td><td>boolean</td><td>无</td></tr><tr><td><code>===</code></td><td>全等</td><td>2</td><td>没有要求</td><td>boolean</td><td>无</td></tr><tr><td><code>!==</code></td><td>不全等</td><td>2</td><td>没有要求</td><td>boolean</td><td>无</td></tr></tbody></table><blockquote><p><strong>比较大小：</strong></p><ol><li><p>比较大小的运算符，如果两个操作数类型不一致，自动转为 number 进行比较； </p></li><li><p>如果两个操作数都是字符串，按照字符串比较的规则进行比较。字符串比较大小的规则： 按位比，当前位比较大，整个字符串都大； 比较的是每一位的字符对应的 ascii码。</p></li></ol></blockquote><blockquote><p><strong>判等规则 <code>==</code> 和 <code>!=</code> :</strong></p><ol><li><p>两个操作数的类型不一致，转为 number 之后再比较。</p></li><li><p>如果两个操作数都是字符串，安装字符串的规则来判断，两个字符串如果一样就相等。</p></li><li><p>null 与其他值判断比较特殊：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-number">0</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">false</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&#x27;&#x27;</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><p>**全等的规则 <code>===</code> 和 <code>!==</code>**：</p><p>全等判断不会对操作数进行自动类型转换，如果两个操作数类型不一致，直接不全等； 如果两个操作数类型一致，值相同就全等。</p><p>推荐使用！！！</p></blockquote><blockquote><p><strong>NaN 的比较规则：</strong></p><p>NaN 与 任何操作数进行任何比较，都不成立，结果都是 false。（除了判不等 <code>!=</code> 和 <code>!==</code>）</p></blockquote><blockquote><p><strong>常见的 ASCII 码</strong>： </p><p>a -&gt; 97, b -&gt; 98 …..</p><p>A -&gt; 65，B -&gt; 66 …</p></blockquote><h4 id="③-逻辑运算符"><a href="#③-逻辑运算符" class="headerlink" title="③ 逻辑运算符"></a>③ 逻辑运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>操作数个数</th><th>操作数的类型要求</th><th>组成的表达式的值的类型</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND,  并且）</td><td>2</td><td>无要求</td><td>根据操作数的类型</td><td>无</td></tr><tr><td>`</td><td></td><td>`</td><td>逻辑或（OR，或者）</td><td>2</td><td>无要求</td></tr><tr><td><code>!</code></td><td>逻辑非</td><td>1</td><td>boolean</td><td>boolean</td><td>无</td></tr></tbody></table><blockquote><p><strong>逻辑与组成的表达式的值：</strong></p><p>如果第一个操作数成立，取第二个操作数作为整个表达式的值；</p><p>如果第一个操作数不成立，取第一个操作数作为整个表达式的值，第二个操作数直接忽略。</p><p><strong>逻辑或组成的表达式的值：</strong></p><p>如果第一操作数成立，取第一个操作数作为整个表达式的值，第二个操作数直接忽略。</p><p>如果第一个操作数不成立，取第二个操作数作为整个表达式的值。</p></blockquote><h4 id="④-赋值运算符"><a href="#④-赋值运算符" class="headerlink" title="④ 赋值运算符"></a>④ 赋值运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>操作数个数</th><th>操作数的类型要求</th><th>组成的表达式的值的类型</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>+=</code></td><td>赋值求和</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>-=</code></td><td>赋值求差</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>*=</code></td><td>赋值求积</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>/=</code></td><td>赋值求商</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>%=</code></td><td>赋值求余</td><td>2</td><td>类型无要求，左边操作必须是变量</td><td>左边操作数被赋值之后的值</td><td>有</td></tr><tr><td><code>+=</code></td><td>赋值连接</td><td>2</td><td>操作数中只要有一个字符串，表示赋值连接</td><td>左边操作数被赋值之后的值</td><td>有</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ol><li>赋值运算符所组成的表达式，都具有副作用；副作用是对左边的操作数（变量）的值进行修改，我们需要的就是副作用。</li><li>赋值运算符左边的操作数必须是变量形式，右边操作数的形式变量、直接量皆可。</li><li>赋值运算符所组成的表达式的值是赋值之后的左边的操作数。</li></ol></blockquote><h4 id="⑤-其他运算符"><a href="#⑤-其他运算符" class="headerlink" title="⑤ 其他运算符"></a>⑤ 其他运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>操作数个数</th><th>操作数的类型要求</th><th>组成的表达式的值的类型</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>字符串连接符</td><td>2</td><td>string</td><td>string</td><td>无</td></tr><tr><td><code>,</code></td><td>逗号运算符</td><td>2</td><td>无要求</td><td>第二个操作的值</td><td>不确定</td></tr><tr><td><code>typeof</code></td><td>类型判断</td><td>1</td><td>无要求</td><td>string</td><td>无</td></tr><tr><td><code>?:</code></td><td>条件运算符</td><td>3</td><td>第一个操作数要求是 boolean<br>第二个和第三个没有类型要求</td><td>从第二第三个操作数中取一个</td><td>无</td></tr></tbody></table><blockquote><p><strong><code>+</code> 具有三个含义：</strong></p><ol><li> 如果操作数只有一个，<code>+</code> 是正号运算符。</li><li> 如果操作数有两个，且其中一个是字符串或者两个都是字符串，<code>+</code> 是字符串连接符。</li><li> 如果操作数有两个，且没有任何一个操作数是字符串，<code>+</code> 是加号运算符。</li></ol><p><strong>三元运算符组成的表达式取值规则：</strong></p><ol><li>如果第一个操作数成立，把第二个操作数作为表达式的值；此时第三个操作数不会执行。</li><li>如果第一个操作数不成立，把第三个操作数作为表达式的值；此时第二个操作数不会执行。</li></ol></blockquote><h3 id="4-4-运算符优先级"><a href="#4-4-运算符优先级" class="headerlink" title="4.4 运算符优先级"></a>4.4 运算符优先级</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">一元运算符</span> <span class="hljs-comment">（</span>++<span class="hljs-comment">、</span>--<span class="hljs-comment">、负号、正号、逻辑非、typeof）</span><br><span class="hljs-comment">算术运算符（*、</span> <span class="hljs-comment">/、</span> <span class="hljs-comment">%、</span> <span class="hljs-literal">+</span><span class="hljs-comment">、</span> <span class="hljs-literal">-</span> <span class="hljs-comment">）</span><br><span class="hljs-comment">比大小</span><br><span class="hljs-comment">比相等</span><br><span class="hljs-comment">逻辑与和逻辑或</span><br><span class="hljs-comment">赋值运算符</span><br><span class="hljs-comment">三元运算符</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>可以通过添加 <code>()</code> 来提高优先级！</p></blockquote><h2 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5 流程控制语句"></a>5 流程控制语句</h2><h3 id="5-1-条件语句"><a href="#5-1-条件语句" class="headerlink" title="5.1 条件语句"></a>5.1 条件语句</h3><h4 id="①-单向分支-if"><a href="#①-单向分支-if" class="headerlink" title="① 单向分支 if"></a>① 单向分支 if</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    code ....<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-双向分支-if-else"><a href="#②-双向分支-if-else" class="headerlink" title="② 双向分支 if else"></a>② 双向分支 if else</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>code ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>coce ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-多向分支-else-if"><a href="#③-多向分支-else-if" class="headerlink" title="③ 多向分支 else if"></a>③ 多向分支 else if</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>code ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    code ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    code ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    code ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-多向分支-switch-case"><a href="#④-多向分支-switch-case" class="headerlink" title="④ 多向分支 switch case"></a>④ 多向分支 switch case</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> 表达式可能的值: code...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 表达式可能的值: code...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 表达式可能的值: code...; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 表达式可能的值: code...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: code...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>特定：</strong></p><ol><li>switch case 适合判等的多向分支的场景。</li><li>switch case 判等是按照全等的规则进行判等。</li><li>break 会结束本次 case 的执行，如果没有 break，代码会一直向下执行，直到遇到 break。</li></ol></blockquote><h4 id="⑤-嵌套分支"><a href="#⑤-嵌套分支" class="headerlink" title="⑤ 嵌套分支"></a>⑤ 嵌套分支</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    <span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">switch</span> (表达式) &#123;<br>        <span class="hljs-keyword">case</span>: <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h3><h4 id="①-while-循环"><a href="#①-while-循环" class="headerlink" title="① while 循环"></a>① while 循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (条件表达式) &#123;<br>    code ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>循环的条件表达式不能一直都成立，否则会造成死循环。</li><li>正常的循环，随着循环次数增加，循环条件应该越来越趋近于不成立。</li></ol></blockquote><h4 id="②-do-while-循环"><a href="#②-do-while-循环" class="headerlink" title="② do while 循环"></a>② do while 循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>    code ...<br>&#125; <span class="hljs-keyword">while</span> (条件表达式);<br></code></pre></td></tr></table></figure><blockquote><p><strong>while 循环和 do while 循环的区别：</strong></p><p>do wilhe 循环只有第一次循环没有判断条件就行了，以后的每一次都是先判断条件成立了再执行。</p></blockquote><h4 id="③-for-循环"><a href="#③-for-循环" class="headerlink" title="③ for 循环"></a>③ for 循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (初始化循环标记变量; 循环条件; 循环标记变量的变化) &#123;<br>    code ....<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>初始化循环标记标量，只在循环之前执行一次。</li><li>每次执行循环体代码之前，先判断循环条件是否成立。</li><li>循环标记变量的变化，等到大括号中循环体代码执行完毕才执行。</li></ol></blockquote><h3 id="5-3-跳转语句"><a href="#5-3-跳转语句" class="headerlink" title="5.3 跳转语句"></a>5.3 跳转语句</h3><h4 id="①-break"><a href="#①-break" class="headerlink" title="① break"></a>① break</h4><p>在循环中使用，执行到 <code>break</code>，会结束整个循环。</p><p>在 switch case 使用，执行到 <code>break</code>，结束当前 case。</p><h4 id="①-continue"><a href="#①-continue" class="headerlink" title="① continue"></a>① continue</h4><p>在循环中使用，执行到 <code>contine</code>，会跳出当前循环，本次循环内后面的代码不执行了，下次循环继续。</p><h3 id="5-4-其他语句"><a href="#5-4-其他语句" class="headerlink" title="5.4 其他语句"></a>5.4 其他语句</h3><h4 id="①-异常处理语句"><a href="#①-异常处理语句" class="headerlink" title="① 异常处理语句"></a>① 异常处理语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>    code ...<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// e 就是错误信息，对象类型的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写在 <code>try</code> 结构中的代码，一旦出现运行时错误，错误不会被系统抛出，被 <code>catch</code> 捕获，开发者可以按照需求自由处理。</p><p>try 结构以外的代码不会受到 try 代码错误的影响。</p></blockquote><h4 id="②-严格模式语句"><a href="#②-严格模式语句" class="headerlink" title="② 严格模式语句"></a>② 严格模式语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>开启严格模式后，一些旧的不合理的语法就不允许使用了。</p><p><code>use strict</code> 代码通常写在最前面。</p></blockquote><h4 id="③-with-语句-（了解）"><a href="#③-with-语句-（了解）" class="headerlink" title="③ with 语句 （了解）"></a>③ with 语句 （了解）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">with</span> (<span class="hljs-built_in">document</span>) &#123;<br>    write(<span class="hljs-string">&#x27;朦朦&lt;br&gt;&#x27;</span>);<br>    write(<span class="hljs-string">&#x27;大朦朦&lt;br&gt;&#x27;</span>);<br>    write(<span class="hljs-string">&#x27;小朦朦&lt;br&gt;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6 数组"></a>6 数组</h2><h3 id="6-1-什么是数组"><a href="#6-1-什么是数组" class="headerlink" title="6.1 什么是数组"></a>6.1 什么是数组</h3><ul><li>数据是<strong>值的有序集合</strong>。</li><li>数组中的每个值（成员）称之为<strong>元素</strong>。</li><li>每个元素在数组中都有位置，用数字表示，称之为<strong>索引</strong> 或者 <strong>下标</strong>。</li><li>数组中元素可以是任意类型的数据。</li><li>数组索引从 0 开始, 最大为 2^32-2，数组最大能容纳 4294967294 个元素。</li></ul><h3 id="6-2-声明数组的方式"><a href="#6-2-声明数组的方式" class="headerlink" title="6.2 声明数组的方式"></a>6.2 声明数组的方式</h3><h4 id="①-直接量方式"><a href="#①-直接量方式" class="headerlink" title="① 直接量方式"></a>① 直接量方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr1 = [];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;朦朦&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]];<br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><h4 id="②-Array-函数方式"><a href="#②-Array-函数方式" class="headerlink" title="② Array 函数方式"></a>② Array 函数方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr4 = <span class="hljs-built_in">Array</span>();<br><span class="hljs-keyword">var</span> arr5 = <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;朦朦&#x27;</span>, <span class="hljs-string">&#x27;大悲&#x27;</span>, <span class="hljs-string">&#x27;曹操&#x27;</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">var</span> arr6 = <span class="hljs-built_in">Array</span>(<span class="hljs-number">90</span>);  <span class="hljs-comment">// 90会被作为元素的个数 </span><br><span class="hljs-keyword">var</span> arr7 = <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;下了&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>如果 Array() 函数只有一个参数，且该参数是数字，这个参数会被当做元素的个数。</p></blockquote><h4 id="③-Array-构造函数方式"><a href="#③-Array-构造函数方式" class="headerlink" title="③ Array 构造函数方式"></a>③ Array 构造函数方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br><span class="hljs-keyword">var</span> arr9 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">4005</span>,<span class="hljs-number">66</span>);<br><span class="hljs-keyword">var</span> arr10 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">var</span> arr11 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><blockquote><p>规则同 Array 函数相同！</p></blockquote><h3 id="6-3-数组元素的读写"><a href="#6-3-数组元素的读写" class="headerlink" title="6.3 数组元素的读写"></a>6.3 数组元素的读写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用数组中的元素通过索引可以获取指定元素的值</span><br>arr[<span class="hljs-number">4</span>]<br><br><span class="hljs-comment">// 可以数组元素重新赋值; 如果索引是不存在的元素会添加一个元素</span><br>arr[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.length;   <span class="hljs-comment">// 所有的数组都具有 length 属性，通过 length 可以获取数组的长度（元素的个数）</span><br></code></pre></td></tr></table></figure><h3 id="6-4-稀疏数组"><a href="#6-4-稀疏数组" class="headerlink" title="6.4 稀疏数组"></a>6.4 稀疏数组</h3><ul><li>数组元素的索引必须是连续的数字！</li><li>如果隔着索引对数组元素进行赋值，会变为<strong>稀疏数组</strong>； 中间跨过去的索引也会自动填充，只是都没有值。</li></ul><h3 id="6-5-数组的遍历-迭代"><a href="#6-5-数组的遍历-迭代" class="headerlink" title="6.5 数组的遍历(迭代)"></a>6.5 数组的遍历(迭代)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个数组</span><br><span class="hljs-keyword">var</span> nameList = [<span class="hljs-string">&#x27;独孤奶奶&#x27;</span>, <span class="hljs-string">&#x27;欧阳奶奶&#x27;</span>, <span class="hljs-string">&#x27;东方奶奶&#x27;</span>, <span class="hljs-string">&#x27;西门奶奶&#x27;</span>, <span class="hljs-string">&#x27;慕容奶奶&#x27;</span>];<br><br><span class="hljs-comment">// 使用 for 循环遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nameList.length; i ++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i, nameList[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用 for in 遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> nameList) &#123;<br>    <span class="hljs-built_in">console</span>.log(i, nameList[i]);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>更推荐使用 for 循环遍历数组！</p></blockquote><h3 id="6-6-数组元素的添加和删除"><a href="#6-6-数组元素的添加和删除" class="headerlink" title="6.6 数组元素的添加和删除"></a>6.6 数组元素的添加和删除</h3><h4 id="①-添加元素"><a href="#①-添加元素" class="headerlink" title="① 添加元素"></a>① 添加元素</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">1. 通过指定索引  <span class="hljs-selector-tag">arr</span><span class="hljs-selector-attr">[23]</span> 保证索是下一个，否则出现稀疏数组<br>2. 利用 <span class="hljs-selector-tag">length</span>， <span class="hljs-selector-tag">arr</span><span class="hljs-selector-attr">[arr.length]</span>； <span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.length</span> 就是下一个索引。<br>3. <span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.push</span>()在数组的最后面添加一个或多个元素<br>4. <span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.unshift</span>()在数组的最前面添加一个或多个元素<br>5. <span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.splice</span>(索引, 0, 新元素...)在数组的指定位置添加一个或多个元素<br></code></pre></td></tr></table></figure><h4 id="②-删除元素"><a href="#②-删除元素" class="headerlink" title="② 删除元素"></a>② 删除元素</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">1</span>. 通过修改 <span class="hljs-built_in">length</span> 的值删除后面的元素； arr.<span class="hljs-built_in">length</span> -= <span class="hljs-number">1</span> 删除最后一个， arr.<span class="hljs-built_in">length</span> -= <span class="hljs-number">2</span> 删除最后<span class="hljs-number">2</span>个<br><span class="hljs-number">2</span>. arr.<span class="hljs-built_in">pop</span>()删除数组最后一个元素，一次只能删一个<br><span class="hljs-number">3</span>. arr.shift()删除数组第一个元素，一次只能删除一个<br><span class="hljs-number">4</span>. arr.<span class="hljs-built_in">splice</span>(索引，数量)删除数组中指定位置以及数量的元素。<br></code></pre></td></tr></table></figure><h3 id="6-7-多维数组"><a href="#6-7-多维数组" class="headerlink" title="6.7 多维数组"></a>6.7 多维数组</h3><p>数组的元素还是数组，成为多维数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrs = [<br>    [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">4000</span>], <br>    [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>], <br>    <span class="hljs-number">10000</span>, <br>    <span class="hljs-string">&#x27;hello&#x27;</span>, <br>    [],<br>    [<br>        [<span class="hljs-string">&#x27;司马奶奶&#x27;</span>, <span class="hljs-string">&#x27;诸葛奶奶&#x27;</span>, <span class="hljs-string">&#x27;夏侯奶奶&#x27;</span>],<br>        [<span class="hljs-string">&#x27;东方姥姥&#x27;</span>, <span class="hljs-string">&#x27;令狐姥姥&#x27;</span>]<br>    ]<br>];<br><br><br><span class="hljs-built_in">console</span>.log(arrs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);   <span class="hljs-comment">// 300</span><br><span class="hljs-built_in">console</span>.log(arrs[<span class="hljs-number">5</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 诸葛奶奶</span><br><span class="hljs-built_in">console</span>.log(arrs[<span class="hljs-number">5</span>][<span class="hljs-number">1</span>]);  <span class="hljs-comment">// [&#x27;东方姥姥&#x27;, &#x27;令狐姥姥&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="6-8-字符串的数组特性"><a href="#6-8-字符串的数组特性" class="headerlink" title="6.8 字符串的数组特性"></a>6.8 字符串的数组特性</h3><ul><li>字符串具有与数组相似的结构，可以认为字符串时字符的有序集合、</li><li>字符串中每个字符也有索引，从 0 开始，通过 <code>[]</code> 可以读取到指定索引的字符。（只能读取无法修改）</li><li>字符串也具有 <code>length</code> 属性，可以获取字符串的长度（字符的个数）。（length 只能读取）</li><li>向字符串这种，不是数组但是却具有数组的某些特性，称之为 <strong>类数组</strong> 或 <strong>伪数组</strong>。</li></ul><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h2><h3 id="7-1-函数概述"><a href="#7-1-函数概述" class="headerlink" title="7.1 函数概述"></a>7.1 函数概述</h3><h4 id="①-什么是函数"><a href="#①-什么是函数" class="headerlink" title="① 什么是函数"></a>① 什么是函数</h4><p><strong>函数</strong>具有某种<strong>特定功能</strong>的代码块。</p><p><strong>函数</strong>是 JavaScript 中的一种<strong>数据类型</strong>，属于<strong>对象类型</strong>，使用 <code>typeof</code> 判断函数的类型返回 <code>function</code>。</p><h4 id="②-函数的作用"><a href="#②-函数的作用" class="headerlink" title="② 函数的作用"></a>② 函数的作用</h4><p>避免代码重复冗余，提高代码重用性。</p><h4 id="③-函数的组成"><a href="#③-函数的组成" class="headerlink" title="③ 函数的组成"></a>③ 函数的组成</h4><h3 id="7-2-声明函数的三种方式"><a href="#7-2-声明函数的三种方式" class="headerlink" title="7.2 声明函数的三种方式"></a>7.2 声明函数的三种方式</h3><blockquote><p><strong>注意：</strong></p><p>函数名的命名规范同变量名一致，因为本质上函数名就是变量名。</p></blockquote><h4 id="①-function-关键字方式"><a href="#①-function-关键字方式" class="headerlink" title="① function 关键字方式"></a>① function 关键字方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">[参数列表...]</span>) </span>&#123;<br>    函数体语句;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-表达式方式"><a href="#②-表达式方式" class="headerlink" title="② 表达式方式"></a>② 表达式方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 函数名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">[参数列表...]</span>)</span>&#123;<br>    函数体语句;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-Function-构造函数方式-基本不用"><a href="#③-Function-构造函数方式-基本不用" class="headerlink" title="③ Function 构造函数方式 (基本不用)"></a>③ Function 构造函数方式 (基本不用)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 函数名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;参数1&#x27;</span>, <span class="hljs-string">&#x27;参数2&#x27;</span>， <span class="hljs-string">&#x27;参数3&#x27;</span>, <span class="hljs-string">&#x27;函数体语句;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="7-3-函数的调用和返回值"><a href="#7-3-函数的调用和返回值" class="headerlink" title="7.3 函数的调用和返回值"></a>7.3 函数的调用和返回值</h3><h4 id="①-函数调用"><a href="#①-函数调用" class="headerlink" title="① 函数调用"></a>① 函数调用</h4><ul><li>函数名加 <code>()</code> 才是调用函数，只有调用函数，函数内的代码才执行。</li><li>函数名后面没有 <code>()</code>，这就是在使用变量的值，值就是一个 function 类型的数据（函数本身），不会调用函数。</li></ul><h4 id="②-返回值"><a href="#②-返回值" class="headerlink" title="② 返回值"></a>② 返回值</h4><ul><li>函数调用表达式的值就是函数的返回值，只有调用函数才能得到返回值。</li><li>函数体内通过 <code>return</code> 返回，<code>return</code> 的右边可以写一个表达式，表达式的值就函数的返回值。</li><li>如果函数体内没有 <code>return</code> 语句 或者 <code>return</code> 的右边是空的， 默认函数返回 <code>undefiend</code>。</li><li><code>return</code> 除了能返回一个值，还可以中断函数的执行（执行到 <code>return</code>）。</li></ul><h3 id="7-4-函数的参数"><a href="#7-4-函数的参数" class="headerlink" title="7.4 函数的参数"></a>7.4 函数的参数</h3><h4 id="①-形参和实参"><a href="#①-形参和实参" class="headerlink" title="① 形参和实参"></a>① 形参和实参</h4><p><strong>形参：</strong> 声明函数时给的参数就是形参；形参相当于变量，调用的时候才能赋值； 形参只能在函数里用；形参的形式只能是变量名。</p><p><strong>实参：</strong> 调用函数时给的参数，实参会按照顺序赋值给对应的形参； 实参的形式可以是直接量、变量或表达式。</p><h4 id="②-形参和实参的数量问题"><a href="#②-形参和实参的数量问题" class="headerlink" title="② 形参和实参的数量问题"></a>② 形参和实参的数量问题</h4><ul><li>实参给多了，实参数量&gt;形参数量，多给的白给。</li><li>实参给少了，实参数量&lt;形参数量，意味着有些形参无法被赋值，默认取值 undefined</li></ul><h4 id="③-形参的默认值（可选参数）"><a href="#③-形参的默认值（可选参数）" class="headerlink" title="③ 形参的默认值（可选参数）"></a>③ 形参的默认值（可选参数）</h4><p><strong>设置方式一：在函数体内判断参数的值是否是 undefined</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, c,</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (c === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        c = <span class="hljs-string">&#x27;默认值&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置方式二：</strong>(ES6 新增，兼容性并太好)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a,b,c = <span class="hljs-string">&#x27;默认值&#x27;</span></span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>不论是哪种方式给参数设置默认值，有默认值的参数应该在后面。</p><p>有默认值的参数称之为可选参数，意味着调用函数的时候可以没有与之对应的实参。</p></blockquote><h4 id="④-arguments"><a href="#④-arguments" class="headerlink" title="④ arguments"></a>④ arguments</h4><ul><li>arguments 只能在函数内使用。</li><li>arguments 是个伪数组，同数组类似具有 <code>length</code> 属性，也可以通过索引获取其中的成员，也可以用 for 循环遍历。</li><li>arguments 是由调用函数时给的实参组成的集合， 通过 arguments 可以获取调用函数时给的实参。</li></ul><blockquote><p><strong>arguments 和 形参:</strong></p><ul><li>arguments 和 形参都可以获取到调用函数时给的实参。</li><li>如果声明函数的时候，明确的知道需要几个参数，就使用形参； 如果是<strong>可变参数数量的函数</strong>，使用 arguments。</li></ul></blockquote><h3 id="7-5-作用域"><a href="#7-5-作用域" class="headerlink" title="7.5 作用域"></a>7.5 作用域</h3><h4 id="①-变量的作用域"><a href="#①-变量的作用域" class="headerlink" title="① 变量的作用域"></a>① 变量的作用域</h4><p><strong>作用域：</strong> 变量的可作用范围称之为作用域； 根据作用域可以把变量分支全局变量和局部变量。</p><p><strong>全局变量：</strong> 定义在函数外面的变量就是全局变量，作用域是全局的，任何地方都可以使用该变量。</p><p><strong>局部变量：</strong> 定义在函数内的变量就是局部变量，作用域是本函数，仅限本函数内使用。</p><blockquote><p><strong>注意：</strong></p><ol><li>函数名本质是个变量，所以函数本身也有作用域、</li><li>形参是局部变量，作用域是所在的函数。</li></ol></blockquote><h4 id="②-作用域链"><a href="#②-作用域链" class="headerlink" title="② 作用域链"></a>② 作用域链</h4><p><strong>作用域链：</strong> A嵌套函数B，函数A的作用域是函数B作用域的上层作用域，层层嵌套形成作用域链。</p><p><strong>作用域链的作用：</strong> 当使用一个变量的时候，会先从本作用域下查找，如果没有再从上层作用域查找，一直找到全局作用域，哪里找到哪里停止，一直找不到报错。</p><p><strong><font color="red">作用域只与函数声明的位置有关系，与函数调用的位置无关</font></strong></p><h3 id="7-6-变量提升"><a href="#7-6-变量提升" class="headerlink" title="7.6 变量提升"></a>7.6 变量提升</h3><h4 id="①-变量提升"><a href="#①-变量提升" class="headerlink" title="① 变量提升"></a>① 变量提升</h4><p>在正式执行代码之前，进行与解析； 预解析的时候会对变量进行提升； 把变量提升到本作用域的最前面； </p><p>但是变量的提升值提升变量的声明，不会提升赋值，赋值操作需要等到正式执行相关代码。 </p><h4 id="②-函数提升"><a href="#②-函数提升" class="headerlink" title="② 函数提升"></a>② 函数提升</h4><p>相对于普通的变量提升，如果是function关键字方式声明的函数，会在代码正式执行之前把函数的声明以及函数的值都提升到本作用域最前面。</p><p>如果是表达式方式或者 <code>Function</code> 构造函数方式声明的函数，提升方式与普通变量一样，值提升函数的声明，不提升值。</p><p>由于函数提升的时候比较彻底，所以正式执行到函数声明语句的时候会跳过。</p><p>函数的提升认为比普通变量的提升权重高，即使同名的遍历声明代码写在函数声明代码的后代，提升还是函数。</p><h3 id="7-7-自调用函数"><a href="#7-7-自调用函数" class="headerlink" title="7.7 自调用函数"></a>7.7 自调用函数</h3><h4 id="①-匿名函数"><a href="#①-匿名函数" class="headerlink" title="① 匿名函数"></a>① 匿名函数</h4><p>匿名函数就是没有名字的函数，也就是函数直接量。</p><p>匿名函数一般作为自调用函数或回调函数。</p><h4 id="②-自调用函数"><a href="#②-自调用函数" class="headerlink" title="② 自调用函数"></a>② 自调用函数</h4><p>简称 <strong>IIFE</strong>，英文全称 <strong>Immediately Invoked Function Expression</strong>。</p><p>自调用函数就是函数声明完立即调用的函数。</p><p>不论是匿名函数还是有名字的函数都可以自调用，一般匿名函数为主。</p><p>自调用函数用于产生作用域，避免全局变量，以免全局变量污染。</p><h3 id="7-8-回调函数"><a href="#7-8-回调函数" class="headerlink" title="7.8 回调函数"></a>7.8 回调函数</h3><h4 id="①-什么是回调函数"><a href="#①-什么是回调函数" class="headerlink" title="① 什么是回调函数"></a>① 什么是回调函数</h4><ol><li>我定义的</li><li>我没有直接调用</li><li>最后函数却执行了</li></ol><p>满足以上三个条件的函数，称之为回调函数。</p><h4 id="②-回调函数的使用场景"><a href="#②-回调函数的使用场景" class="headerlink" title="② 回调函数的使用场景"></a>② 回调函数的使用场景</h4><ul><li>事件的回调函数</li><li>定时器的回调函数</li><li>ajax 的回调函数</li><li>生命周期钩子函数</li><li>一些系统内置的函数或方法，需要回调函数作为参数。</li></ul><blockquote><p><strong>注意：</strong></p><p>匿名非常适合作为回调函数。</p></blockquote><h3 id="7-9-递归函数"><a href="#7-9-递归函数" class="headerlink" title="7.9 递归函数"></a>7.9 递归函数</h3><h4 id="①-什么是递归函数"><a href="#①-什么是递归函数" class="headerlink" title="① 什么是递归函数"></a>① 什么是递归函数</h4><p>函数内调用自己，我们成为函数的<strong>递归调用</strong>， 这样的函数称为<strong>递归函数</strong>。</p><h4 id="②-递归函数成功的条件"><a href="#②-递归函数成功的条件" class="headerlink" title="② 递归函数成功的条件"></a>② 递归函数成功的条件</h4><ul><li>函数内必须有明确的递归结束条件。</li><li>随着递归次数的增加，应该越来与接近递归的结束条件。</li></ul><h4 id="③-递归函数的缺点"><a href="#③-递归函数的缺点" class="headerlink" title="③ 递归函数的缺点"></a>③ 递归函数的缺点</h4><ul><li>递归函数容易造成内存泄漏。</li><li>递归函数效率很低，能用循环做就使用循环。</li></ul><h4 id="④-递归函数应用场景"><a href="#④-递归函数应用场景" class="headerlink" title="④ 递归函数应用场景"></a>④ 递归函数应用场景</h4><ul><li>后端程序处理目录，删除目录、复制目录、剪切目录等。</li><li>前端处理从后端得到 json 数据。</li></ul><h2 id="8-对象"><a href="#8-对象" class="headerlink" title="8 对象"></a>8 对象</h2><h3 id="8-1-对象的概念"><a href="#8-1-对象的概念" class="headerlink" title="8.1 对象的概念"></a>8.1 对象的概念</h3><p><strong>广义的理解：</strong> 一切皆对象，数组、函数都是对象的一种。</p><p><strong>狭义的理解：</strong> Object 数据类型，是对象类型中的一种，与Array、Function是等价的。</p><h3 id="8-2-Object类型"><a href="#8-2-Object类型" class="headerlink" title="8.2 Object类型"></a>8.2 Object类型</h3><h4 id="8-2-1-什么是-Object"><a href="#8-2-1-什么是-Object" class="headerlink" title="8.2.1 什么是 Object"></a>8.2.1 什么是 Object</h4><p>Object 是值的无序集合。</p><p>Object 由属性组成，组成有属性名也有属性值，属性值可以是任意类型的数据。</p><p>如果属性值的类型是 function，可以称这种属性是方法。</p><h4 id="8-2-2-如何声明-Object-对象"><a href="#8-2-2-如何声明-Object-对象" class="headerlink" title="8.2.2 如何声明 Object 对象"></a>8.2.2 如何声明 Object 对象</h4><h5 id="①-第一种-直接量方式"><a href="#①-第一种-直接量方式" class="headerlink" title="① 第一种 直接量方式"></a>① 第一种 直接量方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一种方式 直接量方式创建对象</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    name: <span class="hljs-string">&#x27;朦朦&#x27;</span>, <br>    age: <span class="hljs-number">18</span>, <br>    address: <span class="hljs-string">&#x27;上海&#x27;</span>, <br>    infos: [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>], <br>    getInfo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 给创建好的对象添加属性</span><br>obj1.grade = <span class="hljs-string">&#x27;100&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> obj1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="②-使用-Object-函数"><a href="#②-使用-Object-函数" class="headerlink" title="② 使用 Object 函数"></a>② 使用 Object 函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第二种方式  Object 函数</span><br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 给创建好的对象添加属性</span><br>obj2.name = <span class="hljs-string">&#x27;小乐&#x27;</span>;<br>obj2.address = <span class="hljs-string">&#x27;上海&#x27;</span>;<br>obj2.getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="③-使用-Object-构造函数"><a href="#③-使用-Object-构造函数" class="headerlink" title="③ 使用 Object 构造函数"></a>③ 使用 Object 构造函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">/ 第三种方式 <span class="hljs-built_in">Object</span> 构造函数函数<br><span class="hljs-keyword">var</span> obj3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 给创建好的对象添加属性</span><br>obj3.username = <span class="hljs-string">&#x27;admin&#x27;</span>;<br>obj3.password = <span class="hljs-string">&#x27;1234565&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h4 id="8-2-3-属性操作"><a href="#8-2-3-属性操作" class="headerlink" title="8.2.3 属性操作"></a>8.2.3 属性操作</h4><h4 id="1-Object-对象属性的读写"><a href="#1-Object-对象属性的读写" class="headerlink" title="(1) Object 对象属性的读写"></a>(1) Object 对象属性的读写</h4><h5 id="①-语法"><a href="#①-语法" class="headerlink" title="① 语法"></a>① 语法</h5><ol><li>对象的属性名没有规则，属性名应该以字符串的形式（加引号）给出，但是如果属性名满足标识符命名规范，可以省略字符串的引号。</li><li>可以使用 <code>.</code> 语法或 <code>[]</code> 语法读写对象中的属性； 读取不存在的属性返回 undefined ；给不存在的属性赋值会添加新属性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> obj = &#123;<br>     name: <span class="hljs-string">&#x27;朦朦&#x27;</span>,<br>     $age: <span class="hljs-number">19</span>,<br>     <span class="hljs-string">&#x27;10abc&#x27;</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>,<br>     <span class="hljs-string">&#x27;地址&#x27;</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>     getInfo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get Info&#x27;</span>);<br>     &#125;,<br>     <span class="hljs-string">&#x27;get-name&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get-name&#x27;</span>);<br>     &#125;<br> &#125;;<br><br> <span class="hljs-comment">// 读写 object 对象的属性， . 语法  [] 语法</span><br><span class="hljs-built_in">console</span>.log(obj.name);<br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">&#x27;name&#x27;</span>]);<br><br><span class="hljs-comment">// 必须使用 [] 语法读写属性的第一种情况： 属性名不符合标识符命名规范</span><br><span class="hljs-comment">// obj.10abc;</span><br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">&#x27;10abc&#x27;</span>]);<br><br><span class="hljs-comment">// 必须使用 [] 语法读写属性的第二种情况： 用变量表示属性名</span><br><span class="hljs-keyword">var</span> prop = <span class="hljs-string">&#x27;$age&#x27;</span>;<br><span class="hljs-comment">// console.log(obj.prop);</span><br><span class="hljs-built_in">console</span>.log(obj[prop]);<br><br><br><span class="hljs-comment">// 给已经存在属性重复赋值</span><br>obj[<span class="hljs-string">&#x27;地址&#x27;</span>] = <span class="hljs-string">&#x27;北京&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="②-什么情况下必须使用-语法读写属性"><a href="#②-什么情况下必须使用-语法读写属性" class="headerlink" title="② 什么情况下必须使用 [] 语法读写属性"></a>② 什么情况下必须使用 [] 语法读写属性</h5><ol><li>情况一： 属性名不符合标识符命名规范</li><li>情况二： 用变量表示属性名。</li></ol><h4 id="2-遍历对象的属性"><a href="#2-遍历对象的属性" class="headerlink" title="(2) 遍历对象的属性"></a>(2) 遍历对象的属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// for in  遍历 Object 对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-built_in">console</span>.log(i, obj[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-删除对象中的属性"><a href="#3-删除对象中的属性" class="headerlink" title="(3) 删除对象中的属性"></a>(3) 删除对象中的属性</h4><p>使用 delete 运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> obj.属性名;<br><span class="hljs-keyword">delete</span> obj[<span class="hljs-string">&#x27;属性名&#x27;</span>];<br></code></pre></td></tr></table></figure><h4 id="4-判断对象中是否存在某个属性"><a href="#4-判断对象中是否存在某个属性" class="headerlink" title="(4) 判断对象中是否存在某个属性"></a>(4) 判断对象中是否存在某个属性</h4><p>使用 in 运算符，是二元运算符，组成的表达式返回布尔值。</p><p>属性名必须以字符串的形式给出。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;属性名&#x27; in 对象<br></code></pre></td></tr></table></figure><h3 id="8-3-构造函数"><a href="#8-3-构造函数" class="headerlink" title="8.3 构造函数"></a>8.3 构造函数</h3><h4 id="8-3-1-什么是构造函数？"><a href="#8-3-1-什么是构造函数？" class="headerlink" title="8.3.1 什么是构造函数？"></a>8.3.1 什么是构造函数？</h4><ul><li>构造函数是用来构造对象的函数，相当于其他编程语言的<strong>类</strong>。</li><li>构造函数仍然是个函数，是普通函数还是构造函数，取决于怎么使用。</li><li>构造函数与数据类型是等价的，相同数据类型的数据（对象），构造函数也一样。</li></ul><h4 id="8-3-2-构造函数和对象的关系"><a href="#8-3-2-构造函数和对象的关系" class="headerlink" title="8.3.2 构造函数和对象的关系"></a>8.3.2 构造函数和对象的关系</h4><ul><li>构造函数是对象的抽象（描述），对象是构造函数的实例。</li><li>一个构造函数可以对应多个对象，而一个对象只能有一个构造函数。</li></ul><h4 id="8-3-3-判断对象的构造函数"><a href="#8-3-3-判断对象的构造函数" class="headerlink" title="8.3.3 判断对象的构造函数"></a>8.3.3 判断对象的构造函数</h4><h4 id="①-运算符-instanceof"><a href="#①-运算符-instanceof" class="headerlink" title="① 运算符 instanceof"></a>① 运算符 instanceof</h4><p>是一个二元运算符，左边的操作数是对象，右边的操作数是构造函数； 组成的表达式返回布尔值。</p><h4 id="②-constructor-属性"><a href="#②-constructor-属性" class="headerlink" title="② constructor 属性"></a>② constructor 属性</h4><p>所有的对象都有具有 <code>constructor</code> 属性，该属性是系统自动添加的；可以得到对象的构造函数。</p><h4 id="8-3-4-自定义构造函数"><a href="#8-3-4-自定义构造函数" class="headerlink" title="8.3.4 自定义构造函数"></a>8.3.4 自定义构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">username, age, address</span>) </span>&#123;<br>    <span class="hljs-comment">// 添加属性</span><br>    <span class="hljs-built_in">this</span>.name = username;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.address = address;<br><br>    <span class="hljs-comment">// 添加方法</span><br>    <span class="hljs-built_in">this</span>.getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我叫&#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;，我今年&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;岁，我住在&#x27;</span> + <span class="hljs-built_in">this</span>.address);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>this 表示构造函数将来实例化的对象，this 是动态的，在实例化的时候动态决定。</p></blockquote><h4 id="8-3-5-实例化"><a href="#8-3-5-实例化" class="headerlink" title="8.3.5 实例化"></a>8.3.5 实例化</h4><ol><li>通过 <code>new 构造函数()</code> 可以实例化出一个对象</li><li>每实例化一次构造函数，就产生一个新的对象（内存中会开辟新的空间），一个构造函数可以实例化无数个对象。</li><li>实例化构造函数的时候，可以传递产生，如果没有参数，可以省略<code>()</code>。</li></ol><h3 id="8-4-this"><a href="#8-4-this" class="headerlink" title="8.4 this"></a>8.4 this</h3><h4 id="8-4-1-this-的含义"><a href="#8-4-1-this-的含义" class="headerlink" title="8.4.1 this 的含义"></a>8.4.1 this 的含义</h4><p>this 是内置的一个关键字，this 的值通常是一个 对象</p><p>this 的值是动态的，会在执行代码的时候动态决定。</p><h4 id="8-4-2-this-的指向"><a href="#8-4-2-this-的指向" class="headerlink" title="8.4.2 this 的指向"></a>8.4.2 this 的指向</h4><p>this 的指向分两种情况：</p><p>第一种情况：在构造函数中使用（new 后面的函数就是构造函数）， this 指向实例化产生的<strong>新对象</strong>。</p><p>第二种情况：在方法或函数中（调用就说明是方法或函数），this 指向调用该方法的对象。</p><h4 id="8-4-3-window-介绍"><a href="#8-4-3-window-介绍" class="headerlink" title="8.4.3 window 介绍"></a>8.4.3 window 介绍</h4><p>window 是JS中的全局对象， 全局的变量和函数本质上是window的一个方法，使用window的属性或方法的时候，可以省略 <code>window.</code></p><h3 id="8-5-原型"><a href="#8-5-原型" class="headerlink" title="8.5 原型"></a>8.5 原型</h3><h4 id="8-5-1-原型的概念"><a href="#8-5-1-原型的概念" class="headerlink" title="8.5.1 原型的概念"></a>8.5.1 原型的概念</h4><p>每一个对象都有一个原型，原型也是个对象。</p><p>对象可以继承（使用）原型上的属性和方法。</p><h4 id="8-5-2-如何获取对象的原型"><a href="#8-5-2-如何获取对象的原型" class="headerlink" title="8.5.2 如何获取对象的原型"></a>8.5.2 如何获取对象的原型</h4><h4 id="①-隐式原型方式"><a href="#①-隐式原型方式" class="headerlink" title="① 隐式原型方式"></a>① 隐式原型方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.__proto__<br></code></pre></td></tr></table></figure><p>通过对象自身的 <code>__proto__</code> 属性获取对象的原型。</p><h4 id="②-显示原型方式"><a href="#②-显示原型方式" class="headerlink" title="② 显示原型方式"></a>② 显示原型方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">构造函数.prototype<br></code></pre></td></tr></table></figure><p>通过对象构造函数的 <code>prototype</code> 属性来获取该对象的原型。</p><blockquote><p>说明具有相同构造函数的对象，原型也是一样的。</p></blockquote><h4 id="8-5-3-对象、构造函数、原型之间的关系"><a href="#8-5-3-对象、构造函数、原型之间的关系" class="headerlink" title="8.5.3 对象、构造函数、原型之间的关系"></a>8.5.3 对象、构造函数、原型之间的关系</h4><h4 id="①-对象和构造函数"><a href="#①-对象和构造函数" class="headerlink" title="① 对象和构造函数"></a>① 对象和构造函数</h4><p>对象是构造函数的实例，构造函数是对象的抽象（描述）。</p><h4 id="②-对象和原型"><a href="#②-对象和原型" class="headerlink" title="② 对象和原型"></a>② 对象和原型</h4><p>每个对象都有原型，对象可以继承原型上的属性和方法。</p><h4 id="③-构造函数和原型"><a href="#③-构造函数和原型" class="headerlink" title="③ 构造函数和原型"></a>③ 构造函数和原型</h4><p>具有相同构造函数的对象，原型也是一样的。</p><p>通过 <code>构造函数.prototype</code> 可以获取构造函数实例的原型。</p><h4 id="8-5-4-原型的应用"><a href="#8-5-4-原型的应用" class="headerlink" title="8.5.4 原型的应用"></a>8.5.4 原型的应用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, age, address</span>) </span>&#123;<br>    <span class="hljs-comment">// 属性</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br><br><span class="hljs-comment">// 把方法添加到实例的原型上</span><br>User.prototype.login = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; 登录了&#x27;</span>);<br>&#125;<br>User.prototype.logout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; 退出登录了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义构造函数的时候，通常通过 this 对象设置属性，方法添加到原型上； 得到实例之后，属性会存储在对象本身上，方法存储在原型对象上。</p><p>一般，相同类型的对象属性的值往往是不同的，但是方法的语句是一致的。</p><p>这么做可以减少内存存储空间。</p><h4 id="8-5-5-判断属性是否属于对象本身"><a href="#8-5-5-判断属性是否属于对象本身" class="headerlink" title="8.5.5 判断属性是否属于对象本身"></a>8.5.5 判断属性是否属于对象本身</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">对象.hasOwnPorperty(<span class="hljs-string">&#x27;属性名&#x27;</span>)返回布尔值<br></code></pre></td></tr></table></figure><blockquote><p>判断属性是否在对象本身上，如果在对象本身山返回 true。 在原型上的属性或者原型上也没有返回 false。</p></blockquote><h4 id="8-5-6-创建对象的同时指定原型"><a href="#8-5-6-创建对象的同时指定原型" class="headerlink" title="8.5.6 创建对象的同时指定原型"></a>8.5.6 创建对象的同时指定原型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建对象的同时指定对象的原型</span><br><span class="hljs-comment">// a 对象的原型就是 b</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(b);<br><br><br><span class="hljs-comment">// 创建没有原型的对象</span><br><span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><h3 id="8-6-原型链"><a href="#8-6-原型链" class="headerlink" title="8.6 原型链"></a>8.6 原型链</h3><h4 id="8-6-1-原型链的概念"><a href="#8-6-1-原型链的概念" class="headerlink" title="8.6.1 原型链的概念"></a>8.6.1 原型链的概念</h4><p>对象有原型，原型也是个对象，原型也有原型，一直到一个顶层原型对象（一个没有原型的对象），构成了一条原型链。</p><h4 id="8-6-2-属性查找过程"><a href="#8-6-2-属性查找过程" class="headerlink" title="8.6.2 属性查找过程"></a>8.6.2 属性查找过程</h4><p>当使用对象中的一个属性的时候，先从对象本身查找，如果找不到，取对象的原型上查找，如果还找不到继续沿着原型链向上查找，哪里找到哪里停止，一直到找到厅层原型对象，如果都没有自动得到 undefined。</p><h4 id="8-6-3-构造函数和原型链"><a href="#8-6-3-构造函数和原型链" class="headerlink" title="8.6.3 构造函数和原型链"></a>8.6.3 构造函数和原型链</h4><ol><li>对象的构造函数和原型绝对不是一回事。</li><li>没有经过特殊初始的内置类型的对象，原型都是 Object 的一个实例。 字符串对象的原型是Object的一个实例、数组对象的原型也是Object的一个实例。</li><li>构造函数本身也是一个函数类型的对象，也有自己的原型（Object的一个实例），也有自己的构造函数（Function）；  <code>构造函数.prototype</code> 获取的是构造函数实例的原型，<code>构造函数.__proto__</code> 获取的是自己的原型，二者完全不是一回事。</li><li>Function 的构造函数是本身，自己构造了自己， <code>Function.prototype ===  Function.__proto__</code> 是成立。</li><li>作为原型的对象，里面的 <code>constructor</code> 属性指向的不是自己的构造函数，指向的是以该原型对象为原型的对象的构造函数。</li></ol><h3 id="8-7-数据类型的其他分类方式"><a href="#8-7-数据类型的其他分类方式" class="headerlink" title="8.7 数据类型的其他分类方式"></a>8.7 数据类型的其他分类方式</h3><h4 id="8-7-1-值类型和引用类型"><a href="#8-7-1-值类型和引用类型" class="headerlink" title="8.7.1 值类型和引用类型"></a>8.7.1 值类型和引用类型</h4><p><strong>值类型：</strong> 原始类型的数据也称为值类型。 值类型的传递方式是值传递。</p><p><strong>引用类型：</strong> 对象类型的数据也称之为引用类型。引用类型的传递方式是引用传递（地址传递）。</p><blockquote><p>内存原理：</p><p>内存中分为栈结构和堆结构； 创建一个变量的时候，变量的名字会存在栈解构中，变量的值如果是原始类型（值类型）就会与变量一起存在栈结构中； 变量的值如果是对象类型（引用类型），值存在堆中，栈结构中存的是值的地址。</p></blockquote><blockquote><p><strong>注意：</strong></p><p>一个值是引用类型的变量，如果对变量重新赋值，原来的引用关系会被修改！</p></blockquote><h4 id="8-7-2-不可变类型和可变类型"><a href="#8-7-2-不可变类型和可变类型" class="headerlink" title="8.7.2 不可变类型和可变类型"></a>8.7.2 不可变类型和可变类型</h4><p><strong>不可变类型：</strong> 就是原始类型（值类型），整个数据就是一个整体，不能修改其中的一部分。</p><p><strong>可变类型：</strong> 就是对象类型（引用类型），可以修改数据中的一部分（属性的值）。</p><h2 id="9-内置对象"><a href="#9-内置对象" class="headerlink" title="9 内置对象"></a>9 内置对象</h2><h3 id="9-1-Boolean"><a href="#9-1-Boolean" class="headerlink" title="9.1 Boolean"></a>9.1 Boolean</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ① 直接量方式</span><br><span class="hljs-keyword">var</span> b1 = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// ② Boolean 函数</span><br><span class="hljs-keyword">var</span> b2 = <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// ③ Boolean 构造函数</span><br><span class="hljs-keyword">var</span> b3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="9-2-Number"><a href="#9-2-Number" class="headerlink" title="9.2 Number"></a>9.2 Number</h3><h4 id="①-构造函数本身的属性和方法"><a href="#①-构造函数本身的属性和方法" class="headerlink" title="① 构造函数本身的属性和方法"></a>① 构造函数本身的属性和方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Number</span>.MAX_VALUE获取 JS 中能表示的最大的数<br><span class="hljs-built_in">Number</span>.MIN_VALUE获取 JS 中能表示的最小的数<br></code></pre></td></tr></table></figure><h4 id="②-实例的属性和方法"><a href="#②-实例的属性和方法" class="headerlink" title="② 实例的属性和方法"></a>② 实例的属性和方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">toFixed</span><span class="hljs-params">()</span></span>保留指定位数的小数，默认取整，参数指定小数位数<br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span>返回数字的字符串形式，可以指定参数，参数表示进制<br></code></pre></td></tr></table></figure><h2 id="9-3-String"><a href="#9-3-String" class="headerlink" title="9.3 String"></a>9.3 String</h2><h4 id="构造函数本身的属性和方法"><a href="#构造函数本身的属性和方法" class="headerlink" title="构造函数本身的属性和方法"></a>构造函数本身的属性和方法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>from<span class="hljs-constructor">CharCode(编码)</span>指定编码（数字），返回编码对应的字符。<br></code></pre></td></tr></table></figure><h4 id="实例的属性和方法"><a href="#实例的属性和方法" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">length属性，得到字符串的长度（字符串的个数），只读。<br><br>index<span class="hljs-constructor">Of(<span class="hljs-params">val</span>)</span>返回 <span class="hljs-keyword">val</span> 在字符串中第一次出现的位置（索引），如果不包含 <span class="hljs-keyword">val</span>，返回 -<span class="hljs-number">1</span><br><br>last<span class="hljs-constructor">IndexOf(<span class="hljs-params">val</span>)</span>返回 <span class="hljs-keyword">val</span> 在字符串中最后一次出现的位置（索引），如果不包含 <span class="hljs-keyword">val</span>，返回 -<span class="hljs-number">1</span><br><br>slice(start <span class="hljs-literal">[,<span class="hljs-identifier">end</span>]</span>)截取字符串，第一个参数指定开始截取的位置，第二个参数指定结束位置；顾头不顾尾（<span class="hljs-keyword">end</span>对应的字符不会被截取）；如果不指定第二个参数，一直截取到最后。<br><br>substring<span class="hljs-literal">()</span>同 slice<br><br>substr(start <span class="hljs-literal">[,<span class="hljs-identifier">length</span>]</span>)截取字符串，第一个参数指定开始截取的位置，第二个参数指定要截取的长度；如果不指定第二个参数，一直截取到最后。<br><br>split(<span class="hljs-literal">[分隔符]</span>)把字符串分隔为数组，参数指定分隔符。<br><br><span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>返回转为大写的字符串<br><br><span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>返回转为小写的字符串<br><br><span class="hljs-built_in">char</span><span class="hljs-constructor">CodeAt(<span class="hljs-params">index</span>)</span>返回索引对应的字符的 unicode 编码<br></code></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong></p><p><code>indexOf()</code> 和 <code>lastIndexOf() </code>通常用来判断字符串中是否包含某个值</p></blockquote><h2 id="9-4-Math"><a href="#9-4-Math" class="headerlink" title="9.4 Math"></a>9.4 Math</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Math.PI属性，圆周率<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span>返回指定数字的绝对值<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sqrt<span class="hljs-literal">()</span>返回指定数字的平方根<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>pow(x, y)返回 x 的 y 次方<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max<span class="hljs-literal">()</span>返回所有参数中最大的<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min<span class="hljs-literal">()</span>返回所有参数中最小的<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round<span class="hljs-literal">()</span>四舍五入取整<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor<span class="hljs-literal">()</span>舍一取整<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil<span class="hljs-literal">()</span>进一取整<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span>取随机数，随机范围：<span class="hljs-number">0</span>~<span class="hljs-number">1</span> 之间的小数； <span class="hljs-number">0</span> 有一定的概率被取到，<span class="hljs-number">1</span> 绝无可能。<br></code></pre></td></tr></table></figure><blockquote><p><code>Math.floor(Math.random() * n)</code>  可以取到 0 到 n~1 之间的随机整数，n ~ 1 可以被取到</p><p><code>Math.floor(Math.random() * n) + m</code>  可以取到 m 到 （n-1 + m） 之间的随机整数</p></blockquote><h2 id="9-5-Date"><a href="#9-5-Date" class="headerlink" title="9.5 Date"></a>9.5 Date</h2><h3 id="9-5-1-创建时间日期的对象"><a href="#9-5-1-创建时间日期的对象" class="headerlink" title="9.5.1 创建时间日期的对象"></a>9.5.1 创建时间日期的对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-comment">// 不带参数，data对象中的时间是创建对象那一刻的时间</span><br><span class="hljs-keyword">var</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;December 17, 1995 03:24:00&#x27;</span>);<br><span class="hljs-keyword">var</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2025-04-01 12:12:12&#x27;</span>);<br><span class="hljs-keyword">var</span> date3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2030</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h3 id="9-5-2-实例的属性和方法"><a href="#9-5-2-实例的属性和方法" class="headerlink" title="9.5.2 实例的属性和方法"></a>9.5.2 实例的属性和方法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getFullYear</span><span class="hljs-params">()</span></span>年<br><span class="hljs-function"><span class="hljs-title">getMonth</span><span class="hljs-params">()</span></span>月，值范围 <span class="hljs-number">0</span> ~ <span class="hljs-number">11</span><br><span class="hljs-function"><span class="hljs-title">getDate</span><span class="hljs-params">()</span></span>日<br><span class="hljs-function"><span class="hljs-title">getDay</span><span class="hljs-params">()</span></span>星期几<br><span class="hljs-function"><span class="hljs-title">getHours</span><span class="hljs-params">()</span></span>小时，<span class="hljs-number">24</span>小时进制<br><span class="hljs-function"><span class="hljs-title">getMinutes</span><span class="hljs-params">()</span></span>分钟<br><span class="hljs-function"><span class="hljs-title">getSeconds</span><span class="hljs-params">()</span></span>秒<br><span class="hljs-function"><span class="hljs-title">getMilliseconds</span><span class="hljs-params">()</span></span>毫秒<br><br><span class="hljs-function"><span class="hljs-title">getTime</span><span class="hljs-params">()</span></span><span class="hljs-number">1970</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 至今（对象中的时间）的毫秒数<br><br>getUTC....获取标准时区的年月日时分秒<br><br>set...给对象设置日期时间<br>setUTC...给对象设置标准时区日期时间<br><span class="hljs-function"><span class="hljs-title">setTime</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="9-5-3-Date-构造函数本身的方法"><a href="#9-5-3-Date-构造函数本身的方法" class="headerlink" title="9.5.3 Date 构造函数本身的方法"></a>9.5.3 Date 构造函数本身的方法</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>.now()<span class="hljs-number">1970</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 至今的毫秒数<br><span class="hljs-attribute">Date</span>.UTC()<span class="hljs-number">1970</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 距离指定时间日期的毫秒数； 通过<span class="hljs-number">6</span>个参数指定时间日期<br></code></pre></td></tr></table></figure><h2 id="9-6-Array"><a href="#9-6-Array" class="headerlink" title="9.6 Array"></a>9.6 Array</h2><h4 id="实例的属性"><a href="#实例的属性" class="headerlink" title="实例的属性"></a>实例的属性</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">length</span>数组的长度，可读可写<br></code></pre></td></tr></table></figure><h4 id="实例的方法（修改器方法）"><a href="#实例的方法（修改器方法）" class="headerlink" title="实例的方法（修改器方法）"></a>实例的方法（修改器方法）</h4><p>所谓修改器方法，就是对象调用完该方法之后，对象本身也被修改了，修改器方法并不常见。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>在数组的后面添加一个或多个元素，返回添加之后的长度<br><span class="hljs-function"><span class="hljs-title">unshift</span><span class="hljs-params">()</span></span>在数组的前面面添加一个或多个元素，返回添加之后的长度<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>删除数组的最后一个元素，返回被删除的元素<br><span class="hljs-function"><span class="hljs-title">shift</span><span class="hljs-params">()</span></span>删除数组的第一个元素，返回被删除的元素<br><span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">()</span></span>替换数组中的元素，返回被删除元素组成的数组（没有删除就是空数组）<br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">()</span></span>数组排序，返回排好序的数组<br><span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>翻转数组，返回翻转好的数组<br></code></pre></td></tr></table></figure><h4 id="实例的方法（访问方法）"><a href="#实例的方法（访问方法）" class="headerlink" title="实例的方法（访问方法）"></a>实例的方法（访问方法）</h4><p>对象调用完方法后，结果以返回值的形式返回，不会修改对象本身，大部分方法都是访问方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">concat</span><span class="hljs-params">()</span></span>把多个数组合并为一个，返回合并好的数组<br><span class="hljs-function"><span class="hljs-title">slice</span><span class="hljs-params">()</span></span>截取数组，返回新数组； 参数与字符串的slice方法规则相同<br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span>把数组合并为字符串，返回合并好的字符串。 参数可以指定分隔符，不指定默认逗号<br></code></pre></td></tr></table></figure><h4 id="ES5-增加的方法-（访问方法）"><a href="#ES5-增加的方法-（访问方法）" class="headerlink" title="ES5 增加的方法 （访问方法）"></a>ES5 增加的方法 （访问方法）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">indexOf</span><span class="hljs-params">()</span></span>返回指定的元素第一次出现的位置<br><span class="hljs-function"><span class="hljs-title">lastIndexOf</span><span class="hljs-params">()</span></span>返回指定的元素最后一次出现的位置<br><span class="hljs-function"><span class="hljs-title">forEach</span><span class="hljs-params">(callback)</span></span>遍历数组<br><span class="hljs-function"><span class="hljs-title">filter</span><span class="hljs-params">(callback)</span></span>过滤数组，返回过滤好的新数组；回调函数返回true或false决定当前元素是否加入新数组。map(callback) 返回与原数组长度一致的新数组，新数组中元素的值取决于每次回调函数的返回值。<br><span class="hljs-function"><span class="hljs-title">every</span><span class="hljs-params">(callback)</span></span>返回布尔值。如果所有回调函数都返回true，every() 返回true，否则false<br><span class="hljs-function"><span class="hljs-title">some</span><span class="hljs-params">(callback)</span></span>返回布尔值，只要有一个返回函数返回true，some()就返回true。<br><span class="hljs-function"><span class="hljs-title">reduce</span><span class="hljs-params">(callback [,inital])</span></span>返回最后一次回调函数的返回值<br><span class="hljs-function"><span class="hljs-title">reduceRight</span><span class="hljs-params">(callback [,inital])</span></span>   返回最后一次回调函数的返回值，从后向前遍历<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><p>forEach、filter、map、some、every 的回调函数，都是接收三个参数，分别是当前的元素、元素的索引、调用方法的数组。</p><p>reduce、reduceRight    的回调函数，接收三个参数，分别是初始值（上一个回调函数返回值）、当前元素、元素的索引。</p></blockquote><h2 id="9-7-内置对象"><a href="#9-7-内置对象" class="headerlink" title="9.7 内置对象"></a>9.7 内置对象</h2><h3 id="9-7-1-Function"><a href="#9-7-1-Function" class="headerlink" title="9.7.1 Function"></a>9.7.1 Function</h3><h4 id="实例的属性和方法-1"><a href="#实例的属性和方法-1" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">length返回函数形参的数量<br>call()调用函数并指定函数中的<span class="hljs-keyword">this</span>, 第一个参数是函数中 <span class="hljs-keyword">this</span> 的值，后面的参数任意个，对应函数的参数<br>apply()调用函数并指定函数中的<span class="hljs-keyword">this</span>, 第一个参数是函数中 <span class="hljs-keyword">this</span> 的值，第二个参数是数组，数组元素对应函数的参数<br>bind()相对于 call() 和 apply，bind 返回修改了 <span class="hljs-keyword">this</span> 的新的函数。<br></code></pre></td></tr></table></figure><h3 id="9-7-2-全局对象"><a href="#9-7-2-全局对象" class="headerlink" title="9.7.2 全局对象"></a>9.7.2 全局对象</h3><h4 id="全局对象的方法"><a href="#全局对象的方法" class="headerlink" title="全局对象的方法"></a>全局对象的方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">eval</span><span class="hljs-params">()</span></span>把传入的字符串作为代码执行<br><span class="hljs-function"><span class="hljs-title">encodeURI</span><span class="hljs-params">()</span></span>对 URL 进行编码<br><span class="hljs-function"><span class="hljs-title">decodeURI</span><span class="hljs-params">()</span></span>对编了码的 URL 进行解码<br><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(str, num)</span></span>从字符串中提取数字， num 指定字符串中数字的进制，默认 <span class="hljs-number">10</span>.<br><span class="hljs-function"><span class="hljs-title">parseFloat</span><span class="hljs-params">(str, num)</span></span>从字符串中提取数字， num 指定字符串中数字的进制，默认 <span class="hljs-number">10</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用的正则表达式</title>
    <link href="/2021/01/22/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/"/>
    <url>/2021/01/22/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">数字：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$<br>n位的数字：^\d&#123;n&#125;$<br>至少n位的数字：^\d&#123;n,&#125;$<br>m-n位的数字：^\d&#123;m,n&#125;$<br>零和非零开头的数字：^(<span class="hljs-number">0</span>|[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)$<br>非零开头的最多带两位小数的数字：^([<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$<br>带<span class="hljs-number">1</span>-<span class="hljs-number">2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$<br>正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$<br>有两位小数的正实数：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">2</span>&#125;)?$<br>有<span class="hljs-number">1</span>~<span class="hljs-number">3</span>位小数的正实数：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)?$<br>非零的正整数：^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d*$ 或 ^([<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;$ 或 ^\+?[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$<br>非零的负整数：^\-[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][]<span class="hljs-number">0</span>-<span class="hljs-number">9</span><span class="hljs-string">&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="hljs-string">非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="hljs-string">非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br></code></pre></td></tr></table></figure><h2 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">汉字：^[\u4e00-\u9fa5]&#123;<span class="hljs-number">0</span>,&#125;$<br>英文和数字：^[A-Za-z0-<span class="hljs-number">9</span>]+$ 或 ^[A-Za-z0-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">40</span>&#125;$<br>长度为<span class="hljs-number">3</span>-<span class="hljs-number">20</span>的所有字符：^.&#123;<span class="hljs-number">3</span>,<span class="hljs-number">20</span>&#125;$<br>由<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-Za-z]+$<br>由<span class="hljs-number">26</span>个大写英文字母组成的字符串：^[A-Z]+$<br>由<span class="hljs-number">26</span>个小写英文字母组成的字符串：^[a-z]+$<br>由数字和<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-Za-z0-<span class="hljs-number">9</span>]+$<br>由数字、<span class="hljs-number">26</span>个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;<span class="hljs-number">3</span>,<span class="hljs-number">20</span>&#125;$<br>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$<br>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-<span class="hljs-number">9</span>]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">20</span>&#125;$<br>可以输入含有^%&amp;<span class="hljs-string">&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;</span>,;=?$\x22]+<br>禁止输入含有~的字符：[^~\x22]+<br></code></pre></td></tr></table></figure><h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$<br>域名：[a-zA-Z0-<span class="hljs-number">9</span>][-a-zA-Z0-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">62</span>&#125;(<span class="hljs-regexp">/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/</span>.?<br>InternetURL：[a-zA-z]+:<span class="hljs-comment">//[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br>手机号码：^(<span class="hljs-number">13</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">14</span>[<span class="hljs-number">5</span>|<span class="hljs-number">7</span>]|<span class="hljs-number">15</span>[<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">2</span>|<span class="hljs-number">3</span>|<span class="hljs-number">5</span>|<span class="hljs-number">6</span>|<span class="hljs-number">7</span>|<span class="hljs-number">8</span>|<span class="hljs-number">9</span>]|<span class="hljs-number">18</span>[<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">2</span>|<span class="hljs-number">3</span>|<span class="hljs-number">5</span>|<span class="hljs-number">6</span>|<span class="hljs-number">7</span>|<span class="hljs-number">8</span>|<span class="hljs-number">9</span>])\d&#123;<span class="hljs-number">8</span>&#125;$<br>电话号码(<span class="hljs-string">&quot;XXX-XXXXXXX&quot;</span>、<span class="hljs-string">&quot;XXXX-XXXXXXXX&quot;</span>、<span class="hljs-string">&quot;XXX-XXXXXXX&quot;</span>、<span class="hljs-string">&quot;XXX-XXXXXXXX&quot;</span>、<span class="hljs-string">&quot;XXXXXXX&quot;</span>和<span class="hljs-string">&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ </span><br><span class="hljs-string">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="hljs-string">身份证号：</span><br><span class="hljs-string">15或18位身份证：^\d&#123;15&#125;|\d&#123;18&#125;$</span><br><span class="hljs-string">15位身份证：^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$</span><br><span class="hljs-string">18位身份证：^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$</span><br><span class="hljs-string">短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span><br><span class="hljs-string">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="hljs-string">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="hljs-string">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ </span><br><span class="hljs-string">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="hljs-string">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="hljs-string">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ </span><br><span class="hljs-string">中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="hljs-string">空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="hljs-string">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="hljs-string">首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="hljs-string">腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br><span class="hljs-string">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span><br><span class="hljs-string">IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>水平垂直居中对齐方式(CSS)</title>
    <link href="/2021/01/08/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%EF%BC%88CSS%EF%BC%89/"/>
    <url>/2021/01/08/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%EF%BC%88CSS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="居中元素-定宽高-使用（3种）"><a href="#居中元素-定宽高-使用（3种）" class="headerlink" title="居中元素 定宽高 使用（3种）"></a>居中元素 定宽高 使用（3种）</h3><p>​    absolute + 负margin</p><p>​    absolute + margin：auto</p><p>​    absolute + calc</p><p>​    优点：兼容性好</p><p>​    缺点：需要知道子元素宽高</p><h3 id="公共代码"><a href="#公共代码" class="headerlink" title="公共代码"></a>公共代码</h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML:"></a>HTML:</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;水平垂直居中&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS:"></a>CSS:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid red;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background</span>:green;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-absolute-负margin"><a href="#1-absolute-负margin" class="headerlink" title="1. absolute + 负margin"></a>1. absolute + 负margin</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>; <span class="hljs-comment">//子元素宽度的一半</span><br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>; <span class="hljs-comment">//子元素高度的一半</span><br></code></pre></td></tr></table></figure><h3 id="2-absolute-margin：auto"><a href="#2-absolute-margin：auto" class="headerlink" title="2. absolute + margin：auto"></a>2. absolute + margin：auto</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-absolute-calc"><a href="#3-absolute-calc" class="headerlink" title="3. absolute + calc"></a>3. absolute + calc</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">50px</span>);<br>    <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">50px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="居中元素-不定宽高-使用（7种）"><a href="#居中元素-不定宽高-使用（7种）" class="headerlink" title="居中元素 不定宽高 使用（7种）"></a>居中元素 不定宽高 使用（7种）</h3><ul><li><h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3></li><li><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3></li><li><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3></li><li><h3 id="flex（两种）"><a href="#flex（两种）" class="headerlink" title="flex（两种）"></a>flex（两种）</h3></li><li><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3></li></ul><h3 id="公共代码-1"><a href="#公共代码-1" class="headerlink" title="公共代码"></a>公共代码</h3><h3 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML:"></a>HTML:</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;水平垂直居中&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS:"></a>CSS:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid red;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">background</span>:green;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-absolute-transform"><a href="#1-absolute-transform" class="headerlink" title="1. absolute + transform"></a>1. absolute + transform</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-line-height"><a href="#2-line-height" class="headerlink" title="2. line-height"></a>2. line-height</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>    <span class="hljs-attribute">line-height</span>: initial;<br>    <span class="hljs-attribute">text-align</span>: left; <span class="hljs-comment">/* 修正文字 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-table"><a href="#3-table" class="headerlink" title="3. table"></a>3. table</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: table-cell;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-flex"><a href="#4-flex" class="headerlink" title="4. flex"></a>4. flex</h3><p>第一种：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: flex;<br>&#125;<br>.box &#123;<br>    margin:auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-grid"><a href="#5-grid" class="headerlink" title="5. grid"></a>5. grid</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">align-self</span>: center;<br>    <span class="hljs-attribute">justify-self</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
